{"meta":{"title":"广外编程社官网","subtitle":"","description":"","author":"广外编程社","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-06-19T11:44:43.007Z","updated":"2020-06-19T11:44:43.007Z","comments":true,"path":"baidu_verify_3GIYarUt2r.html","permalink":"http://yoursite.com/baidu_verify_3GIYarUt2r.html","excerpt":"","text":"3GIYarUt2r"}],"posts":[{"title":"（置顶）GZFLS LazyBones 简介","slug":"（置顶）GZFLS LazyBones 简介","date":"2020-06-30T01:35:12.000Z","updated":"2020-06-20T02:23:33.193Z","comments":true,"path":"2020/06/30/（置顶）GZFLS LazyBones 简介/","link":"","permalink":"http://yoursite.com/2020/06/30/%EF%BC%88%E7%BD%AE%E9%A1%B6%EF%BC%89GZFLS%20LazyBones%20%E7%AE%80%E4%BB%8B/","excerpt":"","text":"八十年代，卡内基梅隆大学计算机系的学生们住在一楼，需要跑到三楼的自动贩卖机那里去买可乐。因为可乐的供货量不足，他们经常扑空。为了改变这种状况，懒惰的学生们给贩卖机安装了一组开关，再通过网络把这组开关连接到一楼的电脑上。这样他们在一楼就可以知道三楼的贩卖机里还剩几罐可乐。改变世界的互联网开始形成。 今天，广州外国语学校LazyBones广外编程社正如其名，以懒惰为动力。通过编程快速解决数学难题、进行繁琐的等分统计工作、制作全自动化运行的excel运算脚本、逃脱头发太多难以清洗的噩运…… 线下批改试卷太繁琐，我们就上线调查系统，印刷传单太麻烦，我们就开发门户网站。高考提分太难，我们就参加自主招生…… 走进编程的世界，懒人高效触手可及。 我们始终信奉，懒惰是第一生产力。 学习资源编程部： 请通过以下链接查看 [GitHub项目](https://github.com/LazyBonesMembers/Learning-Material/tree/lessons/upload files) 算法竞赛入门经典 游戏部： 请通过以下链接查看： [GitHub项目](https://github.com/LazyBonesMembers/Learning-Material/tree/lessons/upload files) RPG Maker国内论坛 RPG Maker国外论坛 项目进展简介目前，社团主要致力于使用以下引擎开发项目：1.RPG MakerRPG Maker是基于HTML5的，使用JavaScript的，具有图形界面的2D游戏引擎 我们已经成功地使用该引擎开发或参与开发了“摩尔勇士复刻版”、“广外主题游戏” 2.Cocos-2dxCocos-2dx是基于c++的开源免费2D游戏引擎 我们使用该引擎开发了微信打飞机游戏复刻版 3.HTML5网页语言和Markdown语言由于需要维护及更新社团的网站，我们需要熟悉网页代码以及markdown语言的人才 此项目的成员会参与到社团网站的维护与更新 4.基于c++的dos界面游戏开发少于400行短小精悍的代码，就可以构成一个有趣好玩的dos游戏！ 我们由此方法复刻了经典的扫雷、打飞机、躲避柱子游戏 不仅如此，我们还可以为需要开发c++图形界面的社员提供支持。 5.基于UE4引擎的3D项目开发Unreal Engine 4 ，当今无比强大的基于c++的游戏引擎。 LazyBomes社员们有一个宏愿，就是希望使用UE4开发以我们的母校——广州外校为主题的游戏 这是一个复杂的系统工程，需要持续至少两年以上的努力 涉及到无数个精密的3D模型，成千上万行准确无误的代码，甚至是价格不菲的专业图形显卡…… 我们非常清楚，这个项目所需要的巨大努力，需要我们倾其所有 但是，对母校的热爱，对技术的执着推动着我们不断前行 同时，我们希望团结一切可以团结的力量 我们迫切地需要3D建模、UE4引擎的人才 如果你我同时广州外国语学校学子，又有意向参与到这个宏大的项目中来，或者具有这方面的才能 请一定要联系我们 项目负责人qq：2364045898 想要更多地了解UE4引擎，请进入文末的UE4官网链接 公告栏此网站是基于GitHub免费的境外服务器 请各位社员妥善使用，请勿外传，以免服务器压力过大影响使用 社团活动时间：周三中午 社团活动地点：凤凰楼四楼计算机教室 通知请各位活跃社员尽快加入社团QQ群 群号：855055234 并留意此网站上的活动通知 实用链接: Lazybones社员网站 广州外国语学校官网 菜鸟教程 markdown语言编辑器Typora UE4官网 C++ —游戏制作（RPGMakerMV，资源请自行寻找，建议正版） ╚汉化教程 ╚国内论坛 ╚国外论坛（英语） —编程练习题目 洛谷 CCF OJ","categories":[],"tags":[{"name":"置顶","slug":"置顶","permalink":"http://yoursite.com/tags/%E7%BD%AE%E9%A1%B6/"}]},{"title":"Anaconda是什么？香吗？","slug":"Anaconda是什么？香吗？","date":"2020-06-20T13:26:28.000Z","updated":"2020-06-21T01:15:44.009Z","comments":true,"path":"2020/06/20/Anaconda是什么？香吗？/","link":"","permalink":"http://yoursite.com/2020/06/20/Anaconda%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E9%A6%99%E5%90%97%EF%BC%9F/","excerpt":"","text":"Anaconda是什么？香吗？ 用Anaconda是不可能用Anaconda的，这辈子都不可能用Anaconda的。——鲁迅 （本文由吃核桃不吐核桃壳编写，未经许可不允许转载） Anaconda是什么？？？有很多人在网上问：“装了Anaconda还需要Python吗？”每次听到这个问题，我就傻了——Anaconda不就是Python吗？Anaconda其实就是一个Python的发行版，她自带了Ipython，Cython等Python解释器，以及例如numpy，panda等有关数据分析的常用第三方库，spyder，Jupyter等工具，当然还有最终于的库管理神奇：conda。一开始，我一直在使用官网的Cython解释器，听说Anaconda的时候，也只是看看而已，甚至还有一些抵触情感。比普通的Python解释器更大的大小，多出来的无用的功能，都让我觉得仿佛失去了Python的灵魂。直到我真的尝试了一下Anaconda…… 真香。——鲁迅 吹爆Anaconda！Anaconda是最令人省心的Python解释器。我以前一直不相信，直到我入门了机器学习领域。机器学习需要用到的是大量的第三方库，然而Anaconda已经帮你解决了这些繁琐的安装。一步到位，捷足先登。 开源，没啥好说的。 安装的过程非常的简单！连环境变量都不需要自己设置！ 拥有免费的社区支持。每天有无数个程序员在参与Anaconda的更新与建设！ 而且臃肿的功能也得到了解决，如果和我一样不希望拥有一个很大的Python解释器，可以下载Miniconda这个较小的发行版，仅仅包含了Python和conda。但不可否认，这样极端的处理方式的确是Anaconda的一个缺点，如果能够通过选择自己所属的领域和需要的库来生成安装包就完美了！ 同时，Anaconda还有虚拟版本等等很强大的功能，我将会在下文为大家介绍。 安装Anaconda这里只提及Windows下的anaconda安装，至于Mac和Linux可以参考这篇文章Anaconda介绍、安装及使用教程 去官网下载。选择适合自己的安装包下载。（64位or32位，python3.7or2.7） 双击安装包文件开始安装~ Info 如果在安装过程中遇到任何问题，那么暂时地关闭杀毒软件，并在安装程序完成之后再打开。 如果在安装时选择了“为所有用户安装”，则卸载Anaconda然后重新安装，只为“我这个用户”安装。选择“Next”。 阅读许可证协议条款，然后勾选“I Agree”并进行下一步。 除非是以管理员身份为所有用户安装，否则仅勾选“Just Me”并点击“Next”。 在“Choose Install Location”界面中选择安装Anaconda的目标路径，然后点击“Next”。 在“Advanced Installation Options”中不要勾选“Add Anaconda to my PATH environment variable.”（“添加Anaconda至我的环境变量。”）。因为如果勾选，则将会影响其他程序的使用。如果使用Anaconda，则通过打开Anaconda Navigator或者在开始菜单中的“Anaconda Prompt”（类似macOS中的“终端”）中进行使用。 除非你打算使用多个版本的Anaconda或者多个版本的Python，否则便勾选“Register Anaconda as my default Python 3.6”。 然后点击“Install”开始安装。如果想要查看安装细节，则可以点击“Show Details”。 点击“Next”。 进入“Thanks for installing Anaconda!”界面则意味着安装成功，点击“Finish”完成安装。 注意：如果你不想了解“Anaconda云”和“Anaconda支持”，则可以不勾选“Learn more about Anaconda Cloud”和“Learn more about Anaconda Support”。 验证安装结果。可选以下任意方法： “开始 → Anaconda3（64-bit）→ Anaconda Navigator”，若可以成功启动Anaconda Navigator则说明安装成功。 “开始 → Anaconda3（64-bit）→ 右键点击Anaconda Prompt → 以管理员身份运行”，在Anaconda Prompt中输入conda list，可以查看已经安装的包名和版本号。若结果可以正常显示，则说明安装成功。 自行添加环境变量（可选）为了保证其他程序的正常运行，我们没有勾选“Add Anaconda to my PATH environment variable.”但是在cmd里打Python却打不开的感觉真的很不舒服。所以我们来自行添加一下环境变量。 右键“此电脑”，属性。 单击左侧的高级系统设置 点击环境变量 找到path环境变量，并添加这四行（根据自己的安装路径添加，我这里是D:\\Anaconda） win+R输入cmd回车打开命令行，输入python，你会看到这个： Yep！We got it！到这里，我们的安装就正式结束了，享受它给你带来的便利以及你的编程之旅吧！ （先去喝杯可乐，听一首歌吧（我这里在听Don‘t look back，啊这好像是废话，不应该写到blog里的）） conda的使用 我们来看一下conda。 conda和pip一样，是库管理工具。但相比pip，conda有以下的优点：→ 依赖项检查 pip： 不一定会展示所需其他依赖包。 安装包时或许会直接忽略依赖项而安装，仅在结果中提示错误。 conda： 列出所需其他依赖包。 安装包时自动安装其依赖项。（哇塞这个真的舒服啊） 可以便捷地在包的不同版本中自由切换。→ 环境管理 pip：维护多个环境难度较大。 conda：比较方便地在不同环境之间进行切换，环境管理较为简单。→ 对系统自带Python的影响 pip：在系统自带Python中包的更新/回退版本/卸载将影响其他程序。 conda：不会影响系统自带Python。→ 适用语言 pip：仅适用于Python。 conda：适用于Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN。 conda的常用姿势1conda --version 这一条命令会输出conda的版本，如果没有报错说明的你conda可以正常使用。 1conda update conda 更新conda 1conda update --all 更新所有的包 1conda install &lt;packet-name&gt; 安装某一个包，这里会自动安装依赖项，不用担心。（这里的并不是让你打“”，而是代表包的名字，下文同）这里可能会出现请求失效或者404错误，需要还成国内的源，步骤如下： 添加清华的镜像源，命令如下123456conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;pkgs&#x2F;free&#x2F;conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;conda-forge conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;msys2&#x2F;# 设置搜索时显示通道地址conda config --set show_channel_urls yes 哦对了，如果需要安装pytorch，还要多加一个源:1conda config --add channels https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;anaconda&#x2F;cloud&#x2F;pytorch&#x2F; 1conda list 列出已经安装的包 更多的命令可以输入conda help查看 重头戏，环境管理。想象一下，你千辛万苦的搞定了python3.7的环境，忽然接到同事的电话，告诉你有一个新的项目，用的python2.7。是不是心态崩了呢？？？难道需要再安装一个2.7的python解释器吗？当然不用，环境管理正是anaconda的拿手好戏。 创建一个新的环境1conda create --name &lt;env_name&gt; &lt;package_names&gt; 这一条命令将会创建一个新的python环境。 注意： 即创建的环境名。建议以英文命名，且不加空格，名称两边不加尖括号“&lt;&gt;”。 即安装在环境中的包名。名称两边不加尖括号“&lt;&gt;”。 如果要安装指定的版本号，则只需要在包名后面以=和版本号的形式执行。如：conda create –name python2 python=2.7，即创建一个名为“python2”的环境，环境中安装版本为2.7的python。 如果要在新创建的环境中创建多个包，则直接在后以空格隔开，添加多个包名即可。如：conda create -n python3 python=3.5 numpy pandas，即创建一个名为“python3”的环境，环境中安装版本为3.5的python，同时也安装了numpy和pandas。 –name同样可以替换为-n。 提示：默认情况下，新创建的环境将会被保存在anaconda目录下的envs目录下。 切换环境 1activate &lt;env_name&gt; 这一步需要在anaconda prompt里运行。 列出已经创建的环境 1conda info --envs 尾声这一篇博客到这里就要结束了。希望能帮助各位，在这里祝愿大家能够把编程坚持学下去，我也会在这一条路上帮助大家的。 参考资料： https://www.jianshu.com/p/62f155eb6ac5 https://zhuanlan.zhihu.com/p/67745160 https://www.anaconda.com/products/individual https://conda.io/en/latest/ https://en.wikipedia.org/wiki/Pip_(package_manager)#External_links https://pip.pypa.io/en/stable/","categories":[],"tags":[{"name":"pyrhon","slug":"pyrhon","permalink":"http://yoursite.com/tags/pyrhon/"}]},{"title":"RPG Maker MV 帮助文档中文汉化版","slug":"RPG Maker MV 帮助文档中文汉化版","date":"2020-06-20T03:26:28.000Z","updated":"2020-06-20T02:46:46.273Z","comments":true,"path":"2020/06/20/RPG Maker MV 帮助文档中文汉化版/","link":"","permalink":"http://yoursite.com/2020/06/20/RPG%20Maker%20MV%20%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E4%B8%AD%E6%96%87%E6%B1%89%E5%8C%96%E7%89%88/","excerpt":"","text":"RPG Maker MV 帮助文档中文汉化版本帮助文档含有对「RPG Maker MV」所具有的功能的说明。窗口的左侧为帮助的目录。在左侧选择你想要阅读的项目。 此外，本软件大部分项目都有弹出的提示。把鼠标指针停留在编辑器上的项目一段时间之后，就会显示简单的说明。请善于运用这个功能。 更新历史 RPG Maker MV &gt; 更新历史 2017 年 6 月 8 日更新 Added “Edit as Text” option to the Plugin Manager context menu. ・［RPG Maker MV］→［How to Use Aid Tools］ Added several search options for all context menus: “Search”, “Search Next”, and “Search Previous”. ・［RPG Maker MV］→［Basic Editor Controls］ Added the “Community_Basic” plugin. ・Documentation［Using Official Plugins］ 2017 年 3 月 21 日更新 It is now possible to use RPG Maker MV Tools in conjunction with RPG Maker MV. ・［RPG Maker MV］→［The Menu Bar］ ・［RPG Maker MV］→［How to Use Aid Tools］ Added tutorials (beta). ・［RPG Maker MV］→［The Menu Bar］ ・［RPG Maker MV］→［How to Use Aid Tools］ RPG Maker MV is now available for Linux. ・［RPG Maker MV］→［About RPG Maker MV］→［System Requirements］ ・Documentation［Deployment］ ・Documentation［RPG Maker MV for Linux］ ・Documentation［RPG Maker MV for Linux］→［Graphics Driver Installation］ ・Documentation［RPG Maker MV for Linux］→［Running Games］ 2016 年 11 月 24 日更新 Added an option to generate child characters in the Character Generator. ・［How to use Aid Tools］→［Character Generator］ 2016 年 8 月 4 日更新 You now have the option to use encryption for deployment. ・Documentation［Output Formats］ Added an Object Selector option. ［How to Use Aid Tools］→［Options］ Added options to “Copy as Text” and “Copy as HTML tags” to the context menu of the Contents section on the Event Page. Events ［Map Event Settings］→［Editing Contents］→［Controls via the Context Menu］ 2016 年 4 月 21 日更新 You can now handle files in batches with the Resource Manager tool. A [DLC] button has been added to the Resource Manager. (For Steam versions only) [How to Use Aid Tools]→[Resource Manager] Added a counterclockwise rotation function to the event command [Rotate Picture]. ・Event Commands[Picture]→[Rotate Picture] Added [Options] to [Tools]. [How to Use Aid Tools]→[Options] Added an editor DPI scaling function to the Windows version. The UI display in the editor is automatically adjusted when you change the DPI settings in Windows. Added a scroll wheel zoom in/zoom out function for the map. (For Windows users) Ctrl + Scroll Wheel (For Mac users) Command + Scroll Wheel Added [Refresh] to the Plugin Manager. Documentation →[Enabling Plugins]→[Refreshing Plugins] Fixed a bug in the looping for part of the music data. The [Passage] indicator for Tileset [B] on the upper-left of the tile has been fixed to ☆. Added and updated plugins. 2016 年 3 月 1 日更新 合成方式新增正片叠底。 ・数据库 [动画设置] ・事件指令 [移动]→[设置移动路线] [图片]→[显示图片][移动图片] 现在可以通过右键菜单打开插件帮助界面。 ・数据库 [角色设置][职业设置][技能设置][物品设置][武器/防具设置] [敌人设置][状态设置][图块组设置] ・事件指令 [信息]→[显示文字][显示滚动文字] [流程控制]→[条件分歧][注释] [高级]→[脚本][插件命令] 当变更角色职业时，你可以选择保留职业变更前的等级。 事件指令[角色]→[更改职业] 你可以通过右键菜单查看图标列表。 ・事件指令 [信息]→[显示文字][显示滚动文字] [高级]→[脚本][插件命令] ・[如何使用辅助工具]→[插件管理器] 新增素材管理器。 ・[如何使用辅助工具]→[素材管理器] 发布平台中新增 [Web Browsers（网页浏览器）]。 打包界面新增 [Exclude unused files（不包含未使用文件）] 选项。 ・资料集 [输出格式] 新增 触屏UI、扭蛋、老虎机插件。 ・资料集 [使用官方插件]→[TouchUI] [使用官方插件]→[Gacha / GachaBook] [使用官方插件]→[SlotMachine] 动画设置中新增洋葱皮功能。 在控制帧预览界面可以同时显示多个帧的内容。 退出编辑时弹出提示对话框。 当你在编辑 事件/数据库/插件管理器 的内容时，点击取消键或者关闭按钮时会弹出提示对话框。※ 若选择了 [Yes（确定）], 窗口将关闭，未保存的内容将丢失。 支持 Home/End 键。 当你在编辑事件页时，你可以使用键盘上的 Home/End 键来快速跳转到事件的 开头/末尾 。 压缩音频文件和图像文件的体积。 纸娃娃生成器中增加更多部件。 初识 RPG Maker MV RPG Maker MV &gt; 初识 RPG Maker MV RPG Maker MV 是专为制作角色扮演游戏而生的制作工具。本工具制成的游戏，即使玩家没有工具也可以游玩。 支持格式 RPG Maker MV &gt; 初始 RPG Maker MV &gt; 主要功能 &gt; 支持格式 RPG Maker MV Mac 版用户期盼已久的RPG制作大师Mac版终于推出！软件的整体界面也针对Mac做出了调整，用户将能在熟悉的界面上制作游戏。 支持多种输出格式本作的游戏将输出为 HTML5 格式，使用这一格式，完成的游戏将可以发布在 Windows、Mac OS X、安卓、iOS平台，甚至作为网页游戏在线发布。更多信息请参考 [输出格式] 部分。 )地图 RPG Maker MV &gt; 初识 RPG Maker MV &gt; 主要功能 &gt; 地图 整个游戏世界以一张张地图作为舞台。在 RPG Maker MV 中，地图绘制的功能得到了大幅强化，得益于此，您将能创造出更加丰富的世界。 主要功能更丰富的世界 游戏分辨率从 544x416 扩展到了 816x624。 上层的两个图块组将能自动合并。 RPG Maker VX Ace RPG Maker MV 区域编辑功能强化您可以使用地图着色工具进入区域编辑模式。区域的最大数量则从63增加至了255，现在，您将可以编辑区域的更多细节。 地图保存成图片在地图列表中右键选择[Save as Image]将能够把您的地图保存成图片。 插件脚本 RPG Maker MV &gt; 初识 RPG Maker MV &gt; 主要功能 &gt; 插件脚本 传统的脚本编辑器已经移除，取而代之的将是一个更简单的脚本管理工具。在新工程中已经预置了一部分官方脚本，您可以直接使用。* 更多的内容请参考 [开启脚本] 以及 [使用官方脚本] 。 * 另外， [脚本规格] 部分包含数据库 RPG Maker MV &gt; 初识 RPG Maker MV &gt; 主要功能 &gt; 数据库 包括游戏角色、物品、技能与魔法在内游戏主要的数据都能在数据库中编辑和管理。 主要特点 增加数据库最大值 数据库内容的最大值已经增加。 现在，技能、物品、武器、防具、敌人和敌群数据最多都将达到2000条。 （相比前代增加了1000条） 简单而又强大的功能 数据库的复制功能支持多选。之前只能通过脚本修改的提示文字也能通过 [用语] 部分修改。装备类型（手部装备，脚部装备等）现在可以通过 [属性] 部分进行增删。游戏中菜单部分显示的选项可以通过 [系统] 部分进行修改。[物品] 部分可以设置 [物品类型] 为 [隐藏物品 A, B] 。 了脚本相关规格的说明。横版战斗 RPG Maker MV &gt; 初识 RPG Maker MV &gt; 主要功能 &gt; 横版战斗 在保留了前作纵版战斗的基础上，现在还可以使用横版战斗模式。 横版战斗需要设置的内容需要使用横版战斗模式时，您需要额外进行以下的设置来定制角色以及画面的外观。 系统: Use Side-view Battle 该选项打勾时，游戏中的战斗将使用横版战斗模式。 请查看数据库一节的: [系统设置] 部分来获取更多信息。 系统: Magic Skills 在这里设置技能的类型以设置战斗时角色的咏唱动作。 请查看数据库一节的: [系统设置] 部分来获取更多信息。 系统: Attack Motions 设置各个属性技能攻击时播放的动画。 请查看数据库一节的: [系统设置] 部分来获取更多信息。 角色: Battler 设置角色在战斗时显示的图片。 请查看数据库一节的: [角色设置] 部分来获取更多信息。 状态: Motion 设置角色在特定状态时显示的图片。 请查看数据库一节的: [状态设置] 部分来获取更多信息。 状态: Overlay 设置角色在特定状态时显示在角色上方的图片。 请查看数据库一节的: [状态设置] 部分来获取更多信息。例如，当玩家与NPC对话或者打开一个宝箱时，一个事件便发生了。 主要特点 事件测试功能 不运行游戏即可方便地测试图片的显示、移动以及旋转。 事件指令增加 事件指令增加了以下几条：Actor: [Change Profile（更改角色说明）]Actor: [Change TP（更改TP）]System Settings: [Change Vehicle BGM（更改交通工具BGM）]System Settings: [Change Defeat ME（更改战败ME）]Battle: [Change Enemy TP（更改敌人TP）]Advanced: [Plugin Commands（插件脚本指令）] 显示选项功能强化 选项的最大个数从4个增加到了6个，你还可以设置选项窗口的位置和不透明度。其他 RPG Maker MV &gt; 初识 RPG Maker MV &gt; 主要功能 &gt; 其他 事件搜索新增了事件搜索功能。请参考 [使用辅助工具] 部分来获取更多的内容。 声音设置部分新增声场设置声音设置部分可以设置背景音乐（BGM）、背景声音（BGS）、音效（SE）的声场位置。通过改变声场，您将能调整声音在扬声器左右声道的音量大小。 运行游戏 RPG Maker MV &gt; 初识 RPG Maker MV &gt; 主要功能 &gt; 运行游戏 使用RMMV制作出来的游戏同样得到了增强。 主要特点 您将可以通过拉伸窗口调整游戏画面的大小。 按住确定键将能快速跳过事件。 游戏菜单中新增了 [Option（设置）] 指令。 相比前作，本作的战斗节奏加快。 战斗过程中，选择指定角色时该角色的图像将会变亮。 受到的伤害值将会直接显示在战斗画面中。 敌人的状态图标将直接显示在其图像的上方。 上一次使用的技能将被记忆。 如果地图和战斗界面背景音乐相同时，背景音乐将会继续播放。 游戏标题将保存在存档中，你可以根据游戏的进行在标题栏显示不同的标题。 最大存档数目从16个增加至20个。 编辑游戏目录下的CSS文件(/fonts/gamefont.css)即可更换游戏的字体。 * 要更换字体还需把字体文件复制到该目录下。 在测试模式下，按F8可以打开开发者工具。 请参考 [ 如何使用开发者工具 ] 部分来获取更多信息。 将游戏目录上传到服务器后您可以在线进行游戏。请参考 [运行游戏所需的系统要求] 部分来获取更多信息。本作的配置需求如下： 操作系统 Windows 7/8/8.1/10 (32 位/64 位) Mac OS X 10.10 及其更高版本 Debian 8 及其更高版本 (2017 年 3 月 21 日更新) CPU Intel Core 2 双核或以上 内存 至少2GB 硬盘 至少 2GB 的空余硬盘空间 显卡 需要支持 OpenGL 显示器 1280×768 分辨率或更高 产品验证需要通过网络进行。 顺畅游玩所需要的配置因作品内容而异。 Linux 系统请通过 Debian8 而非 SteamOS 来运行 RPG Maker MV。 准备开始制作你的游戏 RPG Maker MV &gt; 准备开始制作你的游戏 创建新工程要开始制作你自己的游戏，首先你需要创建一个“工程”。一个工程包含了所有构成一个游戏的数据和资料。当然，你也可以导入你自己的文件，例如图片和音乐，以便在工程当中使用。 创建工程的方法如下。 (1) 创建新的工程 在工具栏中点击[New Project]按钮，或者点击菜单栏上的[File]然后选择[New Project]选项。 (2) 输入储存的位置和工程标题 输入工程的名字 (建议输入半角英文数字字符),并在[Game Title]标签下输入你的游戏标题。工程的存储位置会显示在[Location]标签下。要变更储存位置，点击右边的[Choose… ]按钮来指定一个新的存储位置。 当完成上面的设定后，点击[OK]，这样一个样本游戏就会被创建，之后你就可以开始制作你的游戏了。 管理工程 保存/打开工程 当你在制作游戏过程中需要休息一下时，确保你已经保存了工程然后再关闭它。当你点击[Save Project]按钮(或者点击菜单栏中的[File]并选择[Save Project]选项)，当前正在编辑的工程会被最新内容覆盖，整个工程就被保存下来了。 要继续制作游戏，点击[Open Project]按钮(点击菜单栏中的[File]并选择[Load Project]选项)，然后选择[Game]文件(或者[Game.rpgproject])并点击[Open]. 备份/删除 工程的内容会被保存在你最初建立新工程时指定的文件夹中。要备份此工程，你需要将整个文件夹的内容复制到闪存盘或者其他设备上。当你不再需要一个工程时，直接删除这个文件夹即可。 继续制作你的游戏本软件所制作的RPG游戏由很多部分组成，例如屏幕上的图片，玩家控制的角色，道具和魔法的设置，进攻行为的设置以及故事剧情。 在本软件中，这些元素由三种数据类型制作，这些数据是你游戏的核心：地图[Map]，这是你游戏的舞台；事件[Events]决定着游戏中发生了些什么；还有数据库[Database]，这决定了一些游戏对象(如角色)的基本设定。 制作游戏没有特定的顺序。如果这是你第一次使用本软件制作游戏，建议你先学会如何绘制地图。然后，你就可以为游戏内容添加事件和角色了。 基本编辑器控制 RPG Maker MV &gt; 基本编辑器控制 各个窗口组件的名称和功能打开工程后显示的窗口称为“主窗口”。主窗口主要用于编辑地图和事件。例如[Database]这样的工具箱就是在主窗口菜单中打开的。各个组件的功能如下。 (1) 菜单栏 这个软件的可用功能可以从这里选择。 (2) 工具栏 一些特定功能可以通过点击上面的按钮来打开。 (3) 图块板 绘制地图的可用图块都在这里显示。你可以利用下面的标签来切换成组/区域编辑模式。 (4) 地图列表 显示当前游戏所创建的所有地图数据的列表。 (5) 地图预览 显示当前所选择的地图中的内容。它主要被用来绘制地图和指定事件放置的位置。 (6) 状态栏 显示当前所选功能的详细信息，地图名和地图坐标。 编辑参数在使用本软件制作游戏时，制作过程的核心是在各类窗口中调节对象的可用参数，并指定像文本和道具这样的游戏内容。下面是可设定的项目以及他们的编辑方式。 输入文本 当你点击设置区域，”|”光标就会出现。在这种状态下使用键盘输入文本，文本会出现在光标的位置上。你也可以使用键盘上的方向键移动光标。输入文本的方式取决于你所使用的输入法。 输入数值 就像输入文本一样，当点击参数的区域时，”|”光标就会出现。在这种状态下使用键盘输入半角数字。通过点击设置区域右边的[∧] 和[∨]按钮，你可以增加或减少数值。 单选框 从多个项目中选择一项。点击[○]按钮后，中间有黑点的选项处于选中状态。 复选框 启用/禁用旁边所显示的参数。点击[□]按钮后，对应参数被启用。再次点击一次会撤销选中的状态。 下拉列表 从列表中选择一项。你可以通过点击设置区域右侧的[∨] 箭头来打开列表。 列表框 在列表中显示多项设定。通过双击一个项目，你可以增添或变更窗口中的内容。 […]按钮 有些项目的详细信息在另外的独立窗口中显示，这些项目的设置区域右侧会有一个[…]按钮。点击[…]按钮，并在打开的窗口中设置你的参数。 [OK] [Cancel] [Apply]按钮 当你要完成你所做的更改时，应该使用这些按钮。点击[OK]按钮确认更改并关闭窗口，点击[Cancel]放弃当前更改并关闭窗口，而点击[Apply]按钮则是确认更改但不关闭窗口。 Searching via a Context Menu (June 8th, 2017 Update)The context menu can be opened by right clicking on a map or database. From there, you can select the [Search] option. The [Search] window will then open. After searching once, you can select [Search Next] or [Search Previous] to continue searching for the same text. ) 菜单栏 RPG Maker MV &gt; 菜单栏 有关主窗口菜单栏中的选项的细节如下。 [File]菜单 New Project 创建新的工程。如果一个工程已经被打开，那么当创建新工程的同时，这个工程将会被关闭。 Open Project 打开保存的工程，这使得你可以继续编辑你的游戏。进入到你的工程目录，并在[open]窗口中选择你的Game文件。 Close Project 关闭当前打开的工程。如果数据未保存，那么你将会看到一个确认对话框。点击[Yes]将保存并关闭工程，点击[No]将关闭工程，但是不保存。 Save Project 保存你当前正编辑的工程的内容。 Deployment 根据你所选发布平台建立你的工程。具体请参考[输出格式]。 Exit RPG Maker MV 关闭程序。和[Close Project]一样，如果有未储存的数据，那么你将会看到一个确认窗口。 [Edit] 菜单 Undo 允许你撤销刚刚的操作，将工程恢复到一步之前的状态。你至多可以撤销20步操作。 Cut 将你选中的内容(例如地图数据和地图事件)删除，并把它们复制到剪贴板上。 Copy 将你选中的内容(例如地图数据和地图事件)复制到剪贴板上。 Paste 将剪贴板上的内容(例如地图数据和地图事件)添加到所选位置。 Delete 删除选中的数据(例如地图数据和地图事件)。 [Mode] 菜单 Map 切换到地图设计器模式。 Event 切换到事件编辑模式。在此模式下，地图上会出现网格，网格的大小和图块大小相当。 * 在图块窗口选择[R]标签可以进入区域编辑模式，在此模式下你可以决定敌人将出现在何区域(遇敌区域)。 [Draw] 菜单在图块上绘制的工具已经可以在地图编辑模式下使用了。详情请参考[编辑地图] 。 [Scale] 菜单 Zoom In 当你每次选择“放大”时，地图预览窗的内容会变得更大。 Zoom Out 当你每次选择“缩小”时，地图预览窗的内容会变得更小。 Actual Size 以标准大小显示地图(实际大小和当前编辑器中的大小相同). [Tool] 菜单 Database 打开[Database]窗口，以便创建/编辑游戏数据(例如角色和道具)。 Plugin Manager 你在这里管理你的插件。详情请参考[如何使用辅助工具]。 Sound Test 你可以播放导入到工程中测试声音。详情请参考[如何使用辅助工具]。 Event Searcher 你可以使用各种各样的条件搜索事件。详情请参考[如何使用辅助工具]。 Character Generator 将事先做好的素材组合起来，生成角色脸谱，行走图，战斗图。详情请参考[如何使用辅助工具]。 Resource Manager you are able to manage resources included in your project. Please see [How to use Aid Tools] for more information. RPG Maker MV Tools (March 21st, 2017 Update) Organize tools to help you create games in RPG Maker MV. Please see [How to use Aid Tools] for more information. [Game] 菜单 Playtest 开始游戏测试。详情请参考[如何使用辅助工具]。 Open Folder 打开工程所在的文件夹。当你要查看工程文件夹的位置或者手动将文件移动到工程文件夹中时，请使用这个功能。 [Help] 菜单 Contents 显示帮助窗口(本窗口)。 About 显示此软件的版本信息。 Tutorials (Beta) (March 21st, 2017 Update) Users can now view tutorials (beta) in-game. Please see [How to use Aid Tools] for more information. 如何使用辅助工具 RPG Maker MV &gt; 如何使用辅助工具 Plugin Manager（插件管理器）选择[Tools（工具）] → [Plugin Manager（插件管理器）]就可以打开[Plugin Manager（插件管理器）]，使用[Plugin Manager（插件管理器）]你就可以管理官方插件和你自制的插件。 当你点击列表中显示的一个插件时，会出现一个对话框。在对话框中你可以启用/禁用此插件或者调节一些参数值。 (2016 年 3 月 1 日更新)当输入参数时，右键打开菜单，选择[IconSet Viewer…]可以显示图标查看器。 (2017 年 6 月 8 日更新) Click one of the plugin parameters to open the menu. You can make edits to plugin parameters on the [File] and the [Text] tabs. Sound Test（声音测试）选择[Tools（工具）] → [Sound Test（声音测试）]你就可以打开[Sound Test（声音测试）]窗口，在这里你可以测试工程中的音乐和声音文件。当你关闭声音测试窗口时，音乐会继续播放。因此你可以使用此功能来在制作游戏的同时播放背景音乐。 窗口被分为四个标签页：BGM（背景音乐），BGS（背景声音），ME（音效）和 SE（声效）。你可以在各个标签页的文件列表中选择音乐。当你点击[Play（播放）]按钮时音乐就会开始播放。点击[Stop（停止）]按钮时音乐播放就会停止。 你可以通过旁边的滑动条来分别调节声音的 Volume（音量）（0 ~ 100%），Pitch（音调）（50 ~ 150%）和 Pan（声场定位）（-100 ~ 100）。 Event Searcher（事件查找器）选择[Tools（工具）] → [Event Searcher（事件查找器）]你就可以打开[Event Searcher（事件查找器）]，在这里你可以通过开关，变量，名称来查找事件，并把它们显示在列表当中。 Character Generator（角色生成器）(2016 年 11 月 24 日更新)选择[Tools（工具）] → [Character Generator（角色生成器）]来打开角色生成器。在这里你可以生成角色的图形，并把它们分配到主角和事件中去。 点击[Male（男）]、[Female（女）]或[Kid（儿童）]标签来改变体型，并根据你想要的特点来选择变化和颜色。你的选择也会在[Preview（预览）]区域中显示。 Randomize（随机） 随机设置所有部分。 Face Image（头像） 打开角色头像的导出窗口。 Walk Character（角色行走图） 打开角色行走图的导出窗口。 Damage Character（角色倒地图） 打开角色倒地图的导出窗口。 Battler（战斗图） 打开横版战斗图的导出窗口。 Save Settings（保存设置） 存储所制作的角色数据。 Load Settings（载入设置） 载入保存的角色数据。 导出窗口 Import 从文件中导入一张待修改的基础素材图，并将当前制作的新素材插入其中。 Export 将当前图像导出为文件。 Generate Dungeon（迷宫生成器）右键点击地图列表中的地图并选择[Generate Dungeon（迷宫生成器）]即可打开迷宫生成器。 当你选择墙体和地板图块时，地图会自动被绘制成迷宫的样子。由于要在所选地图上生成一个迷宫，因此当你要生成大型迷宫时，你需要增加地图尺寸。如果地图尺寸太小，那么生成出来的地图会不太像一个迷宫。 Type（种类） 有[Rooms（房间）]和[Maze（迷宫）]两种风格可选。当你选择[Rooms（房间）]，迷宫生成器就会生成一个带有房间和过道的迷宫；当你选择[Maze（迷宫）]，那么生成的迷宫只会有过道（也就是所谓真正意义上的迷宫）。 Options（选项） Add Margins（添加边缘）当选择此选项时，地图的上、下、左、右会自动添加边缘。Wide passages（通道加宽）当选择此选项时，迷宫中的过道会变宽。 Wall 选择填充墙体的图块。 * 从正在使用的 A4 (墙体) 图块组中选择。 Floor 选择填充地板的图块。 * 从正在使用的 A5 (地板) 图块组中选择。 Playtest（游戏测试）你可以在制作游戏过程中的任何阶段使用[Playtest（游戏测试）]功能来测试你的游戏，这项功能可以在菜单栏中的[Game（游戏）] → [Playtest（游戏测试）]找到。通过进行游戏测试，你可以在游戏发布之前查看游戏的背景和事件是否按照预期进行运作。 使用调试功能 当运行游戏测试时，按下键盘上的 F9 会打开调试窗口。在这里你可以改变屏幕中所显示的开关和变量的值。 * 在调试界面再按下[F9]即可返回游戏测试。 要改变变量的值，你需要选择目标开关/变量，（上方的 S 表示开关，下方的 V 表示变量，旁边的数字表示编号范围），然后按下决定键，右侧的目标开关/变量窗口会出现一个光标。使用决定键来改变开关的 ON/OFF 值，使用左右方向键和 L/R 来改变变量的值。 如何使用开发者工具 在游戏测试中按下 F8 键可以打开开发者工具。开发者工具的功能基本上与 Google Chrome 的相似。你可以检查任何使用 HTML5 编写的游戏中的元素。 退出游戏测试 要退出游戏测试，按下窗口上的 X 按钮以关闭窗口。 Resource Manager（资源管理器） （2016 年 3 月 1 日更新）选择[Tools（工具）] → [Resource Manager（资源管理器）]即可打开资源管理器。在[Resource Manager（资源管理器）]中, 你能够管理工程中包含的资源。窗口中各个按钮的功能将在下面说明。想要在游戏中使用你自己的原创文件（包括图片/音频等），你的素材需要有特定的标准。详情请参考[素材标准]。 文件夹列表 窗口的左侧会显示包含资源文件的文件夹。当导入资源文件时，你需要根据你使用的目的来选择目标文件夹。 文件列表 窗口的右侧会显示所选文件夹中的文件列表。 Preview（预览） 预览[文件列表]中选中的图片文件。如果想要检查声音文件，请使用[Sound Test（声音测试）]工具。 Import（导入） 向工程中导入资源文件。首先你要在[文件夹列表]中选择要导入资源文件的位置，然后再选择文件进行导入。 你可以通过多选来一次性导入多个文件。(2016 年 4 月 21 日更新) Export（导出） 将工程中的资源文件保存到工程之外。导出后，工程中依然含有导出的资源文件。 Delete（删除） 删除[文件列表]中的资源文件。文件一旦删除无法恢复，因此删除前请仔细考虑。 你可以使用 Shift 键选择多个文件来行进批量删除。(2016 年 4 月 21 日更新) DLC (仅限 Steam 版本) (2016 年 4 月 21 日更新) 你能从网络上下载资源来用于你自己的游戏中。 Options (April 21th, 2016 Update)You can open the [Options] window by going to [Tools] → [Options]. Here, you can change the Transparent Color settings as well as the Map Grid settings. Transparent Color Sets the color to use as the transparency background in the editor. Map Grid By checking off the [Show] box, the Map Editor grid will be activated. UI ThemeChanges the appearance of the editor.Object Selector (August 4th, 2016 Update)Choose an object selector for selecting in-game objects in the editor like Items, Weapons, Armors, and so on. ［Dropdown］・・・Optimized for less than 100 objects. ［Extended］・・・Optimized for hundreds of objects. ［Smart］・・・Chooses one based on the amount of objects automatically. Tutorials (Beta) (March 21st, 2017 Update)You can see a list of available tutorials by opening [Tools]→[Tutorials (Beta)]→[Select Tutorial (Beta)]. Choose the topic that you would like to learn more about, then start the tutorial (beta). Follow the on-screen instructions to proceed through the tutorial (beta). RPG Maker MV Tools (March 21st, 2017 Update)You can manage tools via [Tools]→[RPG Maker MV Tools].*Requires RPG Maker MV Tools (sold separately.) Additional Tools View a list of tools that have been added.DeleteYou can delete tools by selecting them from the list.Additional tools can be used via the [Tools] option in the menu. Found Tools Searches for and displays tools found in RPG Maker MV Tools.AddAdds the selected tool to the list of Additional Tools.Select PathIf a tool does not automatically appear in the list of Additional Tools, it is possible to manually add it by clicking [Select Path] and navigating to the folder where the tool was installed. 玩你的游戏 RPG Maker MV &gt; 玩你的游戏 基本控制运行你的游戏如何运行本软件所开发的游戏取决于取决于游戏的发布方式。 使用 Windows 在游戏文件夹中双击文件名为Game.exe的可执行程序。 使用 Mac OS X 在游戏文件夹中双击文件名为Game.app的可执行程序。 在 Android/iOS 系统上 参考 转换为 Android 程序和转换为 iOS 程序. * 当游戏为网页游戏时，参考[建立本地服务器]以在本地环境中查看你的游戏。 控制作为标准，本软件制作的游戏控制将使用 4 按钮的游戏手柄。这些按钮的名字以 Xbox 360 手柄为基准。如下是标准游戏所支持的手柄按钮/键盘按键。游戏手柄上的十字键和键盘上的方向键被用来控制角色和光标的移动。 控制 游戏手柄 *1 键盘 鼠标 触屏 移动 十字键 方向键， 数字小键盘 直接点击目的地 *2 轻触目的地 *2 动作 A Z, Enter, 空格 点击目标 轻触目标 取消 B X, Esc, 数字小键盘 0 右键 双指轻触 菜单 Y X, Esc, 数字小键盘 0 右键 双指轻触 快跑 X Shift 上一页 LB Q, Page up 下一页 RB W, Page down 页面滚动 十字键 方向键，数字小键盘 从页面内部向外部拖动/鼠标滚轮 从页面内部向外部滑动屏幕 *1 当在 Windows 系统上使用手柄控制游戏时，手柄必须要支持 XInput 标准。建议使用：Xbox 360 Controller for Windows *2 在地图中，你可以通过在屏幕内不断点击/轻触目的地的方式，来达到一直向某个方向行走的目的。 特殊控制 键位 功能 F2 打开/关闭 FPS 和 Drawing Mode[这是什么模式？待讨论]的显示 F3 打开/关闭 拉伸模式 F4 打开/关闭 全屏模式 F5 重新载入 F8 打开开发者工具(仅在游戏测试中有效) F9 打开调试界面(仅在游戏测试中有效) Ctrl + 方向键 角色可以穿过障碍物(仅在游戏测试中有效) 滚轮 滚动页面 游戏内的菜单控制标题菜单标题画面在你运行游戏后出现。选择下面的选项以继续你的游戏。 New Game(新游戏) 从头开始一个新游戏。 Continue(继续) 从旧存档处开始游戏。接下来需要选择存档。 Options(选项) 调整游戏全局设置，例如 BGM 的音量。 游戏时的主菜单[待讨论，原文是Menu During Movement，直译感觉会造成误解]当玩家在地图中移动时，按下菜单键(也就是取消按钮，游戏手柄除外)就会显示这个主菜单。你在菜单中可以使用道具来恢复角色的状态，或者是存储游戏进度，这些命令可以在左侧窗口中找到。各个命令的详细信息如下。 Item(物品) 查看/使用队伍所拥有的物品。要使用一件物品，从列表当中选中它即可(此操作取决于你使用的物品，有些物品选中后还要指定使用的目标才能发挥效果)。 Skill(技能) 查看/使用技能(魔法，等等)。要使用一个技能，从列表当中选中它即可(此操作取决于你使用的技能，有些技能选中后还要指定使用的目标才能发挥效果)。 Equip(装备) 查看/变更装备。当选择一个角色并改变他的装备时，你会同时选中要换下的装备和即将穿到角色身上的装备(或者是选择空白项来卸下装备)。 Status(状态) 查看角色的状态。你需要选择你想查看的角色。 Formation(编队) 更改队伍成员的顺序。 Options(选项) 调整游戏全局设置，例如 BGM 的音量。 Save(存档) 保存当前游戏状态。从 20 个存档位置中选一个你希望将游戏进度存储的位置。 Game End(结束游戏) 退出游戏。从 [To Title(返回标题画面)] 或 [Cancel(取消)] (亦可使用取消键)中选择一项。 战斗菜单当玩家遇敌时，游戏会切换到战斗画面中。你可以利用下面的命令进行战斗。当所有队员的 HP 降至 0 时，游戏结束。 队伍指令 每一回合都会显示的指令。选择[Fight(战斗)]以继续战斗，或者是[Escape(逃跑)]来从敌群中撤退出来。但是，如果敌人来攻击你，即便是你选择了[Escape(逃跑)]，在本回合也只有敌人才能行动。 角色指令 当你选择了[Fight(战斗)]指令时，你需要为队伍中每位成员下达指令。主要的行动为Attack(攻击)，Guard(防御)和Item(物品)。可选的行动种类取决于角色的设定。 商店菜单在商店你可以购买或出售物品，武器，防具等。 购买 当你选择[Buy(购买)]时，屏幕中会出现可购买的物品，武器，防具等。选择物品及其数量然后按下 OK 按钮确认购买。 所持数/可装备此装备的角色队伍所持该物品的数量会显示在右侧窗口中。 当购买武器和防具时，队员会显示在右边，无法装备此装备的成员会显示为灰色。当你的队员数在 5 或以上时，你可以利用冲刺键或点击(轻触)右侧窗口来显示第五名队员后面的成员。 出售 当你选择[Sell(出售)]并选择[Item(物品)]，[Weapon(武器)]，[Armor(防具)]，[Key Item(重要物品)]，你当前拥有的物品会显示在屏幕中。选择你想出售的物品并输入数量，按下 OK 按钮确认出售。 输入数量 十字键/方向键功能右+1 物品数量左-1 物品数量上+10 物品数量下-10 物品数量* 当使用触屏设备控制时，你可以通过轻触下面的按钮来改变数量。按钮功能+1 物品数量-1 物品数量+10 物品数量-10 物品数量OK 开发者工具在游戏测试时，按下 F8 可以打开开发者工具。 详情请参考[如何使用开发者工具]的内容。 地图 RPG Maker MV &gt; 地图 什么是地图？地图是用来表示你游戏的背景和环境的数据。当玩游戏时，地图会随着玩家所到区域而显示出来。 设计地图，就是将一些部分拼接起来，这些部分叫做“图块”。 地图基本说明图块的作用图块是决定地图外观的图像，并且你可以设置哪些图块玩家可以穿过，哪些不可以。 在一张地图当中，许多块图块被组织到一起包装成一整块数据，形成所谓的“图块组”。它是设计地图轮廓的基础。通过改变你所使用的图块组，你可以即时更改地图的外观。要编辑图块组的数据内容，你可以使用[数据库]。 图块分类在一个图块组中，总共可以包含 5 种不同类型的图块，它们的编号为 A ~ E。A 是最低的一层，它代表地形和地面；B ~ E 则是较高层次的图块，它们用于表示地表上的元素，例如树木，灌木丛，或者标志牌。 你可以将上层图块和下层图块放在地图的同一个位置上。使用这样的两层设计，你可以创造极其精致复杂的地图。 作为标准，表示海洋，草地，地板，墙体的图块是底层图块，而上层图块被用来装饰底层图块的内容。此外，你还可以将两种上层的图块重叠在一起。因此在这个版本的 RPG Maker 中，地图会变得更加多样。 地图尺寸和显示方法地图的尺寸以图块为单位，宽度和高度可分别设置为 0 ~ 256 个图块。 当游戏运行时，屏幕中可看到的图块数量为 17×13 。在大于此尺寸的地图中，显示区域会自动以主角为中心(卷动处理)。此外，通过连接地图的边缘，你可以做出循环地图的效果，就好像玩家身处一个星球上一样(循环处理)。 地图定位地图上图块的位置代表着[地图坐标]。地图的原点位于左上角，坐标为(0,0)，X 坐标轴向右延伸，Y 坐标轴向下延伸。例如，在一个尺寸为 100×100 的地图中，右下角的坐标为(99,99)。当前编辑的图块坐标会显示在底部的状态栏上。 地图坐标可被用于一些事件指令当中，这些事件指令监测当前队伍的所在位置或者是以变量指定的移动地点。 编辑地图 RPG Maker MV &gt; 地图 &gt; 编辑地图 基本编辑方法切换到编辑模式要编辑地图布局，点击工具栏上的[Map(地图)]按钮(或者在主菜单中选择[Mode(模式)] → [Map(地图)])来切换到地图编辑模式。 选择地图数据从地图列表中选择地图数据，地图列表可以在窗口左下角的窗口里找到。地图的布局会在右边地图窗口中显示出来。 选择图块从图块调色板上选择你想绘制的图块。当前选中的图块会被白色方框标注。当你点击图块调色板下方的 A ~ E 标签时，所显示的图块内容会随着你选择的标签而切换。 你可以同时选择多个图块，操作的方法为在图块调色板上进行拖动选择。 选择绘制工具来绘制地图要在地图上绘制图块，你可以在工具栏中选择适当的绘制工具(总共是下面的 5 种工具)。此外，当你在窗口右侧的显示区域(地图预览)中点击或拖动鼠标时，图块就被绘制出来了。你也可以在[Draw(绘制)]菜单中找到这些工具。 你可以利用透明图块来擦除已有的图块。透明图块的位置为 B 标签图块的左上角。 Pencil(铅笔) 在点击的位置上绘制所选图块。 Rectangle(矩形) 当你沿着对角线方向拖动鼠标时，鼠标的始末位置(两个点)会形成一个矩形。所选图块会被绘制在这个矩形区域当中。 Ellipse(椭圆) 当你沿着对角线方向拖动鼠标时，鼠标的始末位置(两个点)会决定一个椭圆。所选图块会被绘制在这个椭圆区域当中。 Flood Fill(颜料桶) 图块会填满点击区域中所有相同的其他图块。 Shadow Pen(阴影笔) 添加或删除所点击区域的阴影，例如墙体的阴影。 其他编辑功能 自动元件 图块调色板的 A 标签上有一种特殊功能的图块，这种图块称为[Autotile(自动原件)]。使用自动图块，可以让一种图块中包含多个图案。根据自动图块的放置位置，它们所在区域的边界会自动调节。在数据库的[图块组]，自动图块被安放在[A1] ~ [A4]的位置上。 此外，当使用吸管工具复制图块或者在绘制图块时按住[Shift]键时，自动图块功能将暂时失效。 自动阴影 使用自动图块时，如果将两个或更多的图块竖直放置，那么图块的右下角会自动补上阴影。然而，一些特定的图块不会自动绘制阴影。 阴影笔 阴影笔用于为建筑或墙体绘制阴影。你可以将图块 1/4 处的色调变暗。 点击工具栏上的[Shadow Pen(阴影笔)]按钮(或者点击菜单上的[Draw(绘制)] → [Shadow Pen(阴影笔)])，然后在地图窗口点击。如果一个位置上没有阴影，点击此位置后将绘制阴影；如果一个位置上有阴影，点击此位置后将清除阴影。 上层图块的特殊说明 你最多可以将两种不同的上层(B-E)图块放置在同一位置。 * 当放置第三个图块时，最先放置的上层图块就消失了。 * 当第三个图块和第二个图块相同时，最先放置的图块不会消失。 * 只有 B 标签中左上角的图块可以擦除其他上层图块。当可通行图块和不可通行图块放置在同一位置时，考虑通行度时将优先考虑最后放置的图块。 * 即便是标有 ☆ 的可通行图块在底部，它依然会被显示在最上面。 * 当放置一个标有 ☆ 的可通行图块时，考虑通行度时将优先考虑不可通行的图块。 底层图块的特殊说明 在图块调色板的 [A] 标签页中，[A2] 位置的图块的优先度分成[Base(基础)](左起 1 ~ 4，也就是左半边的图块)和[Decoration(装饰)]图块，(左起 5 ~ 8 ，也就是右半边的图块)。装饰图块可以被放在基础图块上。 然后，对于那些优先度[Mode(模式)]为[World Type(世界类型)]的[Tilesets(图块组)]来说，当将装饰图块放在第二列或者第四列的基础图块上时，基础图块自动会变成第一列或第三列的样子。 地图属性 RPG Maker MV &gt; 地图 &gt; 地图属性 地图详细信息当你新建一个地图，或者右键点击一个已有地图然后选择“编辑”时，地图属性窗口就会打开。在本窗口中，你可以编辑地图大小，所用的工具，背景音乐，遇敌条件(触发战斗的条件)和游戏的行为。 属性详细信息 常规设置Name(名字)地图的名字。这个属性只在编辑器中使用(不会影响游戏)。 Display Name(显示名称)在角色进入地图时显示在屏幕上的地图名。 Tileset(图块组)指定地图布局所使用的图块组。 Width/Height(宽度/高度)地图的尺寸。[Width(宽度)] 和 [Height(高度)] 的设置范围为 0 ~ 256。当缩小地图尺寸时，地图以外的部分将被删除。 Scroll Type(滚动模式)决定地图如何循环滚动。当设置为循环模式时，角色可以从地图的一边循环走到另一边。 No Loop(不循环) 地图不是循环的。 Loop Vertically(垂直循环) 地图的上下边界会连接起来。 Loop Horizontally(水平循环) 地图的上下边界会连接起来。 Loop Both(水平/垂直循环) 上下边界，左右边界都会连接起来。 Encounter Steps(遇敌步数)决定主角随机遇敌的频率。设定值为主角平均走多少步就会遇敌敌人(范围为 1 ~ 999，一步的含义就是移动一个图块的距离)。如果你想要怪物频繁出现，请把此数值下调。 Autoplay BGM/ Autoplay BGS(自动播放 BGM/BGS)启用时，主角进入该地图后，BGM(背景音乐)和 BGS(背景声音)将会自动播放。请分别选择你想要播放的声音文件。如图地图的 BGM 和战斗 BGM 相同，切换场景时，音乐不会停止。 Specify Battleback(指定战斗背景)启用时，你可以使用两种图像的组合来指定此地图战斗的背景。未指定时，战斗背景会自动和地形一致。对其他地图来讲，战斗背景图也可能是处理过的地图画面。 Disable Dashing(禁止加速)启用时，玩家不能在这个地图上加速跑。 Parallax Background(远景图)出现在地图透明处的图像。点击[…]按钮后，在弹出的窗口中选择你想使用的文件。 当你启用[Loop Vertically(垂直循环)] 或 [Loop Horizontally(水平循环)]时，背景也会随着主角移动方向而卷动。并且，如果你设置的滚动值不是 0 (范围为 -32 ~ 32)，它也会自动滚动。如果滚动值时正数，它会向左或向上滚动，如果滚动值时负数，它会向右或向下滚动。数值的绝对值越大，滚动速度越快。 如果你启用[Show in the Editor(在编辑器中显示)]，那么你就会在编辑器中看到远景图预览。然而，显示的内容并不总是和实际游戏中的相同。 此外，如果你在远景图文件名的前面加上”!”，该图的视差会变为 0。 Note(备注)在制作游戏时，你可以随便在这里添加备注。这个属性仅仅在编辑器中有效(不会影响游戏)。 Encounters(遇敌)这个列表显示了所有角色在地图上移动时随机遇到的敌群。双击空行会打开一个窗口，你可以设定以下内容。当右键点击一个已有的敌群时，你可以在右键菜单中做复制或删除等操作。 Troops(敌群) 定义你想要设置的敌群。 Weight(权重) 设置遇敌时此敌群出现的优先顺序(0 ~ 100)。权重越高，当定义多个敌群时，遇到这一组敌群的可能就越大。 敌群的遇敌概率计算取决于此敌群权重的所占比例。例如，敌群 A 的权重为 9，敌群 B 的权重为 7 ，敌群 C 的权重为 4。这种情况下，遇到敌群 A 的概率为 9/20(总权重为 9+7+4)，也就是 0.45。换句话说，它会有 45% 的几率出现。相似地，敌群 B 出现几率为 7/20(35%)，敌群 C 的为 20%。 Range(范围) 敌群出现的区域。如果遇敌范围和区域无关，请选择”Entire Map(整个地图)”。如果要指定仅在特定区域遇敌，请选择”Specify by Region ID(由区域 ID 指定)”，并指定区域的 ID(最多指定 3 个区域)。设置区域的方法如下。 设置区域 在地图的遇敌设置中指定的[Region(区域)]表明在此区域你将遇到何种敌人。一张地图可以分成至多 255 个区域。 要设置区域，首先在图块调色板上选择 R 标签，切换到编辑模式。之后，在窗口的左上方选择区域的 ID(1 ~ 255)，然后在地图上点击就可以设置相应图块的区域。一个图块只能设置一个区域 ID。 数据库 RPG Maker MV &gt; 数据库 什么是数据库？数据库将所有游戏成分（地图和地图事件除外）组织到了一起，例如玩家控制的角色，物品，魔法，属性。这些成分可大致分为下面 15 种数据。 除了[System(系统)]、[Types(属性)]与[Terms(用语)]之外，所有数据均以游戏中登场的单位分别设置。例：“恢复药水”和“钥匙”这类物品，每个物品都在[Items(物品)]中制作数据，设置各自的名称、图像、使用时的效果之类的特征。 Actors(角色) 玩家可控制的角色。 Class(职业) 每个角色的特点(特性，成长条件等)。 Skills(技能) 行动与特殊技能(普通攻击，特技，魔法)。 Item(物品) 玩家拥有的物品(药水，钥匙等)。 Weapons(武器) 角色用于进攻的装备(剑，杖，弓等)。 Armors(防具) 角色用于防御的装备(护甲，盾牌，装饰品等)。 Enemies(敌人) 会和主角发生战斗的角色。 Troops(敌群) 出现在游戏中的敌人队伍。 States(状态) 角色，敌人的状态(中毒，战斗不能等)。 Animations(动画) 一些视觉效果(例如发动技能时)。 Tileset(图块组) 创建地图时，用于管理图块的数据。 Common Events(公共事件) 处理公共使用的事件。 System(系统) 游戏的全局基础设定，例如初始设定和音乐。 Types(属性) 设定元素，技能，武器，防具，装备的属性。 Terms(用语) 一些游戏指令和参数的文字内容。 编辑数据库显示编辑窗口数据库的内容要在[Database(数据库)]窗口编辑。要显示数据库窗口，点击工具栏上的[Database(数据库)]按钮(或选择菜单栏中的[Tools(工具)] → [Database(数据库)])。 组织编辑窗口你可以根据数据的类型在[Database(数据库)]窗口的侧边菜单中选择数据。要创建和编辑数据，请点击侧边菜单上的按钮切换屏幕显示的内容。 当编辑除[System(系统)]，[Types(属性)]，[Terms(用语)]以外的数据时，首先在屏幕左侧的数据列表中选择你要编辑的数据。在这之后，编辑窗口右侧的参数以进一步确定数据的特性。 当按下键盘上的[F4] 或 [F5]键时，你可以在当前的数据列表中切换上一个数据和下一个数据。 更改数据条目的数量技能，物品，武器，敌人，敌群的最大值被设定为 2000，其余类型的数据则是 1000。要改变数据条目的总数，点击数据列表下的[Change Maximum(更改最大值)]按钮，然后输入新的数据条目数量。当减少数据条目的最大值时，超过这个最大值的数据将被删除。 通过右键菜单控制当你右键点击数据列表中的一项时，会出现一个菜单。你可以进行例如复制数据这样的操作。如下是每一项命令的详细信息。 Copy(复制) 将选中数据的详细参数信息复制到剪贴板上。 当你按住[Shift]键进行选择时，可以复制多份数据。 Paste(粘贴) 将剪贴板上的详细参数信息应用(覆盖)到所选数据上。所选数据之前的参数信息将会被丢失。 Clear(清除) 删除本数据所有详细参数信息。 有关数据 ID在每项数据记录前面显示的数字被称作它的数据 ID(这个数字是独一无二的)。当在事件指令中利用变量指定数据时，ID 就会派上用场。 利用备注区域在某些数据中(actors(角色)/classes(职业)/skills(技能)/items(物品)/weapons(武器)/armors(防具)/enemies(敌人)/states(状态)/tilesets(图块组))，有一处[Note(备注)]区域。在制作游戏时你可以随便在这里写下备注。和前面一样，这不会影响游戏，在一些插件中，你可以利用备注来定义额外的信息。 角色设置 RPG Maker MV &gt; 数据库 &gt; 角色设置 数据的作用表示玩家可控角色的数据。你可以给每一位角色赋予独特的特征。 属性详细信息 Name(名字) [Name(名字)]是在游戏过程中所显示的角色姓名。有些情况下，如果名字过长，角色的名字在游戏或战斗中可能会显示不全。 Nickname(昵称) 角色的昵称。它会在右上方的状态窗口中显示。 Class(职业) 角色所属的职业。这会影响到角色所使用的技能，所能装备的武器，所能使用的物品等等。你要在[Class(职业)] 标签里编辑更加详细的信息。 Initial Level/ Max Level(初始等级/最大等级) [Initial Level(初始等级)]是角色在游戏开始时的等级，[Max Level(最大等级)]是该角色所能达到的最高等级。角色的等级不能超过[Max Level(最大等级)]。每一项的数值都可以设定为 1 ~ 99。 Profile(个人资料) 角色的介绍。这会在状态画面的下半部分里显示。 Images(图像) Face(头像)显示在菜单里的图像。Character(行走图)显示在地图画面上的图像。[SV] BattlerI([横版]战斗图)在横版战斗中显示的角色战斗图。 Initial Equipment(初期装备) 游戏开始时角色身穿的装备。在每个部位的下拉列表中选择你想要设定的装备。注意，只能从角色所属职业所能装备的物品中选择。如果设置为[None(无)]，那么游戏初期角色的该位置将不会有装备。 Traits(特性) 角色的独特属性。双击设置区域的每一行都可以定义一项特性的详细信息。详情请参考[如何设置特性]。 备注 在制作游戏过程中，[Note（备注）]部分可以用来做备注。 右键点击可以打开菜单，在其中选择[Plugin Help…（插件帮助）]来显示插件帮助。 （2016.03.01 更新） 职业设置 RPG Maker MV &gt; 数据库 &gt; 职业设置 数据的作用职业数据是有关角色能力特性的集合。你必须为每一个角色指定一个职业，然后通过改变各项参数来调节角色升级的方式，能力值的增长方式，升级所学会的技能等。你还可以为角色赋予职业特性。 参数 设置参数曲线在[Parameter Curves（参数曲线）]窗口当中，每个等级的参数值可以基于以下的方法进行设定。要切换要编辑的参数，直接点击带有该参数名称的标签即可。当你完成编辑后，点击[OK]，你设置的数值就会被保存（当按下[Cancel（取消）]键时会放弃本次更改）。 Quick Settings（快速设置） 此功能会将各个等级的参数值设置为软件事先指定的数值。总共有 5 个级别，分别为 [A] ~ [E]，点击对应的按钮之后该级别的数据就会被自动设置。 Level/Value（等级/数值） 直接为每个等级编辑参数。操作方法为先在[Level（等级）]输入框指定你要设置的等级（1 ~ 99），然后在[Value（数值）]输入框指定当前等级对应的参数（最大 HP 和 最大 MP 的范围为 1 ~ 9999，其他参数为 1 ~ 999）。 Generate Curve（生成曲线） 可以由 1 级和 99 级的数据自动计算所有等级所对应的参数值。 点击[Generate Curve（生成曲线）]后，首先在显示的窗口中定义[1 级]和[99 级]的数值（最大 HP 和 最大 MP 的范围为 1 ~ 9999，其他参数为 1 ~ 999）。 然后，利用滑块决定增长类型。当滑块偏左（早熟）时，增长的速率（参数增长的数量）会随着级别的升高而减慢，当滑块偏右（晚熟）时，增长的速率会随着级别的升高而加快。点击[OK]后，参数会按照你指定的内容进行设置。 Graph（图表） 每个等级的参数值会显示在一个条形图中。直接在图表的显示区域上点击或拖动鼠标，你就可以设置对应等级的参数值。技能设置 RPG Maker MV &gt; 数据库 &gt; 技能设置 数据的作用定义角色在战斗中采取的行为，例如战斗，防御，魔法攻击和特殊攻击等。通过设置使用条件，成功率，给予目标的伤害等参数，你可以创建各种各样的技能。 参数详细信息 常规设置Name(名称)技能的名称。如果技能名称太长，那么在游戏画面中可能会显示不全。 Icon(图标)游戏中和技能名称一同显示的图像。双击技能图标后，你可以在打开的[Select an Image(选择图像)]窗口中任意选择图标。通常会选择和技能特点相关的图片作为技能图标。 Description(说明)在游戏中，光标选中该技能时所显示的技能说明。 Skill Type(技能种类)指定技能种类。默认情况下会设置为[Magic(魔法)] 和 [TP Skills(TP 技能)]，但是你可以在[用语]设置中改变此项设定。对于那些非[None(无)]的设定，每项[Additional Skill Type(附加技能种类)]的效果只能被已经拥有此技能的角色和职业所使用。 MP Cost/TP Cost(MP 消耗/TP 消耗)技能使用后消耗的 MP (0 ~ 999) 和 TP (0 ~ 100)。如果角色的 MP 或 TP 不足，这个技能将无法使用。 Scope(使用范围)技能效果的范围。你必须在如下的选项中选择一个。 None(无) 不需要指定使用范围的技能。 1 Enemy(敌单体) 敌人队伍中的一个敌人 All enemies(敌全体) 整个敌人队伍 X Random Enemy(X 个随机敌人) 随机选择指定数量的敌人(X 为目标数量) 1 Ally(己方单体) 队伍中的一名同伴 All Allies(己方全体) 队伍中的所有同伴 1 Ally (Dead)(己方阵亡单体) 队伍中的一名已经阵亡的同伴 All Allies (Dead)(己方阵亡全体) 队伍中所有已经阵亡的同伴 The User(使用者) 使用此技能的人 Occasion(使用场合)选择技能可以被使用的场合。从如下的选项中选择一个：[Always(平时)] (可以在战斗中和菜单中使用)，[Battle Screen(战斗中)] (只能在战斗中使用)，[Menu Screen(菜单中)] (只能在菜单画面使用) 和 [Never(不能使用)]。 Invocation(使用)Speed(速度)当使用此技能时为角色(暂时)增加的速度(范围为 -2000 ~ 2000)。这会影响到战斗中的行动顺序，利用此设定可以制作威力较小但可以快速使用的技能或者是威力较大但是需要花费一定时间才能使用的技能。 Success(成功率)使用该技能的成功率(0 ~ 100%)。实际成功率还会受到对方有效度的影响。 Repeat(重复次数)技能使用一次后效果被应用的次数(1 ~ 9 次)。 TP Gain(TP 获得数)成功对目标使用技能后，TP 的增加值。 Hit Type(击中类型)决定技能的击中类型。你必须从如下的选项中选择一个。 Certain Hit(必定击中) 技能成功发动就将其视为命中。反击，魔法反射和保护弱者都对该技能无效。 Physical Attack(物理攻击) 成功率由使用者的命中率和目标的回避率决定。反击和保护弱者会对该技能生效。 Magic Attack(魔法攻击) 成功率由目标的魔法回避率决定。魔法反射和保护弱者会对该技能生效。 Animations(动画)战斗中出现在目标上方的动画。 Message(消息)为战斗中技能使用设置固定的短语(至多 2 行)。使用时，”%1” 符号会被技能的名称所替代。你可以通过按下[casts *!] 按钮，[does *!] 按钮或[used *!]按钮来设置固定短语。 Required Weapon(所需武器)Weapon Type 1/Weapon Type 2(武器类型 1/2)使用技能时所需装备的武器。如果二者都被设置为[None(无)]，你在发动这个技能时不需要任何武器要求。当选择了两个种类时，任意装备两种武器中的一种就可以使用此技能。 Damage(伤害)在技能对目标造成伤害时，指定效果的数量和此类效果的伤害公式。 Type(种类) 与 HP、MP 有关的种类。从下面 6 种不同的种类的效果中选择一个。[Damage(伤害)]减少 HP/MP，[Recover(恢复)]增加 HP/MP 以及 [Drain(吸收)]转移 HP/MP (将一小部分 HP/MP 从目标转移到使用者身上)。 Element(属性) 效果的属性。 Formula(伤害公式) 决定技能效果的公式。 输入伤害公式时，可以直接使用下面的字符串来引用各项参数。当表示使用者时，将 “x” 改为 “a”，当表示目标时，将 “x” 改为 “b”。输入 “a.atk” 表示使用者的攻击力。此外，你可以使用 “v[n]” 来引用编号为 n 的变量。属性公式时，你可以使用基本的四则运算符号(+, -, *, /)。 当你输入 “a.atk * 4 - b.def * 2” 时，技能的效果值会被计算为”(攻击者的攻击力×4) - (目标的防御×2)”。 另一方面，由于技能的效果依赖于属性和防御，这些因素可不必出现在公式中。x.atkAttack Power(攻击力)x.defDefense(防御)x.matMagic Attack(魔法攻击力)x.mdfMagic Defense(魔法防御)x.agiAgility(速度)x.lukLuck(幸运)x.mhpMax HP(最大 HP)x.mmpMax MP(最大 MP)x.hpCurrent HP(当前 HP)x.mpCurrent MP(当前 MP)x.tpCurrent TP(当前 TP)x.levelLevel(等级) Variance(分散度) 技能效果的波动范围(0 ~ 100%)。在指定的百分比范围内提高或者降低技能的效果值。例如效果值为 100 分散度为 20，则实际的效果值会在 80 到 120 之间(100±20)。 Critical Hits(会心一击) 选择[Yes(是)]和[No(否)]来指定该技能是否能造成会心一击。当选择[Yes(是)]时，产生会心一击的几率会由使用者的会心一击触发率和目标的会心一击回避率共同决定。 Effects(效果)除伤害之外的其他效果的信息。你可以双击列表，然后在出现的[Effects(效果)]窗口中设置它们。详情请参考后面的[如何设置效果]部分。 Note(备注)在制作游戏过程中，[Note（备注）]部分可以用来做备注。右键点击可以打开菜单，在其中选择[Plugin Help…（插件帮助）]来显示插件帮助。（2016.03.01 更新） 物品设置 RPG Maker MV &gt; 数据库 &gt; 物品设置 数据的作用物品数据表示装备之外的道具。当角色使用物品时，你可以为其添加使用效果。此外，你可以创建推进剧情发展的关键物品(事件内容s)例如开门的钥匙。 参数详细信息 常规设置Name(名称)物品的名称。如果物品名称太长，那么在游戏画面中可能会显示不全。 Icon(图标)游戏中和物品名称一同显示的图像。双击物品图标后，你可以在打开的[Select an Image(选择图像)]窗口中任意选择图标。 Description(说明)在游戏中，光标选中该物品时所显示的物品说明。 Item Type(物品种类)物品的种类。 [Key Item(关键物品)] 区别于常规物品，在道具菜单中，关键物品会在另一个窗口中显示。 [Hidden Item A(隐藏物品 A)] 和 [Hidden Item B(隐藏物品 B)] 这些物品不会在物品画面中显示。只有在事件里选择物品的时候，这些特殊的物品才会显示。 Price(价格)该物品从商店买入时的价格。商品的卖出价为原始价格的一半。当价格设置为 0 时，此项物品无法卖出。 Consumable(消耗)这个参数决定了物品使用后是否消失。如果你设置为[Yes(是)]，每次使用时，物品的数量都会减少。 Scope(使用范围)物品效果的范围。你必须在如下的选项中选择一个。 None(无) 不需要指定使用范围的物品。 1 Enemy(敌单体) 敌人队伍中的一个敌人 All enemies(敌全体) 整个敌人队伍 X Random Enemy(X 个随机敌人) 随机选择指定数量的敌人(X 为目标数量) 1 Ally(己方单体) 队伍中的一名同伴 All Allies(己方全体) 队伍中的所有同伴 1 Ally (Dead)(己方阵亡单体) 队伍中的一名已经阵亡的同伴 All Allies (Dead)(己方阵亡全体) 队伍中所有已经阵亡的同伴 The User(使用者) 使用此技能的人 Occasion(使用场合)选择物品可以被使用的场合。从如下的选项中选择一个：[Always(平时)] (可以在战斗中和菜单中使用)，[Battle Screen(战斗中)] (只能在战斗中使用)，[Menu Screen(菜单中)] (只能在菜单画面使用) 和 [Never(不能使用)]。 Invocation(使用)Speed(速度)当使用此物品时为角色(暂时)增加的速度(范围为 -2000 ~ 2000)。这会影响到战斗中的行动顺序，利用此设定可以制作威力较小但可以快速使用的物品或者是威力较大但是需要花费一定时间才能使用的物品。 Success(成功率)使用该物品的成功率(0 ~ 100%)。实际成功率还会受到对方有效度的影响。 Repeat(重复次数)物品使用一次后效果被应用的次数(1 ~ 9 次)。 TP Gain(TP 获得数)成功对目标使用物品后，TP 的增加值。 Hit Type(击中类型)决定物品的击中类型。你必须从如下的选项中选择一个。 Certain Hit(必定击中) 物品成功使用就将其视为命中。反击，魔法反射和保护弱者都对该物品无效。 Physical Attack(物理攻击) 成功率由使用者的命中率和目标的回避率决定。反击和保护弱者会对该物品生效。 Magic Attack(魔法攻击) 成功率由目标的魔法回避率决定。魔法反射和保护弱者会对该物品生效。 Animations(动画)战斗中出现在目标上方的动画。 Damage(伤害)在物品对目标造成伤害时，指定效果的数量和此类效果的伤害公式。 Type(种类) 与 HP、MP 有关的种类。从下面 6 种不同的种类的效果中选择一个。[Damage(伤害)]减少 HP/MP，[Recover(恢复)]增加 HP/MP 以及 [Drain(吸收)]转移 HP/MP (将一小部分 HP/MP 从目标转移到使用者身上)。 Element(属性) 效果的属性。 Formula(伤害公式) 决定物品效果的公式。 输入伤害公式时，可以直接使用下面的字符串来引用各项参数。当表示使用者时，将 “x” 改为 “a”，当表示目标时，将 “x” 改为 “b”。输入 “a.atk” 表示使用者的攻击力。此外，你可以使用 “v[n]” 来引用编号为 n 的变量。属性公式时，你可以使用基本的四则运算符号(+, -, *, /)。 当你输入 “a.atk * 4 - b.def * 2” 时，物品的效果值会被计算为”(攻击者的攻击力×4) - (目标的防御×2)”。 另一方面，由于物品的效果依赖于属性和防御，这些因素可不必出现在公式中。x.atkAttack Power(攻击力)x.defDefense(防御)x.matMagic Attack(魔法攻击力)x.mdfMagic Defense(魔法防御)x.agiAgility(速度)x.lukLuck(幸运)x.mhpMax HP(最大 HP)x.mmpMax MP(最大 MP)x.hpCurrent HP(当前 HP)x.mpCurrent MP(当前 MP)x.tpCurrent TP(当前 TP)x.levelLevel(等级) Variance(分散度) 物品效果的波动范围(0 ~ 100%)。在指定的百分比范围内提高或者降低物品的效果值。例如效果值为 100 分散度为 20，则实际的效果值会在 80 到 120 之间(100±20)。 Critical Hits(会心一击) 选择[Yes(是)]和[No(否)]来指定该物品使用后是否能造成会心一击。当选择[Yes(是)]时，产生会心一击的几率会由使用者的会心一击触发率和目标的会心一击回避率共同决定。 Effects(效果)除伤害之外的其他效果的信息。你可以双击列表，然后在出现的[Effects(效果)]窗口中设置它们。详情请参考后面的[如何设置效果]部分。 Note(备注)在制作游戏过程中，[Note（备注）]部分可以用来做备注。右键点击可以打开菜单，在其中选择[Plugin Help…（插件帮助）]来显示插件帮助。（2016.03.01 更新） 武器/防具设置 RPG Maker MV &gt; 数据库 &gt; 武器/防具设置 数据的作用武器和防具指的是角色的装备。当角色装备此道具时，角色的能力值可能会升高或降低，或者是额外获得一些特性。 参数详细信息 常规设置Name(名称)武器/防具的名称。如果名称太长，那么在游戏画面中可能会显示不全。 Icon(图标)游戏中和武器/防具名称一同显示的图像。双击物品图标后，你可以在打开的[Select an Image(选择图像)]窗口中任意选择图标。 Description(说明)在游戏中，光标选中该武器/防具时所显示的物品说明。 Weapon Type/Armor Type(武器种类/防具种类)武器和防具的分类。这是利用角色或职业特性判断角色是否可以装备此道具的标准。选择的武器/防具分类可以在[用于]设置中修改。 Price(价格)从商店买入时的价格。商品的卖出价为原始价格的一半。当价格设置为 0 时，此项装备无法卖出。 Animations (Weapons only)(动画，仅武器)设置使用此武器进行攻击的动画。 Equipment Type (Armor only)(装备种类，仅防具)防具装备的部位(Shield/Head/Body/Accessory[盾/头部/身体/装饰品])。你可以为角色的各个部位装备合适的防具。 Parameter Changes(参数变化)装备此道具时，角色能力值的变化。[Max HP(最大 HP)] 和 [Max MP(最大 MP)]可设置为 -5000 ~ 5000，其他各项的范围是 -500 ~ 500。输入负数时，对应的能力值则会减小。 Traits(特性)装备此武器或防具时，角色获得的特性。在参数区域的每一行双击，然后在打开的窗口中定义特性的详细信息。详情请参考[如何设置特性]。 Note(备注)在制作游戏过程中，[Note（备注）]部分可以用来做备注。右键点击可以打开菜单，在其中选择[Plugin Help…（插件帮助）]来显示插件帮助。（2016.03.01 更新 敌人设置 RPG Maker MV &gt; 数据库 &gt; 敌人设置 数据的作用表示和角色发生战斗的敌人的数据。除了那些和主角相同的特性之外，你需要额外设置战斗中敌人采取的行动模式。 参数详细信息 常规设置Name(名称)敌人的名称。如果名称太长，那么在游戏画面中可能会显示不全。 Image(战斗图)游戏中显示的敌人图像。双击图像后，在打开的[Select an Image(选择图片)]的窗口中选择一张图片。选择图像时，你可以通过移动[Hue(色相)]滑块来改变图像的色相。如果设置为[None(无)]，则不会有图片显示。 Max HP/Max MP/Attack/Defense/M.Attack/M.Defense/Agility/Luck(最大 HP/最大 MP/攻击力/防御/魔法攻击力/魔法防御/速度/幸运)战斗开始时敌人的能力值。[Max HP(最大 HP)]的范围为 1 ~ 999999，[Max MP(最大 MP)]的范围为 0 ~ 9999，其他能力值的范围为 1 ~ 999。 Rewards(奖励)战斗获胜后角色获得的 EXP (1 ~ 9999999) 和获得金钱(0 ~ 9999999)数量。 Drop Items(掉落物品)战斗获胜后队伍获得的物品(包括武器和防具)。双击区域后可以打开设置窗口，在里面你可以指定掉落的物品和掉落几率（在[Probability(概率)]中设置，范围为 1/1 ~ 1/1000）。 Action Patterns(行动模式) Turn(回合) 战斗经过的回合可作为行动条件。回合的定义格式为[A + B * X]，其中 A 为距离战斗开始的回合数，B 为相邻两回合之间的回合数。如果将 A 设置为 2，B 设置为 3，则从第二回合开始，每隔 3 回合就满足一次条件(第 5 回合，第 8 回合…)。 HP 敌人当前 HP 可作为行动的条件。设置时请指定当前 HP 所占最大 HP 的百分比(0 ~ 100%)。当敌人的 HP 在指定范围内时，条件视为满足。 MP 敌人当前 MP 可作为行动的条件。设置时请指定当前 MP 所占最大 MP 的百分比(0 ~ 100%)。当敌人的 MP 在指定范围内时，条件视为满足。 State(状态) 战斗者持有指定状态可作为行动的条件。 Party Level(队伍等级) 队伍成员的等级可作为行动的条件。当队伍中等级最高者在指定等级以上（或相等）时，条件视为满足。 Switch(开关) 指定的开关可作为行动的条件。当指定开关打开时，条件视为满足。 Traits(特性)敌人的特性。双击每行的设置区域，然后在打开的窗口里面编辑特性的细节。详情请参考[如何设置特性]。 Note(备注)在制作游戏过程中，[Note（备注）]部分可以用来做备注。右键点击可以打开菜单，在其中选择[Plugin Help…（插件帮助）]来显示插件帮助。（2016.03.01 更新） 行动模式应用规则在[Action Patterns(行动模式)]里面设置的行动当中，战斗中实际采取的行动会服从下面的规则。 只有满足条件的行动会被从行动列表里面选择出来。如果没有行动满足执行条件，那么该敌人不会采取任何行动。 在满足条件的行动当中，具有最高 rating（级别）的行动和与其相差两个级别以内的行动可能会被实际采用。 在所有可能的选择中，和最高级别的行动相差 1 ~ 2 个级别的行动，实际采取的概率分别为最高级别行动的 2/3 和 1/3。对于 rating（级别）相同的行动，它们被选中的几率相同。 例子 1：行动级别为 [5] 和 [5] 每个行动的几率为 50%。 例子 2：行动级别为 [6]，[5]，[4]，[3] [6] 为 50%，[5] 为 33.3% (50% 的 2/3)，[4] 为 16.6% (50% 的 1/3)。[3] 不会成为备选行动。 例子 3：行动级别为 [5]，[3] 和 [3] [5] 为 60%，每个 [3] 为 20% (60% 的 1/3)。 实际采取的行动会按照以上概率在备选行动中随机产生。 敌群设置 RPG Maker MV &gt; 数据库 &gt; 敌群设置 数据的作用敌群是游戏中表示敌人队伍的数据。玩家在地图上遭遇的敌人或事件指令中的战斗就是靠这类数据设置的。即使时角色只和一名敌人发生战斗，你也必须为那一名敌人准备敌群数据。每个敌群也会设有特定的“战斗事件”(战斗中发生的事件)。 参数详细信息 常规设置Name(名称)敌群的名称。这个属性仅在编辑器中使用(不会影响游戏)。点击[Auto-name(自动生成名称)]按钮之后，敌群的名称会依照所选的敌人自动生成。 Change BG(更改背景)更改位置预览窗口的战斗背景。在窗口左侧区域指定战斗背景，在右侧区域指定使用的图像。这些设置仅在编辑器中使用(不会影响游戏)。编辑时，此设定也会被应用到其他的敌群数据上。 Battle Test(战斗测试)启动此敌群的战斗测试。在打开的窗口中，选择参加战斗的角色，使用的装备，角色的等级，不同的角色要在[1] ~ [4] 标签之间切换(能力值会依照装备和等级的设定而自动生成，并显示在[Status(状态)]部分)。点击[OK]时，游戏窗口打开，战斗测试开始。战斗测试结束后，窗口自动关闭。* 当使用插件后，务必保存你的游戏。如果不保存，插件的设置将不能在战斗测试中生效。 Placement View(位置预览)敌群中的敌人。你最多可为一个敌群添加 8 名敌人(包含相同的敌人)。 你可以通过在位置预览窗口拖动敌人的方式来调整敌人的位置。此外，当你在预览窗口中右键点击敌人并选择[Appear Halfway(中途出现)]时，这个敌人会被隐藏，直到战斗事件[Enemy Appearance(敌人出现)]被执行。 使用下面的按钮来编辑敌群的内容。 Add(添加) 将右侧区域中选中的敌人添加的预览窗口。你也可以通过创建列表中的敌人来进行添加。敌人添加的顺序决定了战斗中显示的敌人列表。 Remove(删除) 将预览窗口中选中的敌人删除。 Clear(清空) 删除所有预览窗口中的敌人。 Align(对齐) 依照敌人添加的顺序，将敌人在预览窗口的位置进行自动对齐。 战斗事件参数你可以在[Battle Event（战斗事件）]部分里设置处理敌人的事件的出现条件和内容。就像设置地图事件一样，你也可以使用事件页和事件出现条件来分割所处理的事件内容。 Event Page Controls(事件页控制)你可以使用左边的[New Event Page(新建事件页)]，[Copy Event Page(复制事件页)]，[Paste Event page(粘贴事件页)] 和 [Clear Event Page(清空事件页)]按钮来控制事件页。它们的功能和地图事件的相同。 Conditions(事件出现条件)事件页的出现条件。当按下[…]按钮时，[Conditions(事件出现条件)]窗口会出现。你可以从下面的 5 种条件中启用一些条件，并指定每个条件的判定标准。和地图事件不同，如果不指定战斗事件页的出现条件，该事件页的内容永远不会被执行。此外，如果多个事件页满足执行条件，编号最小的那个事件页会被执行。 Turn End(回合结束) 回合结束的一瞬间会成为事件出现条件。 Turn(回合) 从战斗开始算起，经过指定数量的回合之后会成为事件出现条件。在左侧指定从战斗开始后经过的回合数，在右侧指定两个回合之间的间隔。 Enemy HP(敌人 HP) 当敌人的 HP 降低到指定值以下时，该条件就会被触发。你需要指定作为条件的敌人和 HP 数量(当前 HP 所占最大 HP 的百分比)。 Actor HP(主角 HP) 当主角的 HP 降低到指定值以下时，该条件就会被触发。你需要指定作为条件的角色和 HP 数量(当前 HP 所占最大 HP 的百分比)。 Switch(开关) 当开关打开时，该条件被视为满足。 Span(范围)指定事件页允许执行的时机。 Battle(战斗) 战斗开始后，条件第一次满足时事件会执行。这就意味着它运行一次之后，将不会运行下一次。 Turn(回合) 每个回合都会检查事件条件，如果条件满足则事件会执行。 Moment(暂时) 事件会在条件满足期间反复执行。如果事件页由开关控制，那么有可能战斗不会继续下去（事件会一直反复执行，阻塞战斗进程）。所以请格外注意这个问题。 Run Contents(事件内容)在此处设置事件指令，这些指令会在[Conditions(条件)] 和 [Span(范围)] 被满足时执行。编辑方式和地图事件的 [事件内容]相同。 事件 RPG Maker MV &gt; 事件 什么是事件？在PRG游戏里，游戏进程中贯穿着很多要素，比如文字会话，从宝箱中获取到物品，和boss战斗等等。用RPG maker你将用名为“事件”的概念来组织这些数据。 事件是用来执行某些种类游戏进程的机制。例如，当玩家尝试和NPC谈话的时候，你可以使用事件相应来指派显示在屏幕上的图片和句子。 依赖于玩家的行动和游戏状态，不同的事件触发将会导致游戏中不同的结果产生。 事件类型事件有如下的三种类型。那些关系到故事和游戏推进的部分都由“地图事件”产生。 地图事件（Map Events） 地图事件是运行在地图场景上的事件。使用这个类型的事件可以设置角色会话，可以获得物品的宝箱。另外，你也可以声明游戏结构和推进相关的事件，这些事件不需要在显示图片，比如改变玩家位置，切换场景。 你可以通过点击主窗口的“事件（Events）”按钮进入事件编辑模式，点击[模式(Mode)]-&gt;[事件(Events)]也可以达到同样的效果，这样你就可以创建和编辑地图事件了。 战斗事件（Battle Events） 这类事件出现在战斗场景当中。例如，“当敌人HP低于某个设定值的时候就变形”就会使用战斗事件。 这些事件的创建和编辑在数据库的[（敌群）Troops]页面当中。 通用事件（Common events） 这些事件可以在任何时候使用。使用这些事件来调用地图事件和战斗事件，或者设定在使用特殊物品的时候产生这些事件。可以在 上数据库中的[（通用事件）Common Events]分页创建和编辑这些事件。 地图事件系统 RPG Maker MV &gt; 事件 &gt; 地图事件系统 地图事件处理流程 事件表示（Expressing Events） 游戏中地图事件详情的声明遵循以下流程：在哪里（位置），何种情况（表现出来的情况）， 被何种行动触发, 将会发生什么（事件执行内容）。 比如角色对话和有物品的箱子这种类型的事件，表现为指派到地图事件的图像，而地图事件声明了“将会发生什么”。另外，像出入建筑，场景切换之类的过程，可以用没有图像的事件来实现。 创建事件的时候，你首先需要在主窗口的地图上面决定“在哪里 和 发生什么”。然后，你就可以定义剩余的内容，比如“什么情况下发生”。 事件页面的“条件”（Event Pages with “Conditional” Contents） 地图事件中，你可以根据当前游戏状态来决定发生什么事情。 [Event Pages]（事件页）就负责这一块。事件页[conditionally]（条件）决定了发生的事件内容。你可以设定一个事件页多达20页的事件，同时指定不同的图像，触发条件，并为每一个事件页指定一个事件内容。 换句话说，你可以在一个地图事件中[根据条件]有20种不同选择。 用条件限制事件页 决定“何种情况” 使用哪个特定的事件页的参数是 条件。“条件” 基于开关和变量或者”玩家是否拥有某个特定的物品”而设定。 游戏流程中地图事件的发生基于事件页中设定的条件是否被满足。当有许多事件页满足设定的[条件]时，地图中拥有最高数字的事件页将会被触发。反之，将不会发生任何事件。 计量游戏状态 使用开关来计量游戏状态 事件页中的条件当中，[Switches]（开关）和 [Variables]（变量）是用来设定条件的主要手段。 开关能记录[ON]和[OFF]的值。这个用来计量一些二值化的游戏状态，例如“玩家是否已经接受了国王的任务”，“玩家是否打败了boss”。 游戏开始时，所有的开关都被设置为[OFF]。最重要的是，当触发了一个事件的时候，你可以将相应的[开关]值在事件页“内容”（事件产生的结果）里设置为[ON]。 通过在别的事件页的[条件]里读取之前设定的[开关]状态，你可以用一个开关值来控制其他所有地图事件的内容。整个游戏剧情发展都可以通过持续改变开关状态来控制事件触发来构建。 用变量来追踪数值 [变量]可以用来存储任意值（整数）。游戏开始时候数值被自动设为0， 你可以根据游戏状态来给变量赋值或者与其他值做加法（通过Control Variables事件命令）。 通过使用变量，你可以精细控制地图事件的出现条件和结果，比如，根据玩家的剩余HP、金钱或其他数值来改变事件的内容。 管理开关变量 在一个游戏里，你最多可以使用共5000个开关/变量。开关或者变量的数量多少和如何使用都取决于你。使用合理的命名帮你理解这个开关/变量的用途以及两者的区别。你可以在他们各自的选择窗口设置他们的名字。 在自主事件中使用“独立开关” 地图事件还支持独立开关。独立开关只能在某事件的内部使用，每个事件最多四个（A到D）。 当一个事件的进程控制仅由它自己完成的时候，可以使用独立开关。例如：一个含有宝物的宝箱就可以使用独立开关来判断是否已被开启过。设置两个事件页（未被开启和已被开启），在第一个事件页（未被开启）页的最后打开独立开关，使之成为第二个事件页出现的条件，这样只有在宝箱未被开启（第一次触发）的时候才能得到宝物。 地图事件创建和控制 RPG Maker MV &gt; 事件 &gt; 地图事件创建和控制 地图事件创建和控制切换到编辑模式为了创建和编辑地图事件，首先通过点击主窗口工具栏中的事件按钮切换到事件编辑模式（菜单栏中使用[Mode]（模式） -&gt; [Events]（事件）也可以切换） 创建一个新的地图事件要创建新地图事件，先在地图上双击你需要放置事件的地方。然后在弹出的Event Editor中编辑你的设定，按下[OK]按钮确定。要获得更多关于设置参数的帮助，请查看[地图事件设置]. 再编辑和移动当你放置一个地图事件的时候，一个图标将会在你事件的位置显示（你第一个事件页选择的图像会默认被使用）。双击这个图像，会再次打开[Event Editor]（事件编辑器）窗口，这里你可以再次编辑事件设置。此时，你也可以通过拖动图标来移动你的事件位置。 通过上下文菜单控制当你在事件编辑模式右击地图的时候，你可以复制或者删除已经放置的事件。上下文菜单有如下功能。 Edit（编辑） (当图块没有事件的时候，这里是“New”，新建事件) 打开事件编辑器窗口 Cut （剪切） 复制当前事件到剪贴板并删除当前事件 Copy （复制） 复制你右击的地图事件 Paste （粘贴） 粘贴剪贴板的地图时间到你右击的位置 Delete （删除） 删除你右击的地图事件 Quick Event Creation （快速创建事件） 使用默认配置创建四个类型的事件（稍后会提到） Set Starting Position（设置初始点） 设定玩家和交通工具的起始点。起始点将会被蓝色框标识。 *事件图标使用白色框 快速事件创建通过使用上下文菜单中的Quick Event Creation，你可以创建四种传统RPG中常用的事件类型（使用默认设置）：[Transfer]（场所移动）, Door, [Treasure]（宝物）, [Inn]（旅馆） 就像其他事件一样，使用“快速事件创建”创建的事件一样可以编辑，复制其的参数和进行其他可以对标准事件进行的操作。 Transfer（场所移动） 在地图上的指定位置创建一个不可见的事件，将玩家传送到指定位置。请在楼梯或者入口这种地方使用这个事件。在Location和[Direction]（方向）参数中指定玩家被传送的目的地和玩家的朝向。 Door（门） 创建包含一张图像的事件，它会将玩家传送到指定位置。使用[Image]（图像）字段指定显示的图像，用[Location]（位置）字段指定玩家被传送到的位置。 Treasure（宝物） 创建一个可以在玩家第一次打开时从宝箱获得物品的事件。使用[Image]（图像）字段指定显示的图像，通过[Content]（执行内容）字段指定玩家能获得什么样的物品（金币/物品/武器/防具） Inn（旅馆） 创建一个可以让你的队伍完成回复的事件，使用[Image]（图像）字段指定显示的图像， 使用[Price]（价格）字段指定回复的价格。 地图事件设置 RPG Maker MV &gt; 事件 &gt; 地图事件设置 通用设置和事件页（Event Pages）设置 ID (标题栏显示)每个事件都有自己的唯一ID，ID会在事件创建时根据这张地图内创建顺序被自动分配。事件ID被用于如指定事件使用特定变量的情况。 Name （名字）地图事件的名字，这个属性仅被用在编辑器（不会影响游戏）。ID将会被自动输入作为初始名字。必要时可以改动名字以提高可读性。 Note （备注）给自己看的备注 Event Page ID（事件页ID）包含在这个事件当中的事件页ID。通过点击选项卡，你可以切换到你想要编辑的事件页。 Event Page Control Buttons（事件页控制按钮）窗口顶部的按钮可以进行创建，删除事件页等操作。每个按钮的功能罗列如下。 New Event Page（新建事件页） 在当前正在编辑的事件页后创建一个新的事件页。每个额外事件页创建时将会有一个数字自增ID。 Copy Event Page（复制事件页） 复制当前事件页的内容到剪贴板。 Paste Event Page （粘贴事件页） 从剪贴板复制的内容中添加（插入）一个事件页到当前编辑的事件页之后。事件页创建时将会获得一个自增ID。 Delete Event Page （删除事件页） 删除当前编辑的事件页。在这个事件页之后的事件页ID将会被减1。 Clear Event Page （清空事件页） 清空当前正在编辑的事件页内容（重置为初始状态）。 事件页设置 Conditions（触发条件）这个事件页的内容触发的条件。触发条件可以在[Switch]（开关）, [Variable]（变量）, [Self Switch]（独立开关）, [Item]（物品） and [Actor]（角色）。设定特定的条件以满足你的需求。 如果你希望事件无条件触发，那么不要设置任何条件。如果你设置多了多个条件，那么事件仅会在所有条件都满足的情况下事件才会被触发。 如果有多个事件页的条件被同时满足了，那么拥有最大ID的事件页内容将会被触发。反之，如果没有事件页的条件被满足则不会有任何事件页被触发。 Switch（开关） 如果开关被设置为ON则此类型事件将会被触发 Variable （变量） 指定变量大于给定值的时候事件将会被触发。 Self Switch （独立开关） 指定独立开关变成ON状态时被触发。 Item （物品） 一个队伍拥有指定物品的时候事件将被触发。 Actor （角色） 指定角色在队伍中时事件将被触发。 Image （图像）当事件出现在地图上的时候图像会被显示。要指定图像，双击事件框中心并在弹出的Select an Image窗口中点击文件列表（左边）和图像（右边）并选中。 如果你没设置图像，则事件图像将不可见。在选择图像的窗口中选择位于文件列表顶部的[(None)]可以删除已经设置的图像。 Autonomous Movement （自动移动）用[Type]（类型）、[Speed]（速度）和Frequency 来指定地图事件的移动方式。[速度]定义了移动的速度，数值越大移动越快。[频率]定义了移动的周期，数值越大周期越短。Type让你指定下面四种移动方式之一。 Fixed(固定) 地图事件将不会移动 Random （随机） 地图事件将会随机四处移动 Approach （接近） 地图事件将会自动接近玩家 Custom （自定义） 沿一条特定的路线移动。单击[移动路线]的时候可以指定路线。更多信息请参见 [设置移动路线]. Options可选的图像的显示方式。需要的话就选中特定的选项。 Walking（步行动画） 移动的时候播放步行动画。当事件是角色或动物等的时候使用。 Stepping（踏步动画） 不动的时候播放踏步动画。当事件是波浪或火焰等的时候使用。 Direction Fix （固定朝向） 禁止改变图像的朝向，即使是在移动的时候。 Through（允许穿透） 允许它穿过一些无法通行的地形或事件。 优先级在下面的选项中指定一个以确定事件和玩家的高低位置关系。如果事件和玩家可以重叠，那么位置在上方的图像优先显示。 Below characters（人物下方） 玩家和其他角色可以从该事件上方通过。然而，如果在[Image]（图像）中选择了一个图块作为图像，那么玩家能否通行会根据这个图块的通行度来决定。 Same as characters（与人物同层） 将事件和玩家置于同层，禁止玩家走到该事件的位置。 Above characters（人物上方） 玩家和其他角色可以从该事件下方通过。 触发条件对于已经出现在地图上了的事件，在下面的选项中指定一个以确定什么时候执行事件的[Contents]（执行内容）。 Action Button(按确定键) 当玩家面对事件（如果允许重叠就是和玩家重叠）按下确定键的时候执行。 Player Touch(玩家接触) 玩家碰触到事件（如果允许重叠就是经过事件）的时候执行。这种情况下按确定键也会执行。 Event Touch（事件接触） 当一个Autonomous Movement的事件碰到了玩家（如果允许重叠就是经过玩家），以及[玩家接触]的时候执行。 Autorun（自动执行） 当事件满足出现条件，出现在地图上后立刻执行。 并行处理 当事件满足出现条件，出现在地图上后立刻执行（周期性地循环处理执行内容）。 Contents （事件内容）当满足[Conditions]（触发条件）满足的时候执行的命令列表。更多信息请看接下来的项目：”编辑事件指令”。 编辑内容查看执行内容列表在执行内容中，将游戏中的处理以“Event Commands”的方式进行编辑 事件指令会从顶部开始按顺序处理，并且被应用到游戏内容中。已被添加的事件指令会在行的最左端有一个[◆]的标记。以[:]开头的行是它上方的事件指令的内容，或者是处理流程发生分支的位置 添加事件指令要向列表中注册一个事件指令，只需要双击有[◆]标记的行。在弹出的窗口中，选择要使用的事件指令，然后定义想要的行为和设置即可（除了一小部分）。新双击的位置已经存在事件指令时，新添加的事件指令会插入到双击的位置。 上下文菜单的操作已经被注册了的事件指令有一个[◆]的标记。在这样的行上面右击会弹出一个菜单，里面有一些常用操作如[Copy]（复制）和[Delete]（删除）。这些项目的功能如下。 New（新建） 在选择的指令的上一行插入一条新的事件指令 Edit（编辑） 编辑选中的事件指令。 Cut（剪切） 把当前的事件指令复制到剪贴板并删除。 Copy（复制） 把当前的事件指令复制到剪贴板。 Paste（粘贴） 把剪贴板中的内容插入到选择的位置。 Delete（删除） 删除所选的事件指令。 Select All（全选） 将列表中的所有事件指令全部选中。 Copy as Text (August 4th, 2016 Update) Copies the selected lines of text to the clipboard. Copy as HTML Tags (August 4th, 2016 Update) Copies the HTML of the selected lines of text to the clipboard. Test（测试） 在游戏中测试所有选中指令 选择多行指令单击选中开始的那一行，然后按住[Shift]键单击结束的那一行。这样在这两行之间的所有带[◆]标记的指令都会被选中。在选中的事件指令（会变成蓝色）上右键就可以弹出一个上下文菜单，你可以在里面选择一些操作，这些操作会影响所有被选中的指令。值得注意的是，如果选择的指令在一个分支中，只有处于同一个分支的指令才能用这种方式选中。 事件指令集 RPG Maker MV &gt; 事件指令集 在事件中的[执行内容]里使用的事件指令有如下。善用这些来创作你的游戏故事吧。 第1页▼信息 显示文字 显示选择 数值输入处理 物品选择处理 显示滚动文字 ▼游戏进程 开关操作 变量操作 独立开关操作 计时器操作 ▼流程控制 条件分支 循环 跳出循环 终止事件处理 公共事件 标签 转至标签 注释 ▼队伍 增减金钱 增减物品 增减武器 增减防具 队伍管理 ▼角色 增减HP 增减MP 增减TP 增减状态 完全恢复 增减经验值 增减等级 增减能力值 增减技能 更换装备 更改名字/a&gt; 更改职业 更改称号 更改外观 第2页▼移动 场所移动 设置载具位置 设置事件位置 卷动地图 设置移动路径 载具升/降 ▼人物 更改透明度 更改队列行进 集合队列成员 显示动画 显示心情 暂时消除事件 ▼图片 显示图片 移动图片 旋转图片 更改图片色调 消除图片 ▼时间调整 等待 ▼画面效果 淡出画面 淡入画面 更改画面色调 闪烁画面 震动画面 设置天气效果 ▼音频与视频 播放BGM 淡出BGM 记忆BGM 还原BGM 播放BGS 淡出BGS 播放ME 播放SE 停止SE 播放视频 第3页▼场景控制 战斗处理 商店处理 名字输入处理 打开菜单场景 打开存档场景 结束游戏 返回标题 ▼系统设定 调节战斗BGM 更改战斗胜利ME 更改战斗失败ME 更换载具BGM 启用/禁用存档 启用/禁用菜单 启用/禁用遇敌 启用/禁用整队 更改窗口色调 更改角色图像 更改载具图像 ▼地图 启用/禁用地图名称 更改地图图块组 更改战斗图背景 更改远景图 获取指定位置的信息 ▼战斗 增减敌人HP 增减敌人MP 增减敌人TP 更改敌人状态 敌人完全恢复 敌人出现 敌人变身 显示战斗动画 强制战斗 中止战斗 ▼高级 脚本 插件命令","categories":[],"tags":[{"name":"RPG Maker MV","slug":"RPG-Maker-MV","permalink":"http://yoursite.com/tags/RPG-Maker-MV/"}]},{"title":"Git","slug":"Git","date":"2020-06-20T02:26:28.000Z","updated":"2020-06-20T02:27:04.239Z","comments":true,"path":"2020/06/20/Git/","link":"","permalink":"http://yoursite.com/2020/06/20/Git/","excerpt":"","text":"1.Git简介 Git是目前世界上最先进的分布式版本控制系统，在处理各种项目时都十分高效，而且非常的高大上。 SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。而且集中式版本控制系统是必须联网才能工作。 Git是分布式版本控制系统，它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。 2.Git安装（仅列出在Windows系统下的安装过程）打开Git官网下载安装程序，然后按照默认选项安装即可。 安装完成后，打开Git bash软件，弹出一个类似cmd的命令行窗口，证明安装成功。 安装完成后，需要进行设置，在命令行输入以下代码： 12345$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 顾名思义，这是设置你的名字和Email地址。 我们可以查看一下用户名和密码： 12345$ git config user.name$ git config user.email 假如我们这时候报错，证明Git的用户名和密码没有配置成功，我们还可以这样做： 在用户主目录下找到 .git 文件夹： 然后打开 config 文件，这是专门用来配置和读取相应的工作环境变量的，在里面加上如图所示内容： 这样也就完成了对Git用户名和邮箱的配置。 3.创建版本库版本库(repository)也叫仓库，可以看做一个目录，这个目录里的所以文件都由Git进行管理，每个文件的修改、删除，Git都能跟踪。 1.选择一个合适的地方，创建一个空目录：`` `` 12345678910111213$ mkdir learngit &#x2F;&#x2F;创建一个名叫learngit的空目录$ cd learngit &#x2F;&#x2F;把learngit设置为当前目录$ pwd &#x2F;&#x2F;查看当前目录&#x2F;c&#x2F;Users&#x2F;Administrator&#x2F;learngit 如果使用Windows系统，要保证目录名不包含中文。 2.通过如下命令把这个目录变成Git可以管理的仓库： 12345$ git initInitialized empty Git repository in &#x2F;Users&#x2F;Administrator&#x2F;learngit&#x2F;.git&#x2F; 这样Git就把仓库建好啦，我们可以看到在当前目录下多了一个 .git 的目录，这个目录是Git来跟踪管理版本库的。 3.把文件添加到版本库 我们在 learngit 目录下编写一个 readme.txt 文件，内容如下： 12345Git is a version control system.Git is free software. (1) 用 git add 命令，把文件添加到仓库： 1$ git add readme.txt 执行以上命令，没有任何显示。 (2) 用 git commit 命令，把文件提交到仓库： 12345678910111213$ git commit -m &quot;wrote a readme file&quot; &#x2F;&#x2F;-m后面输入的是本次提交的说明，可以输入任意内容。[master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) &#x2F;&#x2F;1 file changed：1个文件被改动（新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt内有两行内容） create mode 100644 readme.txt 4.修改文件我们已经成功添加并提交了一个 readme.txt 文件，继续修改 readme.txt 文件，改成如下内容： 12345Git is a distributed version control system.Git is free software. 运行 git status 命令： 123456789101112131415161718192021222324252627282930313233$ git status &#x2F;&#x2F;查看仓库当前的状态On branch masterChanges not staged for commit: &#x2F;&#x2F;没有文件将要被提交 (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;) 上面的命令告诉我们，readme.txt 文件被修改过了，但还没有准备提交的修改。 如果我们想知道上次是怎么修改readme.txt 文件的，需要用 git diff 命令： 123456789101112131415161718192021222324252627282930313233$ git diff readme.txt diff --git a&#x2F;readme.txt b&#x2F;readme.txtindex 46d49bf..9247db6 100644--- a&#x2F;readme.txt+++ b&#x2F;readme.txt@@ -1,2 +1,2 @@-Git is a version control system. &#x2F;&#x2F;这一句是被删掉的+Git is a distributed version control system. &#x2F;&#x2F;这一句是新添加的 Git is free software. 接下来还是那两步： (1) git add 1$ git add readme.txt 没有任何输出，这时候可以用 git status 查看一下当前仓库状态： 123456789101112131415161718192021$ git statusOn branch masterChanges to be committed: &#x2F;&#x2F;将要被提交的文件包括 readme.txt (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txt ``(2) git commit 123456789$ git commit -m &quot;add distributed&quot;[master e475afc] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 再用 git status 查看一下当前仓库状态： 123456789$ git statusOn branch masternothing to commit, working tree clean &#x2F;&#x2F;当前没有需要提交的修改，而且，工作目录是干净的。 5.版本回退如果我们继续对 readme.txt 文件进行修改，改成如下内容： 12345Git is a distributed version control system.Git is free software distributed under the GPL. 然后添加并提交： 12345678910111213$ git add readme.txt$ git commit -m &quot;append GPL&quot;[master 1094adb] append GPL 1 file changed, 1 insertion(+), 1 deletion(-) 到目前为止，readme.txt 文件一共有三个版本被提交到了 Git 仓库里，我们可以用 git log 命令进行查看： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869$ git log &#x2F;&#x2F;查看历史记录commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:06:15 2018 +0800 append GPL commit e475afc93c209a690c39c13a46716e8fa000c366Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 21:03:36 2018 +0800 add distributed commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0Author: Michael Liao &lt;askxuefeng@gmail.com&gt;Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 我们还可以加上 –pretty=oneline 参数： 12345678910111213$ git log --pretty&#x3D;oneline1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPLe475afc93c209a690c39c13a46716e8fa000c366 add distributedeaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file &#x2F;&#x2F;一大串数字是 commit id ，而且每个人的都不一样。 好了，现在如果我们想把 readme.txt 文件退回到上一个版本，就可以使用 git reset 命令： 12345$ git reset --hard HEAD^ &#x2F;&#x2F;HEAD表示当前版本，则HEAD^表示上一个版本，那么上上版本就是HEAD^^HEAD is now at e475afc add distributed 这时候用 cat 命令查看一下 readme.txt 的内容： 123456789$ cat readme.txt &#x2F;&#x2F;查看 readme.txt 文件的内容Git is a distributed version control system.Git is free software. 果然 readme.txt 文件返回到了上一个版本。 我们现在想要回到最新的版本，还是使用 git reset 命令： 12345$ git reset --hard 1094a &#x2F;&#x2F;这里不能用HEAD而必须使用 commit id ，因为最新版本在之前返回时已经被删除了，1094a就是最新版本的 commit id，可以在之前的代码中查到HEAD is now at 83b0afe append GPL 这时再查看一下 readme.txt 文件内容： 123456789$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL. 果然，又回到了最新的版本。 6.工作区和暂存区工作区（Working Directory） learngit 文件夹就是一个工作区。 版本库（Repository） 工作区有个隐藏目录 .git ，这个不算工作区，而是 Git 的版本库。 版本库里面的 index(stage) 文件叫暂存区，还有Git为我们自动创建的第一个分支 master ，以及指向 master 的一个指针叫做 HEAD。 前面我们提到过，如果我们想把文件添加到Git里面时，需要分两步： 第一步是用 git add 把文件添加进去，实际上就是把文件修改添加到暂存区。 第二步是用 git commit 提交更改，实际上就是把暂存区的所有内容提交到当前分支。（我们现在只有唯一一个分支 master，所以现在就是往 master 分支上提交更改） 我们可以实践一下： 在 readme.txt 文件中加上一行内容： 123456789Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage. 然后在工作区新建一个 LICENSE 文本文档（任意内容） 使用两次 git add 命令分别把 readme.txt 和 LICENSE 都添加后，可以用 git status 命令查看一下： 12345678910111213141516171819202122232425$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: LICENSE modified: readme.txt 现在，暂存区的状态就变成这样了： 再使用 git commit 命令把暂存区的所有修改提交到分支： 12345678910111213$ git commit -m &quot;understand how stage works&quot;[master e43a48b] understand how stage works 2 files changed, 2 insertions(+) create mode 100644 LICENSE 这时候的工作区就是干净的： 123456789$ git statusOn branch masternothing to commit, working tree clean 这时候版本库就变成了这样： 7.管理修改Git 如此的优秀是因为，Git 跟踪并管理的不是文件，而是修改。 我们对 readme.txt 文件进行修改： 1234567891011121314151617$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes. 然后，添加： 1234567891011121314151617181920212223242526272829$ git add readme.txt$ git status# On branch master# Changes to be committed:# (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)## modified: readme.txt# 然后再修改 readme.txt 文件： 1234567891011121314151617$ cat readme.txt Git is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 提交： 123456789$ git commit -m &quot;git tracks changes&quot;[master 519219b] git tracks changes 1 file changed, 1 insertion(+) 这时候我们查看一下状态： 123456789101112131415161718192021222324252627282930313233$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;) 我们可以发现，第二次修改并没有被提交。 因为在工作区的第一次修改被放入暂存区，准备提交；而在工作区的第二次修改并没有被放入暂存区，所以， git commit 命令只负责把暂存区的修改提交了。 提交后，我们可以用 git diff HEAD – readme.txt 命令去查看工作区和版本库里面最新版本的区别： 1234567891011121314151617181920212223242526272829303132333435363738394041$ git diff HEAD -- readme.txt diff --git a&#x2F;readme.txt b&#x2F;readme.txtindex 76d770f..a9c5755 100644--- a&#x2F;readme.txt+++ b&#x2F;readme.txt@@ -1,4 +1,4 @@ Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage.-Git tracks changes.+Git tracks changes of files. 8.撤销修改假如说你在 readme.txt 文件中添加了一行内容如下： 123456789101112131415161718192021$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN. 最后一行是万万不能让BOSS看到的，应该怎么撤销呢？ (1) 没有 git add 之前 可以手动删除最后一行，手动把文件恢复到上一个版本的状态。然后再用 git checkout – file 命令丢弃工作区的修改： 1$ git checkout -- readme.txt &#x2F;&#x2F;把readme.txt文件在工作区的修改全部撤销。 现在看一下 readme.txt 文件内容： 1234567891011121314151617$ cat readme.txtGit is a distributed version control system.Git is free software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files. 果然复原了。 (2) git add了，但没有git commit 这时候的修改添加到了暂存区，但没有提交到分支，用 git status 查看一下： 123456789101112131415161718192021$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: readme.txt 这时候我们可以使用 git reset HEAD file 命令把把暂存区的修改撤销掉，重新放回工作区： 123456789$ git reset HEAD readme.txt &#x2F;&#x2F;git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区，HEAD表示最新版本。Unstaged changes after reset:M readme.txt 现在再用 git status 查看一下： 12345678910111213141516171819202122232425$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: readme.txt &#x2F;&#x2F;暂存区是干净的，工作区有修改。 这时候再丢弃工作区的修改就OK了： 1234567891011121314151617$ git checkout -- readme.txt &#x2F;&#x2F;丢弃工作区的修改。 $ git statusOn branch masternothing to commit, working tree clean 终于大功告成了。 (3) 既 git add 了，也 git commit 了 可以回退到上一个版本，见回退版本内容。 9.删除文件在工作区即 learngit 文件夹下新建一个 test.txt 文件，并添加和提交到Git： 123456789101112131415161718192021$ git add test.txt $ git commit -m &quot;add test.txt&quot;[master b84166e] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 这时候可用 rm 命令删除： 1$ rm test.txt 这时工作区和版本库就不一样了。 现在又分两种情况： (1) 确实要从版本库中删除该文件，那就用 git rm 命令删除，并且 git commit： 12345678910111213141516171819202122232425$ git rm test.txtrm &#39;test.txt&#39; $ git commit -m &quot;remove test.txt&quot;[master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 这时候文件就从版本库被删除了。 (2) 文件被删错了。因为版本库里有，所以很好恢复： 1$ git checkout -- test.txt &#x2F;&#x2F;用版本库里的版本替换工作区的版本。 10.远程仓库准备工作在开始这部分之前，我们需要自行注册GitHub账号。而且，因为你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以需要设置： (1) 创建SSH Key。在用户主目录下，看看有没有.ssh 目录，如果有的话，看此目录下有没有 id_rsa 和 id_rsa.pub 这两个文件，如果有，直接跳到下一步。如果没有，打开Git Bash，创建SSH (2) 登陆GitHub，打开”Account settings” 然后点击”Add SSH and GPG Keys”，再点击”New SSH Key”进行SSH Key 的创建，填上任意 Title ，把 id_rsa.pub 中的内容复制到Key文本框内： 11.添加远程库现在我们已经在本地创建了一个Git仓库了，又想在GitHub上创建一个Git仓库，然后让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。那么我们应该怎么做呢？ 首先，登陆GitHub，在右上角找到“Create a new repo”按钮，创建一个新的仓库： 在Repository name填入 learngit ``（因为我已经创建完成了，所以提示此用户名存在）其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 如上图所示我已经把本地仓库的内容推送到了GitHub上了，大家创建完以后应该是一个空的仓库。这时候我们可以在本地learngit仓库下运行命令： 1$ git remote add origin git@github.com:RFHzhj&#x2F;learngit.git &#x2F;&#x2F;“RFHzhj”是我的GitHub的账户名，你需要填写你自己的账户名 添加后，远程库的名字就是 origin ，这是Git默认的叫法。 然后，我们就可以把本地库的所有内容推送到远程库上： 12345678910111213141516171819202122232425262728293031323334353637$ git push -u origin master Counting objects: 20, done.Delta compression using up to 4 threads.Compressing objects: 100% (15&#x2F;15), done.Writing objects: 100% (20&#x2F;20), 1.64 KiB | 560.00 KiB&#x2F;s, done.Total 20 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5&#x2F;5), done.To github.com:RFHzhj&#x2F;learngit.git * [new branch] master -&gt; masterBranch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;origin&#39;. 使用 git push 命令，就是把当前分支 master 推送到远程。 因为远程库是空的，所以我们在第一次推送 master 分支时，要加上 -u 参数，Git不但会把本地的master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： 1$ git push origin master 把本地 master 分支的最新修改推送至GitHub。现在，我们拥有了真正的分布式版本库。 12.从远程库克隆我们的学习过程是先有了本地库，后有了远程库，然后再对远程库进行关联。 其实，我们大部分时候是先创建远程库，然后再从远程库克隆。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"nodejs","slug":"nodejs","date":"2020-06-20T02:25:01.000Z","updated":"2020-06-20T02:25:39.665Z","comments":true,"path":"2020/06/20/nodejs/","link":"","permalink":"http://yoursite.com/2020/06/20/nodejs/","excerpt":"","text":"起源 Ryan Dahl是一名资深的C/C++程序员，在创造出Node之前，他的主要工作都是围绕高性能 Web服务器进行的。经历过一些尝试和失败之后，他找到了设计高性能，Web服务器的几个要点： 事件驱动、非阻塞I/O，而这也正是nodejs的两大特点。 所以Ryan Dahl最初的目标是写一个基于事件驱动、非阻塞I/O的Web服务器，以达到更高的性能，提供Apache等服务器之外的选择。写Node的时候，Ryan Dahl曾经评估过C、Lua、Haskell、 Ruby等语言作为备选实现，结论为：C的开发门槛高，可以预见不会有太多的开发者能将它用于日常的业务开发，所以舍弃它；Ryan Dahl觉得自己还不足够玩转Haskell，所以舍弃它；Lua自身已经含有很多阻塞I/O库，为其构建非阻塞I/O库也不能改变人们继续使用阻塞I/O库的习惯，所以也舍弃它；而Ruby的虚拟机由于性能不好而落选。 相比之下，JavaScript比C的开发门槛要低，比Lua的历史包袱要少。尽管服务器端JavaScript存在已经很多年了，但是后端部分一直没有市场，可以说历史包袱为零，为其导入非阻塞I/O库没有额外阻力。另外，JavaScript在浏览器中有广泛的事件驱动方面的应用，暗合Ryan Dahl喜好基于事件驱动的需求。当时，第二次浏览器大战也渐渐分出高下，Chrome浏览器的JavaScript引擎V8摘得性能第一的桂冠。考虑到高性能、符合事件驱动、没有历史包袱这3个主要原因，JavaScript成为了Node的实现语言。 起初，Ryan Dahl称他的项目为web.js，就是一个Web服务器，但是项目的发展超过了他最初单纯开发一个Web服务器的想法，变成了构建网络应用的一个基础框架，这样可以在它的基础上构建更多的东西，诸如服务器、客户端、命令行工具等。Node发展为一个强制不共享任何资源的单线程、单进程系统，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施，其目标也是成为一个构建快速、可伸缩的网络应用平台。它自身非常简单，通过通信协议来组织许多Node，非常容易通过扩展来达成构建大型网络应用的目的。每一个Node进程都构成这个网络应用中的一个节点，这是它名字所含意义的真谛。 特点 作为后端JavaScript的运行平台，Node保留了前端浏览器JavaScript中那些熟悉的接口，没有改写语言本身的任何特性，依旧基于作用域和原型链，区别在于它将前端中广泛运用的思想迁移到了服务器端。Node相较于其他语言的特点如下所示： 1、异步I/O 在Node中，绝大多数的操作都以异步的方式进行调用。Ryan Dahl排除万难，在底层构建了很多异步I/O的API，从文件读取到网络请求等，均是如此。这样的意义在于，在Node中，我们可 以从语言层面很自然地进行并行I/O操作。每个调用之间无须等待之前的I/O调用结束。在编程模型上可以极大提升效率。 以同时执行两个文件读取任务为例，异步I/O取决于最慢的那个文件读取的耗时，而同步I/O的耗时是两个任务的耗时之和。这里异步带来的优势是显而易见的。 2、事件 随着Web 2.0时代的到来，JavaScript在前端担任了更多的职责，事件也得到了广泛的应用。 Node不像Rhino那样受Java的影响很大，而是将前端浏览器中应用广泛且成熟的事件引入后端， 配合异步I/O，将事件点暴露给业务逻辑。 事件的编程方式具有轻量级、松耦合、只关注事务点等优势，但是在多个异步任务的场景下，事件与事件之间各自独立，如何协作是一个问题。 3、回调函数 与其他的Web后端编程语言相比，Node除了异步和事件外，回调函数是一大特色。纵观下来，回调函数也是最好的接受异步调用返回数据的方式。但是这种编程方式对于很多习惯同步思路编程的人来说，也许是十分不习惯的。代码的编写顺序与执行顺序并无关系，这对他们可能造成阅读上的障碍。在流程控制方面，因为穿插了异步方法和回调函数，与常规的同步方式相比，变得不那么一目了然了。 4、单线程 JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征。 Node保持了JavaScript在浏览器中单线程的特点。而且在Node中，JavaScript与其余线程是无法共享任何状态的。单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。 同样，单线程也有它自身的弱点，具体有以下3方面：无法利用多核CPU；错误会引起整个应用退出，应用的健壮性值得考验；大量计算占用CPU导致无法继续调用异步I/O。 像浏览器中JavaScript与UI共用一个线程一样，JavaScript长时间执行会导致UI的渲染和响应被中断。在Node中，长时间的CPU占用也会导致后续的异步I/O发不出调用，已完成的异步I/O的回调函数也会得不到及时执行。 HTML5定制了Web Workers的标准，Web Workers能够创建工作线程来进行计算，以解决JavaScript大计算阻塞UI渲染的问题。工作线程为了不阻塞主线程，通过消息传递的方式来传递运行结果，这也使得工作线程不能访问到主线程中的UI。 Node采用了与Web Workers相同的思路来解决单线程中大计算量的问题：child_process。 子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问题。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来传递结果，这可以很好地保持应用模型的简单和低依赖。通过Master-Worker的管理方式，也可以很好地管理各个工作进程，以达到更高的健壮性。 应用场景 在进行技术选型之前，需要了解一项新技术具体适合什么样的场景，毕竟合适的技术用在合适的场景可以起到意想不到的效果。关于Node，探讨得较多的主要有I/O密集型和CPU密集型。 1、I/O密集型 如果将所有的脚本语言拿到一处来评判，那么从单线程的角度来说，Node处理I/O的能力是值得竖起拇指称赞的。通常， 说Node擅长I/O密集型的应用场景基本上是没人反对的。Node面向网络且擅长并行I/O，能够有效地组织起更多的硬件资源，从而提供更多好的服务。 I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请求服务，资源占用极少 2、CPU密集型 换一个角度，在CPU密集的应用场景中，Node是否能胜任呢？实际上，V8的执行效率是十分高的。单以执行效率来做评判，V8的执行效率是毋庸置疑的。 CPU密集型应用给Node带来的挑战主要是：由于JavaScript单线程的原因，如果有长时间运行的计算（比如大循环），将会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好处，又能充分利用CPU。","categories":[],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"}]},{"title":"Valine- 一款快速、简洁且高效的无后端评论系统","slug":"Valine- 一款快速、简洁且高效的无后端评论系统","date":"2020-06-19T13:09:47.000Z","updated":"2020-06-20T02:07:34.718Z","comments":true,"path":"2020/06/19/Valine- 一款快速、简洁且高效的无后端评论系统/","link":"","permalink":"http://yoursite.com/2020/06/19/Valine-%20%E4%B8%80%E6%AC%BE%E5%BF%AB%E9%80%9F%E3%80%81%E7%AE%80%E6%B4%81%E4%B8%94%E9%AB%98%E6%95%88%E7%9A%84%E6%97%A0%E5%90%8E%E7%AB%AF%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"介绍Valine - 一款快速、简洁且高效的无后端评论系统。 在Github上编辑此页 由于某些原因，src目录将从v1.4.0后暂停更新. Valine 诞生于2017年8月7日，是一款基于LeanCloud的快速、简洁且高效的无后端评论系统。 理论上支持但不限于静态博客，目前已有Hexo、Jekyll、Typecho、Hugo、Ghost 等博客程序在使用Valine。 特性 快速 安全 Emoji 😉 无后端实现 MarkDown 全语法支持 轻量易用 文章阅读量统计 v1.2.0+ TodoValine 现在仍处于开发阶段，这里有一些目前还不支持、但已经在计划中的特性： 基于Firebase的评论存储 或者更多… 欢迎你为 Valine 的开发作出贡献。 快速开始 在Github上编辑此页 如果你想在某个网页或者文章页中使用Valine，请参照以下步骤配置 获取APP ID 和 APP Key请先登录或注册 LeanCloud, 进入控制台后点击左下角创建应用： 应用创建好以后，进入刚刚创建的应用，选择左下角的设置&gt;应用Key，然后就能看到你的APP ID和APP Key了： HTML 片段修改初始化对象中的appId和appKey的值为上面刚刚获取到的值即可(其他可以默认)。 12345678910111213141516&lt;head&gt; .. &lt;script src='//unpkg.com/valine/dist/Valine.min.js'&gt;&lt;/script&gt; ...&lt;/head&gt;&lt;body&gt; ... &lt;div id=\"vcomments\"&gt;&lt;/div&gt; &lt;script&gt; new Valine(&#123; el: '#vcomments', appId: 'Your appId', appKey: 'Your appKey' &#125;) &lt;/script&gt;&lt;/body&gt; 配置修改初始化对象中的appId和appKey的值为上面刚刚获取到的值即可(其他可以默认)。 12345new Valine(&#123; el: '#vcomments' , appId: 'Your appId', appKey: 'Your appKey'&#125;); npmValine 现已发布到npm，可以直接用命令安装： 12# Install valinenpm install valine --save 123456789// Use importimport Valine from 'valine';// or Use requireconst Valine = require('valine');new Valine(&#123; el:'#vcomments', // other config&#125;) 评论数据管理由于Valine 是无后端评论系统，所以也就没有开发评论数据管理功能。请自行登录Leancloud应用管理。 具体步骤：登录&gt;选择你创建的应用&gt;存储&gt;选择Class Comment，然后就可以尽情的发挥你的权利啦(～￣▽￣)～ 当然，你也可以配合 @DesertsP 开发的 Valine-Admin 进行评论数据管理 安全域名为了你的数据安全，请设置自己的安全域名： 更多信息请查看配置项。 更新日志 在Github上编辑此页 v1.4.11~v1.4.14, 2020-04-26 F 紧急重新修复可能存在的xss漏洞 #298 #294 #293 F 再次修复阅读数回填失败的Bug F 修复某些异常未正常捕获的Bug v1.4.10, 2020-04-25 F 修复表情判断失败的Bug #286 #296 F 修复可能存在的xss漏洞 #294 #293 F 修复阅读数回填失败的Bug F 修复获取QQ信息时的缓存Bug F 表情size适配修复 #295 U 一些样式修改 U 代码逻辑优化 v1.4.8~v1.4.9, 2020-04-23 F 优化SDK加载逻辑，修复Code 98错误 #289 #288 #285 F 修复文章列表阅读次数回填失败的Bug #287 #272 U 一些样式优化 #283 U 代码逻辑优化 v1.4.6~v1.4.7, 2020-04-22 A 新增必填项设置 #281 #59 A 新增评论框获取QQ头像和QQ昵称启用属性enableQQ，需主动启用 #277 F 修复样式被覆盖的Bug #284 #270 F 修复使用了低版本的av-min.js造成的初始化错误 U 一些样式优化 U 代码逻辑优化 v1.4.5, 2020-04-21 A 新增QQ头像的支持(昵称框输入QQ号试试) #192 A 新增自定义表情 #261 #260 #150 F 修复marked渲染错误的Bug #275 #269 F 修复代码高亮样式被覆盖的Bug #270 F 修复阅读次数异常的Bug #272 F 修复在夜间模式下样式渲染异常的Bug U 一些样式优化 U 代码逻辑优化 v1.4.0~1.4.4, 2020-04-11 A 新的SDK加载逻辑 A 新增图片表情 A 新增截图粘贴上传 A 新增图片拖拽至评论框上传 A 新增对MathJax的支持 A 新增对KaTex的支持 A 新增评论框楼内回复 A 新增对夜间模式的支持 #221 A 全新的评论区UI界面 A 新增对zh-CN/zh-TW/en/jp等多国语言的支持 F 修复回复评论时评论数据需要刷新才会显示的Bug #257 F 修复表情和预览只能点开不能收回的Bug #254 F 修复Edge浏览器识别为Chrome的Bug #250 F 修复Storage is not defined的Bug #242 F 修复可能存在的xss漏洞 #218 F 修复分页Bug #196 F 修复点击展开更多击穿Bug #180 F 修复个别UA识别失败的Bug F 修复回复评论后评论数变为1的Bug #264 U 表情图片懒加载 #261 U 删除验证码 #207 U 删除自带的邮件提醒 #20 U 代码逻辑优化 注: MathJax 和 KaTex 需要当前页面已加载并配置好相关的资源文件. v1.3.10, 2019-08-29 A 新的SDK加载逻辑 A 新增可选配置项serverURLs，默认http://自动检测节点.avoscloud.com #206 #203 #194 F 修复列表页阅读量统计失效BUG #136 F 其他BUG修复 v1.3.8,v1.3.9, 2019-06-26 A 新的SDK加载逻辑 F 修复字体样式/待办事项渲染问题 #175 #182 F 修复各节点无法访问的Bug #188 #189 #190 F 紧急修复无回复按钮 Bug F 其他 Bug 修复 v1.3.7, 2019-06-21 A 新增clazzName字段，自定义配置LeanCloud表名 #162 F 修复LeanCloud服务不可访问问题 F 修复待办事项列表渲染Bug #182 F 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 尝试性修复字体大小问题 \\#175 ## v1.3.6, 2019-04-01- &#96;F&#96; 修复代码高亮失效的 &#96;Bug&#96;- &#96;F&#96; 修复以前可以使用&#96;Pjax&#96;而&#96;v1.3.5&#96;版本失效的 &#96;Bug&#96; (感谢小伙伴 [@sxyugao](https:&#x2F;&#x2F;github.com&#x2F;sxyugao) 提供的建议)- &#96;F&#96; 修复评论内容中点击 &#96;@NickName&#96; 跳转到新页面的 &#96;Bug&#96;- &#96;F&#96; 其他 &#96;Bug&#96; 修复## v1.3.5, 2019-03-29- &#96;A&#96; 新增隐私保护：移除页面中的敏感(E-mail)数据- &#96;A&#96; 新增&#96;recordIP&#96; 属性(&#96;Boolean&#96;)：增加IP统计 by [@Showfom](https:&#x2F;&#x2F;github.com&#x2F;Showfom) [#160](https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine&#x2F;issues&#x2F;160)- &#96;U&#96; 一些样式修改- &#96;U&#96; 代码逻辑优化## v1.3.4, 2018-11-24- &#96;F&#96; 修复&#96;img&#96;的&#96;xss&#96;安全漏洞- &#96;F&#96; 修复&#96;embed&#96;的&#96;xss&#96;安全漏洞- &#96;F&#96; 修复评论框内容不重置的bug## v1.3.3, 2018-09-26- &#96;F&#96; 修复可以自定义&#96;CSS&#96;的 Bug## v1.3.1, 2018-09-03- &#96;A&#96; 新增 &#96;avatarForce&#96; 字段，每次访问强制拉取最新的&#96;评论列表头像&#96;- &#96;F&#96; 修复提交评论后，评论框不重置的 Bug## v1.3.0, 2018-07-29- &#96;A&#96; 新增 &#96;pid&#96; 字段- &#96;A&#96; 新增&#96;at&#96;锚点定位- &#96;U&#96; 过滤掉 &#96;iframe&#96; 等HTML元素- &#96;F&#96; BUG 修复 # 配置项[ 在Github上编辑此页](https:&#x2F;&#x2F;github.com&#x2F;xcss&#x2F;Valine-docs&#x2F;tree&#x2F;master&#x2F;source&#x2F;configuration.md)Valine 支持两种不同的初始化方式。一种是构造方法初始化对象，另一种是调用&#96;init&#96;方法：&#96;&#96;&#96;html&lt;!-- 方法 1 --&gt;&lt;script&gt; new Valine(&#123; el:&#39;#vcomment&#39;, appId: &#39;Your appId&#39;, appKey: &#39;Your appKey&#39; &#125;)&lt;&#x2F;script&gt;&lt;!-- 方法 2 --&gt;&lt;script&gt; var valine &#x3D; new Valine(); valine.init(&#123; el:&#39;#vcomment&#39;, appId: &#39;Your appId&#39;, appKey: &#39;Your appKey&#39; &#125;)&lt;&#x2F;script&gt; el 类型:String 默认值:null 必要性:true Valine 的初始化挂载器。可以是一个CSS 选择器，也可以是一个实际的HTML元素。 appId 类型:String 默认值:null 必要性:true 从LeanCloud的应用中得到的appId. 获取appId 和 appKey。 appKey 类型:String 默认值:null 必要性:true 从LeanCloud的应用中得到的appKey. 获取appId 和 appKey。 region 类型:String 默认值:cn 必要性:false 存储节点：在Valine中初始化时默认遵循Leancloud SDK的节点规则(默认中国大陆节点)。 Leancloud js-sdk 从 v3.8.0版本开始删除了region选项:leancloud/javascript-sdk/releases/tag/v3.8.0 可选值: cn - 中国大陆节点 us - 海外节点 placeholder 类型:String 默认值:Just go go 必要性:false 评论框占位提示符。 notify 类型:Boolean 默认值:false 必要性:false v1.4.0+ 已废弃 verify 类型:Boolean 默认值:false 必要性:false 验证码服务。 v1.4.0+ 已废弃 path 类型:String 默认值:window.location.pathname 必要性:false 当前文章页路径，用于区分不同的文章页，以保证正确读取该文章页下的评论列表。可选值： window.location.pathname (默认值，推荐) window.location.href 自定义 I. 请保证每个文章页路径的唯一性，否则可能会出现不同文章页下加载相同评论列表的情况。 II. 如果值为window.location.href，可能会出现随便加不同参数进入该页面，而被判断成新页面的情况。 avatar 类型:String 默认值:mm 必要性:false Gravatar 头像展示方式。 可选值： &#39;&#39;(空字符串) mp identicon monsterid wavatar retro robohash hide 更多信息，请查看头像配置。 meta 类型:Array 默认值:[&#39;nick&#39;,&#39;mail&#39;,&#39;link&#39;] 必要性:false 评论者相关属性。 pageSize 类型:Number 默认值:10 必要性:false 评论列表分页，每页条数。 lang 类型:String 默认值:zh-CN 必要性:false 多语言支持。 可选值： zh-CN zh-TW en ja 如需自定义语言，请参考i18n。 visitor 类型:Boolean 默认值:false 必要性:false 文章访问量统计。 highlight 类型：Boolean 默认值: true 必要性: false 代码高亮，默认开启，若不需要，请手动关闭 avatarForce 类型: Boolean 默认值: false 必要性: false 每次访问强制拉取最新的评论列表头像 不推荐设置为true，目前的评论列表头像会自动带上Valine的版本号 recordIP 类型: Boolean 默认值: false 必要性: false 是否记录评论者IP 1v1.3.5+ serverURLs 类型: String 默认值: http[s]://[tab/us].avoscloud.com 必要性: false ⚠️ 该配置适用于国内自定义域名用户, 海外版本会自动检测(无需手动填写) v1.3.10+ emojiCDN 类型: String 默认值: `` 必要性: false 设置表情包CDN，参考自定义表情 1v1.4.5+ emojiMaps 类型: Object 默认值: null 必要性: false 设置表情包映射，参考自定义表情 1v1.4.5+ enableQQ 类型: Boolean 默认值: false 必要性: false 是否启用昵称框自动获取QQ昵称和QQ头像, 默认关闭，需博/网站主主动启用 1v1.4.6+ requiredFields 类型: Array 默认值: [] 必要性: false 设置必填项，默认匿名，可选值： [&#39;nick&#39;] [&#39;nick&#39;,&#39;mail&#39;] 1v1.4.6+ 头像配置 在Github上编辑此页 Valine 目前使用的是Gravatar 作为评论列表头像。 请自行登录或注册Gravatar，然后修改自己的头像。 评论的时候，留下在Gravatar注册时所使用的邮箱即可。 感谢gravatar.cat.net提供的镜像服务。 如果你修改了头像后发现没有更新，请不要慌张，因为gravatar.cat.net 有七天的缓存期，安静的等待吧~ 目前非自定义头像有以下7种默认值可选: 参数值 表现形式 备注 空字符串&#39;&#39; Gravatar官方图形 mp 神秘人(一个灰白头像) identicon 抽象几何图形 monsterid 小怪物 wavatar 用不同面孔和背景组合生成的头像 retro 八位像素复古头像 robohash 一种具有不同颜色、面部等的机器人 hide 不显示头像 1234new Valine(&#123; ... avatar:'' // (''/mp/identicon/monsterid/wavatar/robohash/retro/hide)&#125;); 邮件提醒Valine 评论系统中的邮件提醒设置 在Github上编辑此页 !!! 自带的邮件提醒功能将在v1.4.0发布时下线，请使用自带邮件提醒的用户注意更改为第三方邮件提醒 第三方支持如果你对Valine自带的邮件提醒不满意，其实还使用更完善的第三方邮件提醒： Valine-Admin (by @zhaojun1998) 多语言支持 在Github上编辑此页 基本用法现在，Valine开始支持多语言。默认内置： zh-CN zh-TW en ja 123456new Valine(&#123; el:'#vcomment', appId:'Your appId', appKey:'Your appKey', lang:'en' // 设置这里就ok&#125;) 自定义语言自定义语言只需两步： 定义langName和langMode 初始化 Valine 请严格按照下面的langMode格式书写内容: 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 1.定义 langName 和 langMode var langName = 'en', langMode = &#123; \"nick\": \"NickName\", \"mail\": \"E-Mail\", \"link\": \"Website(http://)\", \"nickFail\":\"NickName cannot be less than 3 bytes.\", \"mailFail\":\"Please confirm your email address.\", \"sofa\": \"No comment yet.\", \"submit\": \"Submit\", \"reply\": \"Reply\", \"cancelReply\": \"Cancel reply\", \"comments\": \"Comments\", \"cancel\": \"Cancel\", \"confirm\": \"Confirm\", \"continue\": \"Continue\", \"more\": \"Load More...\", \"preview\": \"Preview\", \"emoji\": \"Emoji\", \"expand\": \"See more....\", \"seconds\": \"seconds ago\", \"minutes\": \"minutes ago\", \"hours\": \"hours ago\", \"days\": \"days ago\", \"now\": \"just now\", \"uploading\":\"Uploading ...\", \"uploadDone\":\"Upload completed!\", \"busy\":\"Submit is busy, please wait...\", \"code-98\":\"Valine initialization failed, please check your version of av-min.js.\", \"code-99\": \"Valine initialization failed, Please check the `el` element in the init method.\", \"code-100\": \"Valine initialization failed, Please check your appId and appKey.\", \"code-140\":\"The total number of API calls today has exceeded the development version limit.\", \"code-401\": \"Unauthorized operation, Please check your appId and appKey.\", \"code-403\": \"Access denied by API domain white list, Please check your security domain.\" &#125;;// 2.初始化 Valinenew Valine(&#123; el:'#vcomment', appId:'Your appId', appKey:'Your appKey', lang: langName, langMode: langMode&#125;) v1.1.8-beta9开始支持。 文章阅读量统计 在Github上编辑此页 Valine 从 v1.2.0 开始支持文章阅读量统计。 12345new Valine(&#123; el:'#vcomments', ... visitor: true // 阅读量统计&#125;) 如果开启了阅读量统计，Valine 会自动检测 leancloud 应用中是否存在Counter类，如果不存在会自动创建，无需手动创建~ Valine会自动查找页面中class值为leancloud_visitors的元素，获取其id为查询条件。并将得到的值填充到其class的值为leancloud-visitors-count的子元素里： 12345&lt;!-- id 将作为查询条件 --&gt;&lt;span id=\"&lt;Your/Path/Name&gt;\" class=\"leancloud_visitors\" data-flag-title=\"Your Article Title\"&gt; &lt;em class=\"post-meta-item-text\"&gt;阅读量 &lt;/em&gt; &lt;i class=\"leancloud-visitors-count\"&gt;1000000&lt;/i&gt;&lt;/span&gt; 当前页访问次数 24789 Next 主题阅读量统计请参考：#7d17575 #345 基本用法123456789101112131415Valine&#96;从&#96;v1.4.5&#96;开始支持&#96;自定义表情&#96;。默认内置&#96;微博表情new Valine(&#123; el:&#39;#vcomment&#39;, appId:&#39;&lt;Your_APP_ID&gt;&#39;, appKey:&#39;&lt;Your_APP_KEY&gt;&#39;, &#x2F;&#x2F; 这里设置CDN, 默认微博表情CDN emojiCDN: &#39;https:&#x2F;&#x2F;img.t.sinajs.cn&#x2F;t4&#x2F;appstyle&#x2F;expression&#x2F;ext&#x2F;normal&#x2F;&#39;, &#x2F;&#x2F; 表情title和图片映射 emojiMaps: &#123; &quot;smile&quot;:&quot;e3&#x2F;2018new_weixioa02_org.png&quot;, &quot;lovely&quot;:&quot;09&#x2F;2018new_keai_org.png&quot;, &#x2F;&#x2F; ... 更多表情 &#125; &#125;) 举个栗子比如我们要用Bilibili的表情包(效果可以在评论区查看): 123456789101112131415161718192021222324252627282930313233new Valine(&#123; el:'#vcomment', appId:'&lt;Your_APP_ID&gt;', appKey:'&lt;Your_APP_KEY&gt;', // 设置Bilibili表情包地址 emojiCDN: '//i0.hdslb.com/bfs/emote/', // 表情title和图片映射 emojiMaps: &#123; \"tv_doge\": \"6ea59c827c414b4a2955fe79e0f6fd3dcd515e24.png\", \"tv_亲亲\": \"a8111ad55953ef5e3be3327ef94eb4a39d535d06.png\", \"tv_偷笑\": \"bb690d4107620f1c15cff29509db529a73aee261.png\", \"tv_再见\": \"180129b8ea851044ce71caf55cc8ce44bd4a4fc8.png\", \"tv_冷漠\": \"b9cbc755c2b3ee43be07ca13de84e5b699a3f101.png\", \"tv_发怒\": \"34ba3cd204d5b05fec70ce08fa9fa0dd612409ff.png\", \"tv_发财\": \"34db290afd2963723c6eb3c4560667db7253a21a.png\", \"tv_可爱\": \"9e55fd9b500ac4b96613539f1ce2f9499e314ed9.png\", \"tv_吐血\": \"09dd16a7aa59b77baa1155d47484409624470c77.png\", \"tv_呆\": \"fe1179ebaa191569b0d31cecafe7a2cd1c951c9d.png\", \"tv_呕吐\": \"9f996894a39e282ccf5e66856af49483f81870f3.png\", \"tv_困\": \"241ee304e44c0af029adceb294399391e4737ef2.png\", \"tv_坏笑\": \"1f0b87f731a671079842116e0991c91c2c88645a.png\", \"tv_大佬\": \"093c1e2c490161aca397afc45573c877cdead616.png\", \"tv_大哭\": \"23269aeb35f99daee28dda129676f6e9ea87934f.png\", \"tv_委屈\": \"d04dba7b5465779e9755d2ab6f0a897b9b33bb77.png\", \"tv_害羞\": \"a37683fb5642fa3ddfc7f4e5525fd13e42a2bdb1.png\", \"tv_尴尬\": \"7cfa62dafc59798a3d3fb262d421eeeff166cfa4.png\", \"tv_微笑\": \"70dc5c7b56f93eb61bddba11e28fb1d18fddcd4c.png\", \"tv_思考\": \"90cf159733e558137ed20aa04d09964436f618a1.png\", \"tv_惊吓\": \"0d15c7e2ee58e935adc6a7193ee042388adc22af.png\", // ... 更多表情 &#125; &#125;) 在Jekyll中使用 在Github上编辑此页 目前，已有部分Jekyll 主题内置了Valine 评论系统，更多的主题正在逐步增加中(由于个人精力有限，内置Valine 的PR将不定时提交)。 当然，我们也欢迎更多开发者自主的提交PR 😄 staticblog.github.io Supported latest 在Hexo 中使用 在Github上编辑此页 目前，已有部分Hexo主题内置了Valine 评论系统，更多的主题正在逐步增加中(由于个人精力有限，内置Valine的PR将不定时提交)。 当然，我们也欢迎更多开发者自主的提交PR 😄 hexo-theme-ils Supported latest hexo-theme-matery Supported latest hexo-theme-stun Supported latest hexo-theme-apolloZ Supported latest hexo-theme-raytaylorism Open latest hexo-theme-spfk Open latest hexo-them-ochuunn Open latest cactus-dark Open latest cactus-white-cn Open latest hexo-theme-yilia Open latest hexo-theme-even Open v1.1.7 hexo-theme-random Open latest hexo-theme-volantis Supported latest hexo-theme-Cards Supproted latest Hexo-Theme-Life Supported v1.1.7-beta hexo-theme-Anisina Merge latest hexo-theme-pure Merge latest hexo-theme-typing Merge latest hexo-theme-pln Merge latest hexo-theme-landscape Merge latest fexo Merge latest hexo-theme-indigo Merge latest hexo-theme-Anatole Merged v1.1.7 maupassant-hexo Merged latest hexo-theme-mdui Merged latest hexo-theme-next Merged latest hexo-theme-material Merged latest hexo-theme-hueman Merged v1.1.7-rc3 hexo-theme-magnetic Merged v1.1.7 hexo-theme-snippet Resolved v1.2.2 hexo-theme-casper Supported latest hexo-theme-adagio Merged latest hexo-theme-fluid Supported latest hexo-theme-freemind.bithack Supported latest hexo-theme-yun Supported latest hexo-theme-arknights Supported latest 在VuePress中使用 在Github上编辑此页 目前，vuepress-plugin-comment 支持在 Vuepress 中使用 Valine，自动管理 SPA路由 相关的工作。 安装如果使用 npm： 1npm install --save vuepress-plugin-comment 如果使用 yarn: 1yarn add vuepress-plugin-comment -D 快速使用将 vuepress-plugin-comment 添加到vuepress项目的插件配置中： 12345678910111213141516module.exports = &#123; plugins: [ [ 'vuepress-plugin-comment', &#123; choosen: 'valine', // options选项中的所有参数，会传给Valine的配置 options: &#123; el: '#valine-vuepress-comment', appId: 'Your own appId', appKey: 'Your own appKey' &#125; &#125; ] ]&#125; 进阶用法 docs 在Gatsby中使用 在Github上编辑此页 可以使用gatsby-plugin-valine插件在 Gatsby 站点中嵌入 Valine 组件。 本插件支持 TypeScript（因为就是用 TypeScript 写的），目前仅支持 Gatsby v2。 安装 通过 npm 下载和安装本插件: 12345npm install --save gatsby-plugin-valine # 或者用 yarn: yarn add gatsby-plugin-valine 在项目的 gatsby-config.js 文件中加入插件配置: 123456// gatsby-config.js&#123; module.exports = &#123; plugins: [`gatsby-plugin-valine`], &#125;;&#125; 在 gatsby-config.js 中配置插件时，也支持设置插件选项，比如这样: 123456789101112131415// gatsby-config.js&#123; module.exports = &#123; plugins: [ &#123; resolve: `gatsby-plugin-valine`, options: &#123; appId: `LEANCLOUD_APP_ID`, appKey: `LEANCLOUD_APP_KEY`, avatar: `robohash`, &#125;, &#125;, ], &#125;;&#125; 使用插件插件安装好后，只需要在需要的页面中导入它并添加&lt;Valine&gt;组件标签即可。 比如你希望在一个用gatsby-starter-blog模板创建的博客站点上加入评论功能，并将 Valine 评论显示在每个博客文章页面的底部，那么只需要在src/templates/blog-post.js文件中添加如下代码： 1234567891011121314import Valine from 'gatsby-plugin-valine' // 导入...const BlogPostTemplate = (&#123; data, pageContext, location &#125;) =&gt; &#123; ... return ( &lt;Layout location=&#123;location&#125; title=&#123;siteTitle&#125;&gt; ... &lt;!-- 在页面框架最后添加Valine标签 --&gt; &lt;Valine appId=\"LEANCLOUD_APP_ID\" appKey=\"LEANCLOUD_APP_KEY\"/&gt; &lt;/Layout&gt; )&#125; 也许你已经注意到，在上例中appId和appKey的值是作为&lt;Valine&gt;标签的属性传入的。同理，其他 Valine 选项也可以用这种方式传入。 如果这种方式对你来说看着太乱，或者太麻烦（比如有多个页面都需要添加标签），那么也可以在gatsby-config.js的插件选项中进行全局设置。 标签里的局部选项会与gatsby-config.js提供的全局选项进行深度合并（lodash的merge行为），且局部选项会覆盖同名的全局选项。 Valine 选项如前文所述，Valine 选项可以通过插件选项或组件属性进行设置。除el以外，本插件支持 Valine 1.4.14版本所提供的所有可用选项。el属性在插件中会被改写，因此设置了也没效果。 关于 Valine 选项的更多详细描述，请参阅配置项。 Valine组件的各属性已经编写了详细的注释，TypeScript 开发者可以在支持的代码编辑器中直接查看。 下面是插件支持的 Valine 选项列表，以便快速查阅。列表使用 TypeScript 的语法进行了类型描述。 1234567891011121314151617appId?: stringappKey?: stringplaceholder?: stringpath?: stringavatar?: '' | 'mp' | 'identicon' | 'monsterid' | 'wavatar' | 'retro' | 'robohash' | 'hide'meta?: ('nick' | 'mail' | 'link')[]pageSize?: numberlang?: stringvisitor?: booleanhighlight?: booleanavatarForce?: booleanrecordIP?: booleanserverURLs?: stringemojiCDN?: stringemojiMaps?: Record&lt;string, string&gt;enableQQ?: booleanrequiredFields?: ['nick'] | ['nick', 'mail'] 为组件设置样式&lt;Valine&gt; 组件支持 style 和 className 两个属性，以便开发者进行 CSS 样式重写和定制。 自定义的样式和 CSS 类名会被应用到Valine的容器 DOM 节点上，即拥有 CSS 类v的那个节点。自定义的类名会出现在v之前。 使用 CDN 在Github上编辑此页 推荐使用 unpkg —— 能及时获取到最新版本。 也可以在 jsdelivr 和 cdnjs 上获取 (cdnjs 的版本更新可能略滞后)。 获取最新版本123456&lt;!-- do not set the version number --&gt;&lt;script src=\"//unpkg.com/valine/dist/Valine.min.js\"&gt;&lt;/script&gt;&lt;!-- or set latest --&gt;&lt;script src=\"//unpkg.com/valine@latest/dist/Valine.min.js\"&gt;&lt;/script&gt;&lt;!-- or Default value --&gt;&lt;script src=\"//unpkg.com/valine\"&gt;&lt;/script&gt; 获取指定版本1&lt;script src=\"//unpkg.com/valine@1.4.4/dist/Valine.min.js\"&gt;&lt;/script&gt;","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"}]},{"title":"python爬取酷狗音乐歌曲","slug":"python爬取酷狗音乐歌曲","date":"2020-06-19T13:09:47.000Z","updated":"2020-06-20T03:47:04.410Z","comments":true,"path":"2020/06/19/python爬取酷狗音乐歌曲/","link":"","permalink":"http://yoursite.com/2020/06/19/python%E7%88%AC%E5%8F%96%E9%85%B7%E7%8B%97%E9%9F%B3%E4%B9%90%E6%AD%8C%E6%9B%B2/","excerpt":"","text":"经过测试，可以下载要付费下载的歌曲（n_n） 准备工作：Python3.5+Pycharm使用到的库：requests，re，json，time，fakeuseragent步骤： 打开酷狗音乐的官网，输入想要搜索的歌曲（例如《天后》），然后回车搜索，得到如下页面： 右键检查或者按F12打开开发者工具，点击JS选项，查找到如下信息，FileName就是返回的歌手名和歌曲名信息，我们要将其提取出来： 由于这个网址返回的不是标准的json格式，所以要先进行如下处理，然后再转换成json格式： 12res &#x3D; requests.get(url).textjs &#x3D; json.loads(res[res.index(&#39;(&#39;) + 1:-2]) 1提取到歌曲信息之后，我们输入一个序号代表要下载的歌曲序号，然后把歌曲下载下来就好了。这里需要提取出来的是FileHash，这个值会用于构造歌曲详情的URL，该URL格式如下： 1http:&#x2F;&#x2F;www.kugou.com&#x2F;yy&#x2F;index.php?r&#x3D;play&#x2F;getdata&amp;hash&#x3D;&lt;FileHash&gt; 1打开这个链接后会一个如下图所示的Json格式文件，其中包含了歌曲名称、歌手、歌曲时长等信息，其中play_url是歌曲链接，将其提取出来使用requests中的content下载即可。 1运行截图： 源代码（还在努力完善中）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970# coding:utf-8\"\"\"Version: Python3.8Author: 初一三班李天行Site: http://gw-lazybones.github.ioTime: 2019/6/10 15:00\"\"\"import reimport osimport jsonimport timeimport requestsfrom fake_useragent import UserAgentos.system (\"md music\")os.system (\"cls\")os.system (\"color 2\")ua = UserAgent()def get_song(song_name): search_url = \"https://songsearch.kugou.com/song_search_v2?callback=jQuery112405132987859127838_1550204317910&amp;page\" \\ \"=1&amp;pagesize=30&amp;userid=-1&amp;clientver=&amp;platform=WebFilter&amp;tag=em&amp;filter=2&amp;iscorrection=1&amp;privilege_fil\" \\ \"ter=0&amp;_=1550204317912&amp;keyword=&#123;&#125;\".format(song_name) headers1 = &#123; \"UserAgent\": ua.random &#125; headers2 = &#123; \"Cookie\": \"kg_mid=3786e26250f01bf2c64bc515820d9752; Hm_lvt_aedee6983d4cfc62f509129360d6bb3d=1559960644; Hm_lpvt_aedee6983d4cfc62f509129360d6bb3d=1559960644; ACK_SERVER_10015=%7B%22list%22%3A%5B%5B%22bjlogin-user.kugou.com%22%5D%5D%7D; ACK_SERVER_10016=%7B%22list%22%3A%5B%5B%22bjreg-user.kugou.com%22%5D%5D%7D; ACK_SERVER_10017=%7B%22list%22%3A%5B%5B%22bjverifycode.service.kugou.com%22%5D%5D%7D; kg_dfid=0iEqIA1uep0h0AogH30Jq1Od; kg_dfid_collect=d41d8cd98f00b204e9800998ecf8427e\", \"Host\": \"www.kugou.com\", \"Referer\": \"http://www.kugou.com/\", \"UserAgent\": ua.random &#125; res = requests.get(search_url, headers=headers1) # print(res.text) start = re.search(\"jQuery\\d+_\\d+\\(?\", res.text) js = json.loads(res.text.strip().lstrip(start.group()).rstrip(\")\")) # 注意：末尾有一个换行需要去掉 song_list = js['data']['lists'] for i in range(10): print(str(i + 1) + \"&gt;&gt;&gt;\" + str(song_list[i]['FileName']).replace('&lt;em&gt;', '').replace('&lt;/em&gt;', '')) num = int(input(\"\\n请输入您想要下载的歌曲序号：\")) print(\"请稍等，下载歌曲中...\") time.sleep(1) file_hash = song_list[num - 1]['FileHash'] hash_url = \"http://www.kugou.com/yy/index.php?r=play/getdata&amp;hash=&#123;&#125;\".format(file_hash) # print(hash_url) hash_res = requests.get(hash_url, headers=headers2) hash_js = hash_res.json() # json格式 # print(hash_js) play_url = hash_js['data']['play_url'] # 下载歌曲 try: with open(\"music/\" + song_name + \".mp3\", \"wb\")as fp: fp.write(requests.get(play_url).content) print(\"歌曲已下载完成！\") except Exception as e: print(e)if __name__ == '__main__': print (\"作者：广州外校初一三班李天行\\n官网：https://GW-Lazybones.github.io\\n未经允许禁止转载\\n\\n\") get_song(input(\"请输入您想要搜索的歌曲名称：\")) exe下载链接","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python简介","slug":"Python简介","date":"2020-06-19T10:00:54.000Z","updated":"2020-06-19T10:12:59.470Z","comments":true,"path":"2020/06/19/Python简介/","link":"","permalink":"http://yoursite.com/2020/06/19/Python%E7%AE%80%E4%BB%8B/","excerpt":"","text":"编程语言有“高低”之分，而高级语言又有很多种，比如 C++、Java、C#、PHP、JavaScript 等，Python 也是其中之一。从本节开始，我们将正式开始学习 Python 这门高级编程语言，但是在此之前，我们有必要先讨论一下“Python 是什么”。 Python 英文原意为“蟒蛇”，直到 1989 年荷兰人 Guido van Rossum （简称 Guido）发明了一种面向对象的解释型编程语言，并将其命名为 Python，才赋予了它表示一门编程语言的含义。 我们将在《编译型语言和解释型语言的区别》一文中讲解什么是解释型语言。 图 1 Python 的标志（Logo） 说道 Python，它的诞生是极具戏曲性的，据 Guido 的自述记载，Python 语言是他在圣诞节期间为了打发时间开发出来的，之所以会选择 Python 作为该编程语言的名字，是因为他是一个叫 Monty Python 戏剧团体的忠实粉丝。 Python 语言是在 ABC 教学语言的基础上发展来的；遗憾的是，ABC 语言虽然非常强大，但却没有普及应用，Guido 认为是它不开放导致的。 基于这个考虑，Guido 在开发 Python 时，不仅为其添加了很多 ABC 没有的功能，还为其设计了各种丰富而强大的库，利用这些 Python 库，程序员可以把使用其它语言制作的各种模块（尤其是C语言和 C++）很轻松地联结在一起，因此 Python 又常被称为“胶水”语言。 这里的库和模块，简单理解就是一个个的源文件，每个文件中都包含可实现各种功能的方法（也可称为函数）。 从整体上看，Python 语言最大的特点就是简单，该特点主要体现在以下 2 个方面： Python 语言的语法非常简洁明了，即便是非软件专业的初学者，也很容易上手。 和其它编程语言相比，实现同一个功能，Python 语言的实现代码往往是最短的。 对于 Python，网络上流传着“人生苦短，我用 Python”的说法。 因此，看似 Python 是“不经意间”开发出来的，但丝毫不比其它编程语言差。事实也是如此，自 1991 年 Python 第一个公开发行版问世后： 2004 年起 Python 的使用率呈线性增长，不断受到编程者的欢迎和喜爱； 2010 年，Python 荣膺 TIOBE 2010 年度语言桂冠； 2017 年，IEEE Spectrum 发布的 2017 年度编程语言排行榜中，Python 位居第 1 位。 直至现在（2019 年 12 月份），根据 TIOBE 排行榜的显示，Python 也居于第 3 位，且有继续提升的态势（如表 2 所示）。 2019年12月 2018年12月 编程语言 市场份额 变化 1 1 Java 17.253% +1.32% 2 2 C 16.086% +1.80% 3 3 Python 10.308% +1.93% 4 4 C++ 6.196% -1.37% 5 6 C# 4.801% +1.35% 6 5 Visual Basic .NET 4.743% -2.38% 7 7 JavaScript 2.090% -0.97% 8 8 PHP 2.048% -0.39% 9 9 SQL 1.843% -0.34% 10 14 Swift 1.490% +0.27% 11 17 Ruby 1.314% +0.21% 12 11 Delphi/Object Pascal 1.280% -0.12% 13 10 Objective-C 1.204% -0.27% 14 12 Assembly language 1.067% -0.30% 15 15 Go 0.995% -0.19% 16 16 R 0.995% -0.12% 17 13 MATLAB 0.986% -0.30% 18 25 D 0.930% +0.42% 19 19 Visual Basic 0.929% -0.05% 20 18 Perl 0.899% -0.11% 显然，Python 已经将 C++ 语言甩在了后边，直逼 C 语言和 Java，而且未来有可能超越它们，成为编程语言排行榜冠军。 我们不妨再看一下 Python 历年来的市场份额变化曲线，Python 的未来大势可期。 图 2 Python 历年来市场份额变化曲线 错过了 C/C++ 的 PC 时代，又错过了 Java 的互联网和智能手机时代，你还想错过 Python 的人工智能和大数据时代吗？Python 正位于软件产业的第四次风口之上，把握好风口，你就能飞起来。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Hexo优化","slug":"Hexo优化","date":"2020-06-13T12:00:54.000Z","updated":"2020-06-14T06:48:54.521Z","comments":true,"path":"2020/06/13/Hexo优化/","link":"","permalink":"http://yoursite.com/2020/06/13/Hexo%E4%BC%98%E5%8C%96/","excerpt":"","text":"本文将讲述一些博客主题的美化、实用功能的添加，本文以作者 luuman 的 spfk 主题和作者 xaoxuu 的 Material X 主题为例，文章会不定时进行更新。文章涉及有关参考资料、教程、链接如有侵权请联系我删除！ 本文在CSDN的链接：《Hexo 博客优化之博客美化》、《Hexo 博客优化之实用功能添加》，Hexo 博客专栏，从前期搭建到后期美化，帮您解决常见问题：《Github/Coding Pages + Hexo》，对您有帮助就点个赞吧❤️ 请注意：不同主题可能方法有些不同，相同主题不同版本，配置方法也有所差异！ 博客美化前提条件：有一定的前端基础，了解 HTML、CSS、JS，了解 CSS 预处理语言 Sass、Less、Stylus，搞懂 hexo 的目录结构。 博客美化通用步骤：选定主题，认真阅读主题文档，分析主题目录结构，了解每个文件是对应网页哪个部分的，认真阅读美化教程，美化教程本质上只为你提供核心代码和思路，具体代码要添加到哪个地方，需要你自己搞懂主题结构，添加到需要的、合适的位置！ 博客美化终极奥秘：创作第一，体验第二，避免繁杂，简洁为上！ 【01】添加评论系统主流的评论系统有很多，比如：网易云跟帖、多说、友言、畅言、来必力（LiveRe）、Disqus、Valine、Gitment等等，目前网易云跟帖、多说、友言都已经关闭了，还有些可能需要翻墙，比较麻烦，百度了一下，最后还是选择了来必力评论系统 进入来必力官网，注册一个账号（注册时可能需要翻墙） 注册完毕之后，登录，进入安装页面，选择 City 免费版安装，安装之后你会得到一段代码 我们打开主题文件下的 _config.yml 文件，添加如下代码： 在 \\themes\\hexo-theme-spfk\\layout_partial\\comments 文件夹下新建一个 livere.ejs 的文件，在里面填写来必力提供的代码： 123456789101112131415161718复制&lt;!-- 来必力City版安装代码 --&gt;&lt;div id&#x3D;&quot;lv-container&quot; data-id&#x3D;&quot;city&quot; data-uid&#x3D;&quot;这里是你的uid&quot;&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt; (function(d, s) &#123; var j, e &#x3D; d.getElementsByTagName(s)[0]; if (typeof LivereTower &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123; return; &#125; j &#x3D; d.createElement(s); j.src &#x3D; &#39;https:&#x2F;&#x2F;cdn-city.livere.com&#x2F;js&#x2F;embed.dist.js&#39;; j.async &#x3D; true; e.parentNode.insertBefore(j, e); &#125;)(document, &#39;script&#39;); &lt;&#x2F;script&gt; &lt;noscript&gt;为正常使用来必力评论功能请激活JavaScript&lt;&#x2F;noscript&gt;&lt;&#x2F;div&gt;&lt;!-- City版安装代码已完成 --&gt; 打开 \\themes\\hexo-theme-spfk\\layout_partial\\article.ejs 文件，在适当位置添加如下红框中的代码： 完成以上操作之后，我们就可以使用来必力评论系统了 【02】添加卡通人物我在逛别人博客的时候偶然发现右下角居然有一个萌萌的卡通人物，还能根据你鼠标位置摇头，瞬间被吸引到了，赶紧也给自己博客添加一个吧！点击此处进入该项目地址 输入如下命令获取 live2d ： 1复制$ npm install --save hexo-helper-live2d 输入以下命令，下载相应的模型，将 packagename 更换成模型名称即可，更多模型选择请点击此处，各个模型的预览请访问原作者的博客 1复制$ npm install packagename 打开站点目录下的 _config.yml 文件，添加如下代码： 1234567891011复制live2d: enable: true scriptFrom: local model: use: live2d-widget-model-haruto #模型选择 display: position: right #模型位置 width: 150 #模型宽度 height: 300 #模型高度 mobile: show: false #是否在手机端显示 设置好过后我们就拥有了一个卡通人物 【03】自定义鼠标指针样式在 \\themes\\material-x\\source\\less_base.less 文件 body 样式里写入如下代码： 123456复制body &#123; cursor: url(https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;TRHX&#x2F;CDN-for-itrhx.com@2.1.6&#x2F;images&#x2F;mouse.cur),auto; background-color: @theme_background; ...... ......&#125; 鼠标指针可以用 Axialis CursorWorkshop 这个软件自己制作，不同主题具体放的文件有所不同，确保在博客主体 body 的 CSS 文件中即可，其中的鼠标指针链接可替换成自己的，首先尝试加载 https://cdn.jsdelivr.net/gh/TRHX/CDN-for-itrhx.com@2.1.6/images/mouse.cur ，如果该文件不存在或由于其他原因无效，那么 auto 会被使用，也就是自动默认效果，图片格式为.ico、.ani、.cur，建议使用.cur，如果使用.ani或者其他格式无效，原因是浏览器兼容问题，请阅读参考文档或者参考以下兼容表： 浏览器 最低版本 格式 Internet Explorer 6.0 .cur / .ani Firefox (Gecko), Windows and Linux 1.5 (1.8) .cur / .png / .gif / .jpg Firefox (Gecko) 4.0 (2.0) .cur / .png / .gif / .jpg / .svg Opera — — Safari (Webkit) 3.0 (522-523) .cur / .png / .gif / .jpg 拓展阅读：《CSS 鼠标样式 cursor属性》 （By：歪脖先生的博客） 【04】添加鼠标点击爱心效果在 \\themes\\hexo-theme-spfk\\source\\js 下新建文件 love.js，在 love.js 文件中添加以下代码： 1复制!function(e,t,a)&#123;function n()&#123;c(&quot;.heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: &#39;&#39;;width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 500%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;&quot;),o(),r()&#125;function r()&#123;for(var e&#x3D;0;e&lt;d.length;e++)d[e].alpha&lt;&#x3D;0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+&#x3D;.004,d[e].alpha-&#x3D;.013,d[e].el.style.cssText&#x3D;&quot;left:&quot;+d[e].x+&quot;px;top:&quot;+d[e].y+&quot;px;opacity:&quot;+d[e].alpha+&quot;;transform:scale(&quot;+d[e].scale+&quot;,&quot;+d[e].scale+&quot;) rotate(45deg);background:&quot;+d[e].color+&quot;;z-index:99999&quot;);requestAnimationFrame(r)&#125;function o()&#123;var t&#x3D;&quot;function&quot;&#x3D;&#x3D;typeof e.onclick&amp;&amp;e.onclick;e.onclick&#x3D;function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a&#x3D;t.createElement(&quot;div&quot;);a.className&#x3D;&quot;heart&quot;,d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a&#x3D;t.createElement(&quot;style&quot;);a.type&#x3D;&quot;text&#x2F;css&quot;;try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText&#x3D;e&#125;t.getElementsByTagName(&quot;head&quot;)[0].appendChild(a)&#125;function s()&#123;return&quot;rgb(&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;,&quot;+~~(255*Math.random())+&quot;)&quot;&#125;var d&#x3D;[];e.requestAnimationFrame&#x3D;function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3&#x2F;60)&#125;&#125;(),n()&#125;(window,document); 在 \\themes\\hexo-theme-spfk\\layout\\layout.ejs 文件末尾添加以下代码： 12复制&lt;!-- 页面点击小红心 --&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;love.js&quot;&gt;&lt;&#x2F;script&gt; 完成以上操作后，当我们点击鼠标的时候就可以看见爱心的特效了 【05】添加鼠标点击显示字体效果在 \\themes\\hexo-theme-spfk\\source\\js 下新建文件 click_show_text.js，在 click_show_text.js 文件中添加以下代码： 123456789101112131415161718192021222324252627282930313233复制var a_idx &#x3D; 0;jQuery(document).ready(function($) &#123; $(&quot;body&quot;).click(function(e) &#123; var a &#x3D; new Array (&quot;富强&quot;, &quot;民主&quot;, &quot;文明&quot;, &quot;和谐&quot;, &quot;自由&quot;, &quot;平等&quot;, &quot;公正&quot;, &quot;法治&quot;, &quot;爱国&quot;, &quot;敬业&quot;, &quot;诚信&quot;, &quot;友善&quot;); var $i &#x3D; $(&quot;&lt;span&#x2F;&gt;&quot;).text(a[a_idx]); a_idx &#x3D; (a_idx + 1) % a.length; var x &#x3D; e.pageX, y &#x3D; e.pageY; $i.css(&#123; &quot;z-index&quot;: 5, &quot;top&quot;: y - 20, &quot;left&quot;: x, &quot;position&quot;: &quot;absolute&quot;, &quot;font-weight&quot;: &quot;bold&quot;, &quot;color&quot;: &quot;#FF0000&quot; &#125;); $(&quot;body&quot;).append($i); $i.animate(&#123; &quot;top&quot;: y - 180, &quot;opacity&quot;: 0 &#125;, 3000, function() &#123; $i.remove(); &#125;); &#125;); setTimeout(&#39;delay()&#39;, 2000);&#125;);function delay() &#123; $(&quot;.buryit&quot;).removeAttr(&quot;onclick&quot;);&#125; 其中的社会主义核心价值观可以根据你自己的创意替换为其他文字 如果想要每次点击显示的文字为不同颜色，可以将其中 color 值进行如下更改： 1复制&quot;color&quot;: &quot;rgb(&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;,&quot; + ~~(255 * Math.random()) + &quot;)&quot; 然后在 \\themes\\hexo-theme-spfk\\layout\\layout.ejs 文件末尾添加以下代码： 12复制&lt;!--单击显示文字--&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;click_show_text.js&quot;&gt;&lt;&#x2F;script&gt; 最终实现效果如下： 【06】添加鼠标点击烟花爆炸效果在 \\themes\\material-x\\source\\js 目录下新建一个 fireworks.js 的文件，里面写入以下代码： 1复制&quot;use strict&quot;;function updateCoords(e)&#123;pointerX&#x3D;(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY&#x3D;e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t&#x3D;anime.random(0,360)*Math.PI&#x2F;180,a&#x3D;anime.random(50,180),n&#x3D;[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;colors[anime.random(0,colors.length-1)],a.radius&#x3D;anime.random(16,32),a.endPos&#x3D;setParticuleDirection(a),a.draw&#x3D;function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle&#x3D;a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;&quot;#F00&quot;,a.radius&#x3D;0.1,a.alpha&#x3D;0.5,a.lineWidth&#x3D;6,a.draw&#x3D;function()&#123;ctx.globalAlpha&#x3D;a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth&#x3D;a.lineWidth,ctx.strokeStyle&#x3D;a.color,ctx.stroke(),ctx.globalAlpha&#x3D;1&#125;,a&#125;function renderParticule(e)&#123;for(var t&#x3D;0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a&#x3D;createCircle(e,t),n&#x3D;[],i&#x3D;0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n&#x3D;this,i&#x3D;arguments;clearTimeout(a),a&#x3D;setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl&#x3D;document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx&#x3D;canvasEl.getContext(&quot;2d&quot;),numberOfParticules&#x3D;30,pointerX&#x3D;0,pointerY&#x3D;0,tap&#x3D;&quot;mousedown&quot;,colors&#x3D;[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize&#x3D;debounce(function()&#123;canvasEl.width&#x3D;2*window.innerWidth,canvasEl.height&#x3D;2*window.innerHeight,canvasEl.style.width&#x3D;window.innerWidth+&quot;px&quot;,canvasEl.style.height&#x3D;window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render&#x3D;anime(&#123;duration:1&#x2F;0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;A&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;&quot;IMG&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;&quot;use strict&quot;;function updateCoords(e)&#123;pointerX&#x3D;(e.clientX||e.touches[0].clientX)-canvasEl.getBoundingClientRect().left,pointerY&#x3D;e.clientY||e.touches[0].clientY-canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e)&#123;var t&#x3D;anime.random(0,360)*Math.PI&#x2F;180,a&#x3D;anime.random(50,180),n&#x3D;[-1,1][anime.random(0,1)]*a;return&#123;x:e.x+n*Math.cos(t),y:e.y+n*Math.sin(t)&#125;&#125;function createParticule(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;colors[anime.random(0,colors.length-1)],a.radius&#x3D;anime.random(16,32),a.endPos&#x3D;setParticuleDirection(a),a.draw&#x3D;function()&#123;ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.fillStyle&#x3D;a.color,ctx.fill()&#125;,a&#125;function createCircle(e,t)&#123;var a&#x3D;&#123;&#125;;return a.x&#x3D;e,a.y&#x3D;t,a.color&#x3D;&quot;#F00&quot;,a.radius&#x3D;0.1,a.alpha&#x3D;0.5,a.lineWidth&#x3D;6,a.draw&#x3D;function()&#123;ctx.globalAlpha&#x3D;a.alpha,ctx.beginPath(),ctx.arc(a.x,a.y,a.radius,0,2*Math.PI,!0),ctx.lineWidth&#x3D;a.lineWidth,ctx.strokeStyle&#x3D;a.color,ctx.stroke(),ctx.globalAlpha&#x3D;1&#125;,a&#125;function renderParticule(e)&#123;for(var t&#x3D;0;t&lt;e.animatables.length;t++)&#123;e.animatables[t].target.draw()&#125;&#125;function animateParticules(e,t)&#123;for(var a&#x3D;createCircle(e,t),n&#x3D;[],i&#x3D;0;i&lt;numberOfParticules;i++)&#123;n.push(createParticule(e,t))&#125;anime.timeline().add(&#123;targets:n,x:function(e)&#123;return e.endPos.x&#125;,y:function(e)&#123;return e.endPos.y&#125;,radius:0.1,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule&#125;).add(&#123;targets:a,radius:anime.random(80,160),lineWidth:0,alpha:&#123;value:0,easing:&quot;linear&quot;,duration:anime.random(600,800)&#125;,duration:anime.random(1200,1800),easing:&quot;easeOutExpo&quot;,update:renderParticule,offset:0&#125;)&#125;function debounce(e,t)&#123;var a;return function()&#123;var n&#x3D;this,i&#x3D;arguments;clearTimeout(a),a&#x3D;setTimeout(function()&#123;e.apply(n,i)&#125;,t)&#125;&#125;var canvasEl&#x3D;document.querySelector(&quot;.fireworks&quot;);if(canvasEl)&#123;var ctx&#x3D;canvasEl.getContext(&quot;2d&quot;),numberOfParticules&#x3D;30,pointerX&#x3D;0,pointerY&#x3D;0,tap&#x3D;&quot;mousedown&quot;,colors&#x3D;[&quot;#FF1461&quot;,&quot;#18FF92&quot;,&quot;#5A87FF&quot;,&quot;#FBF38C&quot;],setCanvasSize&#x3D;debounce(function()&#123;canvasEl.width&#x3D;2*window.innerWidth,canvasEl.height&#x3D;2*window.innerHeight,canvasEl.style.width&#x3D;window.innerWidth+&quot;px&quot;,canvasEl.style.height&#x3D;window.innerHeight+&quot;px&quot;,canvasEl.getContext(&quot;2d&quot;).scale(2,2)&#125;,500),render&#x3D;anime(&#123;duration:1&#x2F;0,update:function()&#123;ctx.clearRect(0,0,canvasEl.width,canvasEl.height)&#125;&#125;);document.addEventListener(tap,function(e)&#123;&quot;sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;toggle-sidebar&quot;!&#x3D;&#x3D;e.target.id&amp;&amp;&quot;A&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;&quot;IMG&quot;!&#x3D;&#x3D;e.target.nodeName&amp;&amp;(render.play(),updateCoords(e),animateParticules(pointerX,pointerY))&#125;,!1),setCanvasSize(),window.addEventListener(&quot;resize&quot;,setCanvasSize,!1)&#125;; 然后在 \\themes\\material-x\\layout\\layout.ejs 文件中写入以下代码： 123复制&lt;canvas class&#x3D;&quot;fireworks&quot; style&#x3D;&quot;position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;&quot; &gt;&lt;&#x2F;canvas&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;animejs&#x2F;2.2.0&#x2F;anime.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;fireworks.js&quot;&gt;&lt;&#x2F;script&gt; 最终效果： 【07】添加彩色滚动变换字体在你想要添加彩色滚动变换字体的地方写入以下代码即可，其中文字可自行更改： 123456789101112131415161718192021222324252627282930313233343536373839404142复制&lt;div id&#x3D;&quot;binft&quot;&gt;&lt;&#x2F;div&gt; &lt;script&gt; var binft &#x3D; function (r) &#123; function t() &#123; return b[Math.floor(Math.random() * b.length)] &#125; function e() &#123; return String.fromCharCode(94 * Math.random() + 33) &#125; function n(r) &#123; for (var n &#x3D; document.createDocumentFragment(), i &#x3D; 0; r &gt; i; i++) &#123; var l &#x3D; document.createElement(&quot;span&quot;); l.textContent &#x3D; e(), l.style.color &#x3D; t(), n.appendChild(l) &#125; return n &#125; function i() &#123; var t &#x3D; o[c.skillI]; c.step ? c.step-- : (c.step &#x3D; g, c.prefixP &lt; l.length ? (c.prefixP &gt;&#x3D; 0 &amp;&amp; (c.text +&#x3D; l[c.prefixP]), c.prefixP++) : &quot;forward&quot; &#x3D;&#x3D;&#x3D; c.direction ? c.skillP &lt; t.length ? (c.text +&#x3D; t[c.skillP], c.skillP++) : c.delay ? c.delay-- : (c.direction &#x3D; &quot;backward&quot;, c.delay &#x3D; a) : c.skillP &gt; 0 ? (c.text &#x3D; c.text.slice(0, -1), c.skillP--) : (c.skillI &#x3D; (c.skillI + 1) % o.length, c.direction &#x3D; &quot;forward&quot;)), r.textContent &#x3D; c.text, r.appendChild(n(c.prefixP &lt; l.length ? Math.min(s, s + c.prefixP) : Math.min(s, t.length - c.skillP))), setTimeout(i, d) &#125; var l &#x3D; &quot;&quot;, o &#x3D; [&quot;青青陵上柏，磊磊涧中石。&quot;, &quot;人生天地间，忽如远行客。&quot;,&quot;斗酒相娱乐，聊厚不为薄。&quot;, &quot;驱车策驽马，游戏宛与洛。&quot;,&quot;洛中何郁郁，冠带自相索。&quot;,&quot;长衢罗夹巷，王侯多第宅。&quot;,&quot;两宫遥相望，双阙百余尺。&quot;,&quot;极宴娱心意，戚戚何所迫？&quot;].map(function (r) &#123; return r + &quot;&quot; &#125;), a &#x3D; 2, g &#x3D; 1, s &#x3D; 5, d &#x3D; 75, b &#x3D; [&quot;rgb(110,64,170)&quot;, &quot;rgb(150,61,179)&quot;, &quot;rgb(191,60,175)&quot;, &quot;rgb(228,65,157)&quot;, &quot;rgb(254,75,131)&quot;, &quot;rgb(255,94,99)&quot;, &quot;rgb(255,120,71)&quot;, &quot;rgb(251,150,51)&quot;, &quot;rgb(226,183,47)&quot;, &quot;rgb(198,214,60)&quot;, &quot;rgb(175,240,91)&quot;, &quot;rgb(127,246,88)&quot;, &quot;rgb(82,246,103)&quot;, &quot;rgb(48,239,130)&quot;, &quot;rgb(29,223,163)&quot;, &quot;rgb(26,199,194)&quot;, &quot;rgb(35,171,216)&quot;, &quot;rgb(54,140,225)&quot;, &quot;rgb(76,110,219)&quot;, &quot;rgb(96,84,200)&quot;], c &#x3D; &#123; text: &quot;&quot;, prefixP: -s, skillI: 0, skillP: 0, direction: &quot;forward&quot;, delay: a, step: g &#125;; i() &#125;; binft(document.getElementById(&#39;binft&#39;)); &lt;&#x2F;script&gt; 最终效果： 【08】添加字数统计和阅读时长先在博客目录下执行以下命令安装 hexo-wordcount 插件： 1复制$ npm i --save hexo-wordcount 注意：在 Material X 主题中，字数统计和阅读时长的功能我已提交 PR，在最新版本中，只需要安装插件后，在主题 config.yml 配置文件里，将 word_count 关键字设置为 true 即可，对于旧版本，可以通过以下方法实现： 以 Material X 主题（版本 1.2.1）为例，在 \\themes\\material-x\\layout_meta 目录下创建 word.ejs 文件，在 word.ejs 文件中写入以下代码： 123456789101112131415161718192021复制&lt;% if(isPostList || !isPostList)&#123; %&gt; &lt;% if (theme.word_count &amp;&amp; !post.no_word_count) &#123; %&gt; &lt;div style&#x3D;&quot;margin-right: 10px;&quot;&gt; &lt;span class&#x3D;&quot;post-time&quot;&gt; &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt; &lt;i class&#x3D;&quot;fa fa-keyboard&quot;&gt;&lt;&#x2F;i&gt; &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt; 字数统计: &lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; wordcount(post.content) %&gt;字&lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &amp;nbsp; | &amp;nbsp; &lt;span class&#x3D;&quot;post-time&quot;&gt; &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt; &lt;i class&#x3D;&quot;fa fa-hourglass-half&quot;&gt;&lt;&#x2F;i&gt; &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt; 阅读时长≈&lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; min2read(post.content) %&gt;分&lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;&#x2F;div&gt; &lt;% &#125; %&gt;&lt;% &#125; %&gt; 然后在主题的配置文件 _config.yml 找到 meta 关键字，将 word 填入 header 中： 123复制meta: header: [title, author, date, categories, tags, counter, word, top] footer: [updated, share] 最后在主题目录下的 _config.yml 添加以下配置即可 1复制word_count: true 效果图： 同样的，以 spfk 主题为例，在 \\themes\\hexo-theme-spfk\\layout_partial\\post 目录下创建 word.ejs 文件，在 word.ejs 文件中写入以下代码： 1234567891011121314151617复制&lt;div style&#x3D;&quot;margin-top:10px;&quot;&gt; &lt;span class&#x3D;&quot;post-time&quot;&gt; &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt; &lt;i class&#x3D;&quot;fa fa-keyboard-o&quot;&gt;&lt;&#x2F;i&gt; &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt; 字数统计: &lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; wordcount(post.content) %&gt;字&lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &amp;nbsp; | &amp;nbsp; &lt;span class&#x3D;&quot;post-time&quot;&gt; &lt;span class&#x3D;&quot;post-meta-item-icon&quot;&gt; &lt;i class&#x3D;&quot;fa fa-hourglass-half&quot;&gt;&lt;&#x2F;i&gt; &lt;span class&#x3D;&quot;post-meta-item-text&quot;&gt; 阅读时长: &lt;&#x2F;span&gt; &lt;span class&#x3D;&quot;post-count&quot;&gt;&lt;%&#x3D; min2read(post.content) %&gt;分&lt;&#x2F;span&gt; &lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;&#x2F;div&gt; 然后在 \\themes\\hexo-theme-spfk\\layout_partial\\article.ejs 中适当位置添加以下代码： 最后在主题目录下的 _config.yml 添加以下配置 1复制word_count: true 如果显示的位置不好，可以自行更改其位置，成功配置后的效果如下： 另外：要在博客底部显示所有文章的总字数，可以点击此处，根据你博客底部文件的类型选择相应的代码放在适当的位置即可，前提是要安装好 hexo-wordcount 插件，例如我使用 Material X 主题，在 \\themes\\material-x\\layout_partial 目录下的 footer.ejs 文件中添加如下代码： 12复制&lt;i class&#x3D;&quot;fas fa-chart-area&quot;&gt;&lt;&#x2F;i&gt;&lt;span class&#x3D;&quot;post-count&quot;&gt;字数统计：&lt;%&#x3D; totalcount(site) %&gt;&lt;&#x2F;span&gt; 实现效果如下： 【09】添加背景音乐打开网页版网易云音乐，选择你准备添加的背景音乐，点击生成外链播放器，前提是要有版权，不然是无法生成外链播放器的，复制底下的HTML代码 然后将此代码放到你想要放的地方，比如放在博客的左侧，则打开 \\themes\\hexo-theme-spfk\\layout_partial\\left-col.ejs 文件，将复制的HTML代码粘贴进去，再进行适当的位置设置让播放器更美观，其中 auto=1 表示打开网页自动播放音乐，auto=0 表示关闭自动播放音乐 最后效果如下： 这种网易云音乐外链的方式有很多局限性，因此推荐使用aplayer，GitHub地址为：https://github.com/MoePlayer/APlayer ，参考教程：《hexo上的aplayer应用》 【10】添加网站运行时间一个比较好的小功能，可以看见自己的博客运行多久了，时间一天天的增加，成就感也会一天天增加的在 \\themes\\hexo-theme-spfk\\layout_partial\\footer.ejs 文件下添加以下代码： 1234567891011121314151617复制&lt;span id&#x3D;&quot;timeDate&quot;&gt;载入天数...&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;times&quot;&gt;载入时分秒...&lt;&#x2F;span&gt;&lt;script&gt; var now &#x3D; new Date(); function createtime() &#123; var grt&#x3D; new Date(&quot;08&#x2F;10&#x2F;2018 17:38:00&quot;);&#x2F;&#x2F;在此处修改你的建站时间，格式：月&#x2F;日&#x2F;年 时:分:秒 now.setTime(now.getTime()+250); days &#x3D; (now - grt ) &#x2F; 1000 &#x2F; 60 &#x2F; 60 &#x2F; 24; dnum &#x3D; Math.floor(days); hours &#x3D; (now - grt ) &#x2F; 1000 &#x2F; 60 &#x2F; 60 - (24 * dnum); hnum &#x3D; Math.floor(hours); if(String(hnum).length &#x3D;&#x3D;1 )&#123;hnum &#x3D; &quot;0&quot; + hnum;&#125; minutes &#x3D; (now - grt ) &#x2F; 1000 &#x2F;60 - (24 * 60 * dnum) - (60 * hnum); mnum &#x3D; Math.floor(minutes); if(String(mnum).length &#x3D;&#x3D;1 )&#123;mnum &#x3D; &quot;0&quot; + mnum;&#125; seconds &#x3D; (now - grt ) &#x2F; 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum &#x3D; Math.round(seconds); if(String(snum).length &#x3D;&#x3D;1 )&#123;snum &#x3D; &quot;0&quot; + snum;&#125; document.getElementById(&quot;timeDate&quot;).innerHTML &#x3D; &quot;本站已安全运行 &quot;+dnum+&quot; 天 &quot;; document.getElementById(&quot;times&quot;).innerHTML &#x3D; hnum + &quot; 小时 &quot; + mnum + &quot; 分 &quot; + snum + &quot; 秒&quot;; &#125; setInterval(&quot;createtime()&quot;,250);&lt;&#x2F;script&gt; 最后效果如下： 【11】添加百度统计百度统计是百度推出的一款免费的专业网站流量分析工具，能够告诉用户访客是如何找到并浏览用户的网站，在网站上做了些什么，非常有趣，接下来我们把百度统计添加到自己博客当中 访问百度统计首页，注册一个账号后登陆，添加你的博客网站 接着点击代码获取，复制该代码 然后到目录 \\Hexo\\themes\\hexo-theme-spfk\\layout_partial 下新建一个 baidu-analytics.ejs 文件，里面粘贴你刚刚复制的代码 修改主题文件夹下的 _config.yml 文件，将你的key（图中涂掉部分）填写进去： 所有操作完成后可以在百度统计管理页面检查代码是否安装成功，如果代码安装正确，一般20分钟后，可以查看网站分析数据 另外推荐：友盟，2010年4月在北京成立，安全、可靠、公正、第三方的网站流量统计分析系统 【12】浏览器网页标题恶搞当用户访问你的博客时点击到了其他网页，我们可以恶搞一下网页标题，呼唤用户回来，首先在目录 \\themes\\material-x\\source\\js 下新建一个 FunnyTitle.js 文件，在里面填写如下代码： 1234567891011121314151617复制&#x2F;&#x2F; 浏览器搞笑标题var OriginTitle &#x3D; document.title;var titleTime;document.addEventListener(&#39;visibilitychange&#39;, function () &#123; if (document.hidden) &#123; $(&#39;[rel&#x3D;&quot;icon&quot;]&#39;).attr(&#39;href&#39;, &quot;&#x2F;funny.ico&quot;); document.title &#x3D; &#39;╭(°A°&#96;)╮ 页面崩溃啦 ~&#39;; clearTimeout(titleTime); &#125; else &#123; $(&#39;[rel&#x3D;&quot;icon&quot;]&#39;).attr(&#39;href&#39;, &quot;&#x2F;favicon.ico&quot;); document.title &#x3D; &#39;(ฅ&gt;ω&lt;*ฅ) 噫又好啦 ~&#39; + OriginTitle; titleTime &#x3D; setTimeout(function () &#123; document.title &#x3D; OriginTitle; &#125;, 2000); &#125;&#125;); 其中 funny.ico 是用户切换到其他标签后你网站的图标，favicon.ico 是正常图标，然后在 \\themes\\material-x\\layout\\layout.ejs 文件中添加如下代码： 12复制&lt;!--浏览器搞笑标题--&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;FunnyTitle.js&quot;&gt;&lt;&#x2F;script&gt; 再次部署博客后就可以看见标题搞笑的效果了： 【13】背景添加动态线条效果在 \\Hexo\\themes\\hexo-theme-spfk\\layout\\layout.ejs 文件中添加如下代码： 1234复制&lt;!--动态线条背景--&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;color&#x3D;&quot;220,220,220&quot; opacity&#x3D;&#39;0.7&#39; zIndex&#x3D;&quot;-2&quot; count&#x3D;&quot;200&quot; src&#x3D;&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;canvas-nest.js&#x2F;1.0.0&#x2F;canvas-nest.min.js&quot;&gt;&lt;&#x2F;script&gt; 其中： color：表示线条颜色，三个数字分别为(R,G,B)，默认：（0,0,0） opacity：表示线条透明度（0~1），默认：0.5 count：表示线条的总数量，默认：150 zIndex：表示背景的z-index属性，css属性用于控制所在层的位置，默认：-1 最终实现效果： 【14】添加人体时钟无意中发现了个有趣的人体时钟 HONE HONE CLOCK，作者是个日本人，点击此处访问作者博客，点击此处在作者原博客上查看动态样式，点击此处查看动态大图，如果你的博客上有合适的地方，加上一个人体时钟会很有趣的 实现代码： 12345复制&lt;!--人体时钟背景透明--&gt;&lt;script charset&#x3D;&quot;Shift_JIS&quot; src&#x3D;&quot;http:&#x2F;&#x2F;chabudai.sakura.ne.jp&#x2F;blogparts&#x2F;honehoneclock&#x2F;honehone_clock_tr.js&quot;&gt;&lt;&#x2F;script&gt;&lt;!--人体时钟背景白--&gt;&lt;script charset&#x3D;&quot;Shift_JIS&quot; src&#x3D;&quot;http:&#x2F;&#x2F;chabudai.sakura.ne.jp&#x2F;blogparts&#x2F;honehoneclock&#x2F;honehone_clock_wh.js&quot;&gt;&lt;&#x2F;script&gt; 其他网页小挂件推荐： http://abowman.com/ 里面有很多有趣的小挂件，可以养养鱼、龟、狗、仓鼠等各式各样的虚拟宠物，能根据你的鼠标指针位置移动，直接复制代码就可以用 http://www.revolvermaps.com/ 它提供网站访客地理信息，可以以2D、3D等形式显示 http://www.amazingcounters.com/ 免费网站计数器，有非常多的样式供你选择，可以设置计数器初始数值，可以设置按访问量计数，也可以按独立访问者计数 https://www.seniverse.com/widget/get 心知天气提供基于Web的免费天气插件，可以为你的网站添加一项简洁美观的天气预报功能，并自动适配PC和手机上的浏览 【15】添加RSS订阅RSS订阅是站点用来和其他站点之间共享内容的一种简易方式，即Really Simple Syndication（简易信息聚合），如果不会使用，可以参见百度百科：https://baike.baidu.com/item/RSS%E8%AE%A2%E9%98%85/663114 ；首先我们安装feed插件，在本地hexo目录下右键git bash here，输入以下命令： 1复制$ npm install hexo-generator-feed 等待安装完成后，打开hexo目录下配置文件的_config.yml，在末尾添加以下配置： 12345678910复制# Extensions## Plugins: http:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;#RSS订阅plugin:- hexo-generator-feed#Feed Atomfeed:type: atompath: atom.xmllimit: 20 随后打开主题配置文件_config.yml，添加以下配置： 1复制rss: &#x2F;atom.xml 至此，RSS订阅功能添加完成 【16】添加网站雪花飘落效果样式一和样式二分别如下： 实现方法：在 \\Hexo\\themes\\hexo-theme-spfk\\source\\js 目录下新建一个 snow.js 文件，粘贴以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170复制&#x2F;*样式一*&#x2F;(function($)&#123; $.fn.snow &#x3D; function(options)&#123; var $flake &#x3D; $(&#39;&lt;div id&#x3D;&quot;snowbox&quot; &#x2F;&gt;&#39;).css(&#123;&#39;position&#39;: &#39;absolute&#39;,&#39;z-index&#39;:&#39;9999&#39;, &#39;top&#39;: &#39;-50px&#39;&#125;).html(&#39;&amp;#10052;&#39;), documentHeight &#x3D; $(document).height(), documentWidth &#x3D; $(document).width(), defaults &#x3D; &#123; minSize : 10, maxSize : 20, newOn : 1000, flakeColor : &quot;#AFDAEF&quot; &#x2F;* 此处可以定义雪花颜色，若要白色可以改为#FFFFFF *&#x2F; &#125;, options &#x3D; $.extend(&#123;&#125;, defaults, options); var interval&#x3D; setInterval( function()&#123; var startPositionLeft &#x3D; Math.random() * documentWidth - 100, startOpacity &#x3D; 0.5 + Math.random(), sizeFlake &#x3D; options.minSize + Math.random() * options.maxSize, endPositionTop &#x3D; documentHeight - 200, endPositionLeft &#x3D; startPositionLeft - 500 + Math.random() * 500, durationFall &#x3D; documentHeight * 10 + Math.random() * 5000; $flake.clone().appendTo(&#39;body&#39;).css(&#123; left: startPositionLeft, opacity: startOpacity, &#39;font-size&#39;: sizeFlake, color: options.flakeColor &#125;).animate(&#123; top: endPositionTop, left: endPositionLeft, opacity: 0.2 &#125;,durationFall,&#39;linear&#39;,function()&#123; $(this).remove() &#125;); &#125;, options.newOn); &#125;;&#125;)(jQuery);$(function()&#123; $.fn.snow(&#123; minSize: 5, &#x2F;* 定义雪花最小尺寸 *&#x2F; maxSize: 50,&#x2F;* 定义雪花最大尺寸 *&#x2F; newOn: 300 &#x2F;* 定义密集程度，数字越小越密集 *&#x2F; &#125;);&#125;);复制&#x2F;*样式二*&#x2F;&#x2F;* 控制下雪 *&#x2F;function snowFall(snow) &#123; &#x2F;* 可配置属性 *&#x2F; snow &#x3D; snow || &#123;&#125;; this.maxFlake &#x3D; snow.maxFlake || 200; &#x2F;* 最多片数 *&#x2F; this.flakeSize &#x3D; snow.flakeSize || 10; &#x2F;* 雪花形状 *&#x2F; this.fallSpeed &#x3D; snow.fallSpeed || 1; &#x2F;* 坠落速度 *&#x2F;&#125;&#x2F;* 兼容写法 *&#x2F;requestAnimationFrame &#x3D; window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(callback) &#123; setTimeout(callback, 1000 &#x2F; 60); &#125;;cancelAnimationFrame &#x3D; window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame;&#x2F;* 开始下雪 *&#x2F;snowFall.prototype.start &#x3D; function()&#123; &#x2F;* 创建画布 *&#x2F; snowCanvas.apply(this); &#x2F;* 创建雪花形状 *&#x2F; createFlakes.apply(this); &#x2F;* 画雪 *&#x2F; drawSnow.apply(this)&#125;&#x2F;* 创建画布 *&#x2F;function snowCanvas() &#123; &#x2F;* 添加Dom结点 *&#x2F; var snowcanvas &#x3D; document.createElement(&quot;canvas&quot;); snowcanvas.id &#x3D; &quot;snowfall&quot;; snowcanvas.width &#x3D; window.innerWidth; snowcanvas.height &#x3D; document.body.clientHeight; snowcanvas.setAttribute(&quot;style&quot;, &quot;position:absolute; top: 0; left: 0; z-index: 1; pointer-events: none;&quot;); document.getElementsByTagName(&quot;body&quot;)[0].appendChild(snowcanvas); this.canvas &#x3D; snowcanvas; this.ctx &#x3D; snowcanvas.getContext(&quot;2d&quot;); &#x2F;* 窗口大小改变的处理 *&#x2F; window.onresize &#x3D; function() &#123; snowcanvas.width &#x3D; window.innerWidth; &#x2F;* snowcanvas.height &#x3D; window.innerHeight *&#x2F; &#125;&#125;&#x2F;* 雪运动对象 *&#x2F;function flakeMove(canvasWidth, canvasHeight, flakeSize, fallSpeed) &#123; this.x &#x3D; Math.floor(Math.random() * canvasWidth); &#x2F;* x坐标 *&#x2F; this.y &#x3D; Math.floor(Math.random() * canvasHeight); &#x2F;* y坐标 *&#x2F; this.size &#x3D; Math.random() * flakeSize + 2; &#x2F;* 形状 *&#x2F; this.maxSize &#x3D; flakeSize; &#x2F;* 最大形状 *&#x2F; this.speed &#x3D; Math.random() * 1 + fallSpeed; &#x2F;* 坠落速度 *&#x2F; this.fallSpeed &#x3D; fallSpeed; &#x2F;* 坠落速度 *&#x2F; this.velY &#x3D; this.speed; &#x2F;* Y方向速度 *&#x2F; this.velX &#x3D; 0; &#x2F;* X方向速度 *&#x2F; this.stepSize &#x3D; Math.random() &#x2F; 30; &#x2F;* 步长 *&#x2F; this.step &#x3D; 0 &#x2F;* 步数 *&#x2F;&#125;flakeMove.prototype.update &#x3D; function() &#123; var x &#x3D; this.x, y &#x3D; this.y; &#x2F;* 左右摆动(余弦) *&#x2F; this.velX *&#x3D; 0.98; if (this.velY &lt;&#x3D; this.speed) &#123; this.velY &#x3D; this.speed &#125; this.velX +&#x3D; Math.cos(this.step +&#x3D; .05) * this.stepSize; this.y +&#x3D; this.velY; this.x +&#x3D; this.velX; &#x2F;* 飞出边界的处理 *&#x2F; if (this.x &gt;&#x3D; canvas.width || this.x &lt;&#x3D; 0 || this.y &gt;&#x3D; canvas.height || this.y &lt;&#x3D; 0) &#123; this.reset(canvas.width, canvas.height) &#125;&#125;;&#x2F;* 飞出边界-放置最顶端继续坠落 *&#x2F;flakeMove.prototype.reset &#x3D; function(width, height) &#123; this.x &#x3D; Math.floor(Math.random() * width); this.y &#x3D; 0; this.size &#x3D; Math.random() * this.maxSize + 2; this.speed &#x3D; Math.random() * 1 + this.fallSpeed; this.velY &#x3D; this.speed; this.velX &#x3D; 0;&#125;;&#x2F;&#x2F; 渲染雪花-随机形状（此处可修改雪花颜色！！！）flakeMove.prototype.render &#x3D; function(ctx) &#123; var snowFlake &#x3D; ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size); snowFlake.addColorStop(0, &quot;rgba(255, 255, 255, 0.9)&quot;); &#x2F;* 此处是雪花颜色，默认是白色 *&#x2F; snowFlake.addColorStop(.5, &quot;rgba(255, 255, 255, 0.5)&quot;); &#x2F;* 若要改为其他颜色，请自行查 *&#x2F; snowFlake.addColorStop(1, &quot;rgba(255, 255, 255, 0)&quot;); &#x2F;* 找16进制的RGB 颜色代码。 *&#x2F; ctx.save(); ctx.fillStyle &#x3D; snowFlake; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); ctx.restore();&#125;;&#x2F;* 创建雪花-定义形状 *&#x2F;function createFlakes() &#123; var maxFlake &#x3D; this.maxFlake, flakes &#x3D; this.flakes &#x3D; [], canvas &#x3D; this.canvas; for (var i &#x3D; 0; i &lt; maxFlake; i++) &#123; flakes.push(new flakeMove(canvas.width, canvas.height, this.flakeSize, this.fallSpeed)) &#125;&#125;&#x2F;* 画雪 *&#x2F;function drawSnow() &#123; var maxFlake &#x3D; this.maxFlake, flakes &#x3D; this.flakes; ctx &#x3D; this.ctx, canvas &#x3D; this.canvas, that &#x3D; this; &#x2F;* 清空雪花 *&#x2F; ctx.clearRect(0, 0, canvas.width, canvas.height); for (var e &#x3D; 0; e &lt; maxFlake; e++) &#123; flakes[e].update(); flakes[e].render(ctx); &#125; &#x2F;* 一帧一帧的画 *&#x2F; this.loop &#x3D; requestAnimationFrame(function() &#123; drawSnow.apply(that); &#125;);&#125;&#x2F;* 调用及控制方法 *&#x2F;var snow &#x3D; new snowFall(&#123;maxFlake:60&#125;);snow.start(); 然后在 \\Hexo\\themes\\hexo-theme-spfk\\layout\\layout.ejs 文件里引用即可： 12复制&lt;!-- 雪花特效 --&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;\\js\\snow.js&quot;&gt;&lt;&#x2F;script&gt; 如果没效果，请确认网页是否已载入JQurey，如果没有请在下雪代码之前引入JQ即可： 12复制&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;http:&#x2F;&#x2F;libs.baidu.com&#x2F;jquery&#x2F;1.8.3&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;http:&#x2F;&#x2F;libs.baidu.com&#x2F;jquery&#x2F;1.8.3&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt; 原文链接：《分享两种圣诞节雪花特效JS代码(网站下雪效果)》 【17】添加 Fork me on GitHub 效果效果图： 点击此处可以查看更多样式，将相应样式的代码复制到你想要放的地方就OK了，代码里的链接也要替换成你的，更多创意，比如 Follow me on CSDN ，只需要用PS改掉图片里的文字，替换掉相应链接即可 【18】添加背景动态彩带效果样式一是鼠标点击后彩带自动更换样式，样式二是飘动的彩带： 实现方法：在 \\themes\\material-x\\layout\\layout.ejs 文件的body前面添加如下代码： 1234复制&lt;!-- 样式一（鼠标点击更换样式） --&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;g.joyinshare.com&#x2F;hc&#x2F;ribbon.min.js&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&lt;&#x2F;script&gt;复制&lt;!-- 样式二（飘动的彩带） --&gt;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;g.joyinshare.com&#x2F;hc&#x2F;piao.js&quot; type&#x3D;&quot;text&#x2F;javascript&quot;&gt;&lt;&#x2F;script&gt; 【19】添加背景代码雨特效新建 DigitalRain.js，写入以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657复制window.onload &#x3D; function()&#123; &#x2F;&#x2F;获取画布对象 var canvas &#x3D; document.getElementById(&quot;canvas&quot;); &#x2F;&#x2F;获取画布的上下文 var context &#x3D;canvas.getContext(&quot;2d&quot;); var s &#x3D; window.screen; var W &#x3D; canvas.width &#x3D; s.width; var H &#x3D; canvas.height; &#x2F;&#x2F;获取浏览器屏幕的宽度和高度 &#x2F;&#x2F;var W &#x3D; window.innerWidth; &#x2F;&#x2F;var H &#x3D; window.innerHeight; &#x2F;&#x2F;设置canvas的宽度和高度 canvas.width &#x3D; W; canvas.height &#x3D; H; &#x2F;&#x2F;每个文字的字体大小 var fontSize &#x3D; 12; &#x2F;&#x2F;计算列 var colunms &#x3D; Math.floor(W &#x2F;fontSize); &#x2F;&#x2F;记录每列文字的y轴坐标 var drops &#x3D; []; &#x2F;&#x2F;给每一个文字初始化一个起始点的位置 for(var i&#x3D;0;i&lt;colunms;i++)&#123; drops.push(0); &#125; &#x2F;&#x2F;运动的文字 var str &#x3D;&quot;WELCOME TO WWW.ITRHX.COM&quot;; &#x2F;&#x2F;4:fillText(str,x,y);原理就是去更改y的坐标位置 &#x2F;&#x2F;绘画的函数 function draw()&#123; context.fillStyle &#x3D; &quot;rgba(238,238,238,.08)&quot;;&#x2F;&#x2F;遮盖层 context.fillRect(0,0,W,H); &#x2F;&#x2F;给字体设置样式 context.font &#x3D; &quot;600 &quot;+fontSize+&quot;px Georgia&quot;; &#x2F;&#x2F;给字体添加颜色 context.fillStyle &#x3D; [&quot;#33B5E5&quot;, &quot;#0099CC&quot;, &quot;#AA66CC&quot;, &quot;#9933CC&quot;, &quot;#99CC00&quot;, &quot;#669900&quot;, &quot;#FFBB33&quot;, &quot;#FF8800&quot;, &quot;#FF4444&quot;, &quot;#CC0000&quot;][parseInt(Math.random() * 10)];&#x2F;&#x2F;randColor();可以rgb,hsl, 标准色，十六进制颜色 &#x2F;&#x2F;写入画布中 for(var i&#x3D;0;i&lt;colunms;i++)&#123; var index &#x3D; Math.floor(Math.random() * str.length); var x &#x3D; i*fontSize; var y &#x3D; drops[i] *fontSize; context.fillText(str[index],x,y); &#x2F;&#x2F;如果要改变时间，肯定就是改变每次他的起点 if(y &gt;&#x3D; canvas.height &amp;&amp; Math.random() &gt; 0.99)&#123; drops[i] &#x3D; 0; &#125; drops[i]++; &#125; &#125;; function randColor()&#123;&#x2F;&#x2F;随机颜色 var r &#x3D; Math.floor(Math.random() * 256); var g &#x3D; Math.floor(Math.random() * 256); var b &#x3D; Math.floor(Math.random() * 256); return &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot;; &#125; draw(); setInterval(draw,35);&#125;; 在主题文件的相关css文件中（以 Material X 1.2.1 主题为例，在\\themes\\material-x-1.2.1\\source\\less_main.less 文件末尾）添加以下代码： 12345678910复制canvas &#123; position: fixed; right: 0px; bottom: 0px; min-width: 100%; min-height: 100%; height: auto; width: auto; z-index: -1;&#125; 然后在主题的 layout.ejs 文件中引入即可： 123复制&lt;!-- 数字雨 --&gt;&lt;canvas id&#x3D;&quot;canvas&quot; width&#x3D;&quot;1440&quot; height&#x3D;&quot;900&quot; &gt;&lt;&#x2F;canvas&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot; src&#x3D;&quot;&#x2F;js&#x2F;DigitalRain.js&quot;&gt;&lt;&#x2F;script&gt; 最终效果： 代码来源：http://www.lxl8800.cn/Main/Resource 【20】自定义一个不使用主题模板渲染的独立页面 有时候我们需要新建一个独立的页面，这个页面不使用主题的渲染，具有自己独立的样式，可以放一些自己的作品，相册什么的，以下就介绍这种独立页面的实现方法。 方法一： 使用 Hexo 提供的跳过渲染配置，在博客根目录的配置文件 _config.yml 里找到 skip_render 关键字，在后面添加想要跳过渲染的页面，比如我们创建 \\source\\about\\index.html， 配置文件填写：skip_render: about\\**，那么就表示 \\source\\about 里所有的文件将跳过渲染，里面的文件将会被直接复制到 public 文件夹，此时就会得到一个独立的 about 页面；官方文档：https://hexo.io/docs/configuration 方法二： 在文章头部的 Front-matter 里添加配置 layout: false 来跳过渲染配置，比如我们要使 about 页面跳过渲染，创建 \\source\\about\\index.md，将这个页面的相关 HTML 代码写进.md文件并保存，然后在 index.md 的头部写入： 123456789复制---layout: false---&#123;% raw %&#125;这里是 HTML 代码&#123;% endraw %&#125; PS：Front-matter 是 .md 文件最上方以 — 分隔的区域，用于指定个别文件的变量，官方文档：https://hexo.io/docs/front-matter 效果可以对比我的博客主页和关于页面 【21】更改本地预览端口号hexo博客在执行 hexo s 进行本地预览的时候，默认端口号是4000，当该端口号被占用时会报错 Error: listen EADDRINUSE 0.0.0.0:4000 ，此时可以关闭占用该端口的进程，也可以更换端口号，更换端口号可以通过以下两种方法实现： 方法一：在根目录的 _config.yml 配置文件内加上如下代码更改 hexo s 运行时的端口号： 1234复制server: port: 5000 compress: true header: true 方法二：通过 hexo server -p 5000 命令来指定端口，这种方法只是本次执行有效 未完待续……","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Python 爬虫大小项目集合","slug":"Python-爬虫大小项目集合","date":"2020-06-13T12:00:54.000Z","updated":"2020-06-13T12:01:44.780Z","comments":true,"path":"2020/06/13/Python-爬虫大小项目集合/","link":"","permalink":"http://yoursite.com/2020/06/13/Python-%E7%88%AC%E8%99%AB%E5%A4%A7%E5%B0%8F%E9%A1%B9%E7%9B%AE%E9%9B%86%E5%90%88/","excerpt":"","text":"今天为大家带来了自己的爬虫代码集，主要是以往学习Python爬虫过程中写过的大小项目，可能不是很全面，但是持续在更新，那我的代码里有什么？ 1. Cnblogs - 博客园爬虫 使用Urllib库实现博客园”最新文章”的爬取，可以自行扩展为全站爬虫，但是要注意它的接口。 2. Golory_of_Kings - 王者荣耀爬虫 通过王者荣耀官网的英雄列表接口以及英雄皮肤的下载URL，完成对王者荣耀英雄全皮肤的下载。 3.MaoYan_Top100 - 猫眼TOP100爬虫 （见名知意）爬取猫眼TOP排行榜前100的电影信息。 4.Moments - 朋友圈爬虫 基于自动化测试工具Appium的微信朋友圈爬虫，模拟登录、抓取动态、保存数据。 5.Bilibili - B站爬虫 模拟登录B站并识别滑动验证码。破解滑动验证码的思路主要沿袭崔大破解极验的思路，登录、获取验证码Image对象、打码平台识别、本地转化识别结果、Selenium模拟滑动等。 6.DouYin - 抖音爬虫 基于Mitmdump的抖音短视频爬取，包括视频名称、作者名称、获赞数、转发量等重要信息的获取。 7.Crack_Jianshu - 简书爬虫 为了照顾简书，完成了简书的模拟登录并识别简书的点触式验证码，破解验证码的思路基本与滑动验证码相同。 8.Selenium_163 - 网易163邮箱爬虫 模拟登录网易163邮箱，并发送SOS邮件。主要是为了对iframe子节点的训练。 9.City_58 - 58房屋信息爬虫 使用Scrapy框架爬取58同城的出租房信息，并包含下级网页数据的爬虫，项目难度较大，可根据能力练习。 10.Selenium_Cnki - 知网爬虫 模拟登录注册知网，识别知网的普通数字英文混合验证码。别小看这简单的验证码，可是用tesserocr等Python识别库搞不定的。 其他的可以看截图： 我是爬虫小白，代码中如果有写的什么不好的地方，可以提交issue。最后，贴出我的Github仓库地址：https://github.com/Northxw/Python3_WebSpider，欢迎各种**star**和**fork**，一起学爬虫。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python 爬虫（二）","slug":"Python-爬虫（二）","date":"2020-06-13T11:59:47.000Z","updated":"2020-06-13T12:00:24.194Z","comments":true,"path":"2020/06/13/Python-爬虫（二）/","link":"","permalink":"http://yoursite.com/2020/06/13/Python-%E7%88%AC%E8%99%AB%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"Github代码获取：https://github.com/Jack-Cherish/python-spiderPython版本： Python3.x运行平台： WindowsIDE： Sublime text3 更多教程，请查看：https://cuijiahua.com/blog/spider/一 前言强烈建议：请在电脑的陪同下，阅读本文。本文以实战为主，阅读过程如稍有不适，还望多加练习。本文的实战内容有： 网络小说下载(静态网站) 优美壁纸下载(动态网站) 视频下载 2020年，更多精彩内容，尽在微信公众号，欢迎您的关注： 二 网络爬虫简介网络爬虫，也叫网络蜘蛛(Web Spider)。它根据网页地址(URL)爬取网页内容，而网页地址(URL)就是我们在浏览器中输入的网站链接。比如：https://www.baidu.com/，它就是一个URL。 在讲解爬虫内容之前，我们需要先学习一项写爬虫的必备技能：审查元素（如果已掌握，可跳过此部分内容）。 1 审查元素在浏览器的地址栏输入URL地址，在网页处右键单击，找到检查。(不同浏览器的叫法不同，Chrome浏览器叫做检查，Firefox浏览器叫做查看元素，但是功能都是相同的) 我们可以看到，右侧出现了一大推代码，这些代码就叫做HTML。什么是HTML？举个容易理解的例子：我们的基因决定了我们的原始容貌，服务器返回的HTML决定了网站的原始容貌。 为啥说是原始容貌呢？因为人可以整容啊！扎心了，有木有？那网站也可以”整容”吗？可以！请看下图： 我能有这么多钱吗？显然不可能。我是怎么给网站”整容”的呢？就是通过修改服务器返回的HTML信息。我们每个人都是”整容大师”，可以修改页面信息。我们在页面的哪个位置点击审查元素，浏览器就会为我们定位到相应的HTML位置，进而就可以在本地更改HTML信息。 再举个小例子：我们都知道，使用浏览器”记住密码”的功能，密码会变成一堆小黑点，是不可见的。可以让密码显示出来吗？可以，只需给页面”动个小手术”！以淘宝为例，在输入密码框处右键，点击检查。 可以看到，浏览器为我们自动定位到了相应的HTML位置。将下图中的password属性值改为text属性值(直接在右侧代码处修改)： 我们让浏览器记住的密码就这样显现出来了： 说这么多，什么意思呢？浏览器就是作为客户端从服务器端获取信息，然后将信息解析，并展示给我们的。我们可以在本地修改HTML信息，为网页”整容”，但是我们修改的信息不会回传到服务器，服务器存储的HTML信息不会改变。刷新一下界面，页面还会回到原本的样子。这就跟人整容一样，我们能改变一些表面的东西，但是不能改变我们的基因。 2 简单实例网络爬虫的第一步就是根据URL，获取网页的HTML信息。\\在Python3中，可以使用*urllib.request*和requests进行网页爬取。 urllib库是python内置的，无需我们额外安装，只要安装了Python就可以使用这个库。 requests库是第三方库，需要我们自己安装。 requests库强大好用，所以本文使用requests库获取网页的HTML信息。requests库的github地址：https://github.com/requests/requests (1) requests安装在cmd中，使用如下指令安装requests： 12pip install requests1 或者： 12easy_install requests1 (2) 简单实例requests库的基础方法如下： 官方中文教程地址：http://docs.python-requests.org/zh_CN/latest/user/quickstart.html requests库的开发者为我们提供了详细的中文教程，查询起来很方便。本文不会对其所有内容进行讲解，摘取其部分使用到的内容，进行实战说明。 首先，让我们看下requests.get()方法，它用于向服务器发起GET请求，不了解GET请求没有关系。我们可以这样理解：get的中文意思是得到、抓住，那这个requests.get()方法就是从服务器得到、抓住数据，也就是获取数据。让我们看一个例子(以 www.gitbook.cn为例)来加深理解： 12345678# -*- coding:UTF-8 -*-import requestsif __name__ &#x3D;&#x3D; &#39;__main__&#39;: target &#x3D; &#39;http:&#x2F;&#x2F;gitbook.cn&#x2F;&#39; req &#x3D; requests.get(url&#x3D;target) print(req.text)1234567 requests.get()方法必须设置的一个参数就是url，因为我们得告诉GET请求，我们的目标是谁，我们要获取谁的信息。运行程序看下结果： 左侧是我们程序获得的结果，右侧是我们在www.gitbook.cn网站审查元素获得的信息。我们可以看到，我们已经顺利获得了该网页的HTML信息。这就是一个最简单的爬虫实例，可能你会问，我只是爬取了这个网页的HTML信息，有什么用呢？客官稍安勿躁，接下来进入我们的实战正文。 三 爬虫实战1 小说下载(1) 实战背景小说网站-笔趣看：URL：http://www.biqukan.com/ 本次实战就是从该网站爬取并保存一本名为《一念永恒》的小说。 (2) 小试牛刀我们先看下《一念永恒》小说的第一章内容，URL：http://www.biqukan.com/1_1094/5403177.html 我们先用已经学到的知识获取HTML信息试一试，编写代码如下： 12345678# -*- coding:UTF-8 -*-import requestsif __name__ &#x3D;&#x3D; &#39;__main__&#39;: target &#x3D; &#39;http:&#x2F;&#x2F;www.biqukan.com&#x2F;1_1094&#x2F;5403177.html&#39; req &#x3D; requests.get(url&#x3D;target) print(req.text)1234567 运行代码，可以看到如下结果： 可以看到，我们很轻松地获取了HTML信息。但是，很显然，很多信息是我们不想看到的，我们只想获得如右侧所示的正文内容，我们不关心div、br这些html标签。如何把正文内容从这些众多的html标签中提取出来呢？这就是本次实战的主要内容。 ###（3）Beautiful Soup 爬虫的第一步，获取整个网页的HTML信息，我们已经完成。接下来就是爬虫的第二步，解析HTML信息，提取我们感兴趣的内容。对于本小节的实战，我们感兴趣的内容就是文章的正文。提取的方法有很多，例如使用正则表达式、Xpath、Beautiful Soup等。对于初学者而言，最容易理解，并且使用简单的方法就是使用Beautiful Soup提取感兴趣内容。 Beautiful Soup的安装方法和requests一样，使用如下指令安装(也是二选一)： pip install beautifulsoup4 easy_install beautifulsoup4 一个强大的第三方库，都会有一个详细的官方文档。我们很幸运，Beautiful Soup也是有中文的官方文档。 URL：http://beautifulsoup.readthedocs.io/zh_CN/latest/ 同理，我会根据实战需求，讲解Beautiful Soup库的部分使用方法，更详细的内容，请查看官方文档。 现在，我们使用已经掌握的审查元素方法，查看一下我们的目标页面，你会看到如下内容： 不难发现，文章的所有内容都放在了一个名为div的“东西下面”，这个”东西”就是html标签。HTML标签是HTML语言中最基本的单位，HTML标签是HTML最重要的组成部分。不理解，没关系，我们再举个简单的例子： 一个女人的包包里，会有很多东西，她们会根据自己的习惯将自己的东西进行分类放好。镜子和口红这些会经常用到的东西，会归放到容易拿到的外侧口袋里。那些不经常用到，需要注意安全存放的证件会放到不容易拿到的里侧口袋里。 html标签就像一个个“口袋”，每个“口袋”都有自己的特定功能，负责存放不同的内容。显然，上述例子中的div标签下存放了我们关心的正文内容。这个div标签是这样的： 12&lt;div id&#x3D;&quot;content&quot;, class&#x3D;&quot;showtxt&quot;&gt;1 细心的朋友可能已经发现，除了div字样外，还有id和class。id和class就是div标签的属性，content和showtxt是属性值，一个属性对应一个属性值。这东西有什么用？它是用来区分不同的div标签的，因为div标签可以有很多，我们怎么加以区分不同的div标签呢？就是通过不同的属性值。 仔细观察目标网站一番，我们会发现这样一个事实：class属性为showtxt的div标签，独一份！这个标签里面存放的内容，是我们关心的正文部分。 知道这个信息，我们就可以使用Beautiful Soup提取我们想要的内容了，编写代码如下： 12345678910# -*- coding:UTF-8 -*-from bs4 import BeautifulSoupimport requestsif __name__ &#x3D;&#x3D; &quot;__main__&quot;: target &#x3D; &#39;http:&#x2F;&#x2F;www.biqukan.com&#x2F;1_1094&#x2F;5403177.html&#39; req &#x3D; requests.get(url &#x3D; target) html &#x3D; req.text bf &#x3D; BeautifulSoup(html) texts &#x3D; bf.find_all(&#39;div&#39;, class_ &#x3D; &#39;showtxt&#39;) print(texts)123456789 在解析html之前，我们需要创建一个Beautiful Soup对象。BeautifulSoup函数里的参数就是我们已经获得的html信息。然后我们使用find_all方法，获得html信息中所有class属性为showtxt的div标签。find_all方法的第一个参数是获取的标签名，第二个参数class_是标签的属性，为什么不是class，而带了一个下划线呢？因为python中class是关键字，为了防止冲突，这里使用class_表示标签的class属性，class_后面跟着的showtxt就是属性值了。看下我们要匹配的标签格式： 12&lt;div id&#x3D;&quot;content&quot;, class&#x3D;&quot;showtxt&quot;&gt;1 这样对应的看一下，是不是就懂了？可能有人会问了，为什么不是find_all(‘div’, id = ‘content’, class_ = ‘showtxt’)?这样其实也是可以的，属性是作为查询时候的约束条件，添加一个class_=’showtxt’条件，我们就已经能够准确匹配到我们想要的标签了，所以我们就不必再添加id这个属性了。运行代码查看我们匹配的结果： 我们可以看到，我们已经顺利匹配到我们关心的正文内容，但是还有一些我们不想要的东西。比如div标签名，br标签，以及各种空格。怎么去除这些东西呢？我们继续编写代码： 12345678910# -*- coding:UTF-8 -*-from bs4 import BeautifulSoupimport requestsif __name__ &#x3D;&#x3D; &quot;__main__&quot;: target &#x3D; &#39;http:&#x2F;&#x2F;www.biqukan.com&#x2F;1_1094&#x2F;5403177.html&#39; req &#x3D; requests.get(url &#x3D; target) html &#x3D; req.text bf &#x3D; BeautifulSoup(html) texts &#x3D; bf.find_all(&#39;div&#39;, class_ &#x3D; &#39;showtxt&#39;) print(texts[0].text.replace(&#39;\\xa0&#39;*8,&#39;\\n\\n&#39;))123456789 find_all匹配的返回的结果是一个列表。提取匹配结果后，使用text属性，提取文本内容，滤除br标签。随后使用replace方法，剔除空格，替换为回车进行分段。 在html中是用来表示空格的。replace(’\\xa0’*8,’\\n\\n’)就是去掉下图的八个空格符号，并用回车代替： 程序运行结果如下： 可以看到，我们很自然的匹配到了所有正文内容，并进行了分段。我们已经顺利获得了一个章节的内容，要想下载正本小说，我们就要获取每个章节的链接。我们先分析下小说目录： URL：http://www.biqukan.com/1_1094/ 通过审查元素，我们发现可以发现，这些章节都存放在了class属性为listmain的div标签下，选取部分html代码如下： 12345678910111213141516171819202122&lt;div class&#x3D;&quot;listmain&quot;&gt;&lt;dl&gt;&lt;dt&gt;《一念永恒》最新章节列表&lt;&#x2F;dt&gt;&lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;15932394.html&quot;&gt;第1027章 第十道门&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;15923072.html&quot;&gt;第1026章 绝伦道法！&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;15921862.html&quot;&gt;第1025章 长生灯！&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;15918591.html&quot;&gt;第1024章 一目晶渊&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;15906236.html&quot;&gt;第1023章 通天道门&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;15903775.html&quot;&gt;第1022章 四大凶兽！&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;15890427.html&quot;&gt;第1021章 鳄首！&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;15886627.html&quot;&gt;第1020章 一触即发！&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;15875306.html&quot;&gt;第1019章 魁祖的气息！&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;15871572.html&quot;&gt;第1018章 绝望的魁皇城&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;15859514.html&quot;&gt;第1017章 我还是恨你！&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;15856137.html&quot;&gt;第1016章 从来没有世界之门！&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;dt&gt;《一念永恒》正文卷&lt;&#x2F;dt&gt; &lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;5386269.html&quot;&gt;外传1 柯父。&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;5386270.html&quot;&gt;外传2 楚玉嫣。&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt; &lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;5386271.html&quot;&gt;外传3 鹦鹉与皮冻。&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;5403177.html&quot;&gt;第一章 他叫白小纯&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt; &lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;5428081.html&quot;&gt;第二章 火灶房&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;5433843.html&quot;&gt;第三章 六句真言&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt; &lt;dd&gt;&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;5447905.html&quot;&gt;第四章 炼灵&lt;&#x2F;a&gt;&lt;&#x2F;dd&gt;&lt;&#x2F;dl&gt;&lt;&#x2F;div&gt;123456789101112131415161718192021 在分析之前，让我们先介绍一个概念：父节点、子节点、孙节点。&lt;div&gt;和&lt;/div&gt;限定了&lt;div&gt;标签的开始和结束的位置，他们是成对出现的，有开始位置，就有结束位置。我们可以看到，在&lt;div&gt;标签包含&lt;dl&gt;标签，那这个&lt;dl&gt;标签就是&lt;div&gt;标签的子节点，&lt;dl&gt;标签又包含&lt;dt&gt;标签和&lt;dd&gt;标签，那么&lt;dt&gt;标签和&lt;dd&gt;标签就是&lt;div&gt;标签的孙节点。有点绕？那你记住这句话：谁包含谁，谁就是谁儿子！ 他们之间的关系都是相对的。比如对于&lt;dd&gt;标签，它的子节点是&lt;a&gt;标签，它的父节点是&lt;dl&gt;标签。这跟我们人是一样的，上有老下有小。 看到这里可能有人会问，这有好多&lt;dd&gt;标签和&lt;a&gt;标签啊！不同的&lt;dd&gt;标签，它们是什么关系啊？显然，兄弟姐妹喽！我们称它们为兄弟结点。好了，概念明确清楚，接下来，让我们分析一下问题。我们看到每个章节的名字存放在了&lt;a&gt;标签里面。&lt;a&gt;标签还有一个href属性。这里就不得不提一下&lt;a&gt;标签的定义了，&lt;a&gt;标签定义了一个超链接，用于从一张页面链接到另一张页面。&lt;a&gt; 标签最重要的属性是 href 属性，它指示链接的目标。 我们将之前获得的第一章节的URL和&lt;a&gt; 标签对比看一下： 123http:&#x2F;&#x2F;www.biqukan.com&#x2F;1_1094&#x2F;5403177.html&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;5403177.html&quot;&gt;第一章 他叫白小纯&lt;&#x2F;a&gt;12 不难发现，&lt;a&gt; 标签中href属性存放的属性值/1_1094/5403177.html是章节URLhttp://www.biqukan.com/1_1094/5403177.html的后半部分。其他章节也是如此！那这样，我们就可以根据``标签的href属性值获得每个章节的链接和名称了。 总结一下：小说每章的链接放在了class属性为listmain的&lt;div&gt;标签下的&lt;a&gt;标签中。链接具体位置放在html-&gt;body-&gt;div-&gt;dl-&gt;dd-&gt;a的href属性中。先匹配class属性为listmain的&lt;div&gt;标签，再匹配&lt;a&gt;标签。编写代码如下： 1234567891011# -*- coding:UTF-8 -*-from bs4 import BeautifulSoupimport requestsif __name__ &#x3D;&#x3D; &quot;__main__&quot;: target &#x3D; &#39;http:&#x2F;&#x2F;www.biqukan.com&#x2F;1_1094&#x2F;&#39; req &#x3D; requests.get(url &#x3D; target) html &#x3D; req.text div_bf &#x3D; BeautifulSoup(html) div &#x3D; div_bf.find_all(&#39;div&#39;, class_ &#x3D; &#39;listmain&#39;) print(div[0])12345678910 还是使用find_all方法，运行结果如下： 很顺利，接下来再匹配每一个&lt;a&gt;标签，并提取章节名和章节文章。如果我们使用Beautiful Soup匹配到了下面这个&lt;a&gt;标签，如何提取它的href属性和&lt;a&gt;标签里存放的章节名呢？ 12&lt;a href&#x3D;&quot;&#x2F;1_1094&#x2F;5403177.html&quot;&gt;第一章 他叫白小纯&lt;&#x2F;a&gt;1 方法很简单，对Beautiful Soup返回的匹配结果a，使用a.get(‘href’)方法就能获取href的属性值，使用a.string就能获取章节名，编写代码如下： 1234567891011121314# -*- coding:UTF-8 -*-from bs4 import BeautifulSoupimport requestsif __name__ &#x3D;&#x3D; &quot;__main__&quot;: server &#x3D; &#39;http:&#x2F;&#x2F;www.biqukan.com&#x2F;&#39; target &#x3D; &#39;http:&#x2F;&#x2F;www.biqukan.com&#x2F;1_1094&#x2F;&#39; req &#x3D; requests.get(url &#x3D; target) html &#x3D; req.text div_bf &#x3D; BeautifulSoup(html) div &#x3D; div_bf.find_all(&#39;div&#39;, class_ &#x3D; &#39;listmain&#39;) a_bf &#x3D; BeautifulSoup(str(div[0])) a &#x3D; a_bf.find_all(&#39;a&#39;) for each in a: print(each.string, server + each.get(&#39;href&#39;))12345678910111213 因为find_all返回的是一个列表，里边存放了很多的&lt;a&gt;标签，所以使用for循环遍历每个&lt;a&gt;标签并打印出来，运行结果如下。 最上面匹配的一千多章的内容是最新更新的12章节的链接。这12章内容会和下面的重复，所以我们要滤除，除此之外，还有那3个外传，我们也不想要。这些都简单地剔除就好。 ###（3）整合代码 每个章节的链接、章节名、章节内容都有了。接下来就是整合代码，将获得内容写入文本文件存储就好了。编写代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788# -*- coding:UTF-8 -*-from bs4 import BeautifulSoupimport requests, sys&quot;&quot;&quot;类说明:下载《笔趣看》网小说《一念永恒》Parameters: 无Returns: 无Modify: 2017-09-13&quot;&quot;&quot;class downloader(object): def __init__(self): self.server &#x3D; &#39;http:&#x2F;&#x2F;www.biqukan.com&#x2F;&#39; self.target &#x3D; &#39;http:&#x2F;&#x2F;www.biqukan.com&#x2F;1_1094&#x2F;&#39; self.names &#x3D; [] #存放章节名 self.urls &#x3D; [] #存放章节链接 self.nums &#x3D; 0 #章节数 &quot;&quot;&quot; 函数说明:获取下载链接 Parameters: 无 Returns: 无 Modify: 2017-09-13 &quot;&quot;&quot; def get_download_url(self): req &#x3D; requests.get(url &#x3D; self.target) html &#x3D; req.text div_bf &#x3D; BeautifulSoup(html) div &#x3D; div_bf.find_all(&#39;div&#39;, class_ &#x3D; &#39;listmain&#39;) a_bf &#x3D; BeautifulSoup(str(div[0])) a &#x3D; a_bf.find_all(&#39;a&#39;) self.nums &#x3D; len(a[15:]) #剔除不必要的章节，并统计章节数 for each in a[15:]: self.names.append(each.string) self.urls.append(self.server + each.get(&#39;href&#39;)) &quot;&quot;&quot; 函数说明:获取章节内容 Parameters: target - 下载连接(string) Returns: texts - 章节内容(string) Modify: 2017-09-13 &quot;&quot;&quot; def get_contents(self, target): req &#x3D; requests.get(url &#x3D; target) html &#x3D; req.text bf &#x3D; BeautifulSoup(html) texts &#x3D; bf.find_all(&#39;div&#39;, class_ &#x3D; &#39;showtxt&#39;) texts &#x3D; texts[0].text.replace(&#39;\\xa0&#39;*8,&#39;\\n\\n&#39;) return texts &quot;&quot;&quot; 函数说明:将爬取的文章内容写入文件 Parameters: name - 章节名称(string) path - 当前路径下,小说保存名称(string) text - 章节内容(string) Returns: 无 Modify: 2017-09-13 &quot;&quot;&quot; def writer(self, name, path, text): write_flag &#x3D; True with open(path, &#39;a&#39;, encoding&#x3D;&#39;utf-8&#39;) as f: f.write(name + &#39;\\n&#39;) f.writelines(text) f.write(&#39;\\n\\n&#39;)if __name__ &#x3D;&#x3D; &quot;__main__&quot;: dl &#x3D; downloader() dl.get_download_url() print(&#39;《一年永恒》开始下载：&#39;) for i in range(dl.nums): dl.writer(dl.names[i], &#39;一念永恒.txt&#39;, dl.get_contents(dl.urls[i])) sys.stdout.write(&quot; 已下载:%.3f%%&quot; % float(i&#x2F;dl.nums) + &#39;\\r&#39;) sys.stdout.flush() print(&#39;《一年永恒》下载完成&#39;)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 很简单的程序，单进程跑，没有开进程池。下载速度略慢，喝杯茶休息休息吧。代码运行效果如下图所示： 2 优美壁纸下载###（1）实战背景 已经会爬取文字了，是不是感觉爬虫还是蛮好玩的呢？接下来，让我们进行一个进阶实战，了解一下反爬虫。 URL：https://unsplash.com/ 看一看这些优美的壁纸，这个网站的名字叫做Unsplash，免费高清壁纸分享网是一个坚持每天分享高清的摄影图片的站点，每天更新一张高质量的图片素材，全是生活中的景象作品，清新的生活气息图片可以作为桌面壁纸也可以应用于各种需要的环境。 看到这么优美的图片，我的第一反应就是想收藏一些，作为知乎文章的题图再好不过了。每张图片我都很喜欢，批量下载吧，不多爬，就下载50张好了。 ###（2）实战进阶 我们已经知道了每个html标签都有各自的功能。&lt;a&gt;标签存放一下超链接，图片存放在哪个标签里呢？html规定，图片统统给我放到&lt;img&gt;标签中！既然这样，我们截取就Unsplash网站中的一个&lt;img&gt;标签，分析一下： 12&lt;img alt&#x3D;&quot;Snow-capped mountain slopes under blue sky&quot; src&#x3D;&quot;https:&#x2F;&#x2F;images.unsplash.com&#x2F;photo-1428509774491-cfac96e12253?dpr&#x3D;1&amp;auto&#x3D;compress,format&amp;fit&#x3D;crop&amp;w&#x3D;360&amp;h&#x3D;240&amp;q&#x3D;80&amp;cs&#x3D;tinysrgb&amp;crop&#x3D;&quot; class&#x3D;&quot;cV68d&quot; style&#x3D;&quot;width: 220px; height: 147px;&quot;&gt;1 可以看到，&lt;img&gt;标签有很多属性，有alt、src、class、style属性，其中src属性存放的就是我们需要的图片保存地址，我们根据这个地址就可以进行图片的下载。 那么，让我们先捋一捋这个过程： 使用requeusts获取整个网页的HTML信息； 使用Beautiful Soup解析HTML信息，找到所有&lt;img&gt;标签，提取src属性，获取图片存放地址； 根据图片存放地址，下载图片。 我们信心满满地按照这个思路爬取Unsplash试一试，编写代码如下： 1234567# -*- coding:UTF-8 -*-import requestsif __name__ &#x3D;&#x3D; &#39;__main__&#39;: target &#x3D; &#39;https:&#x2F;&#x2F;unsplash.com&#x2F;&#39; req &#x3D; requests.get(url&#x3D;target) print(req.text)123456 按照我们的设想，我们应该能找到很多&lt;img&gt;标签。但是我们发现，除了一些&lt;script&gt;标签和一些看不懂的代码之外，我们一无所获，一个&lt;img&gt;标签都没有！跟我们在网站审查元素的结果完全不一样，这是为什么？ 答案就是，这个网站的所有图片都是动态加载的！网站有静态网站和动态网站之分，上一个实战爬取的网站是静态网站，而这个网站是动态网站，动态加载有一部分的目的就是为了反爬虫。 对于什么是动态加载，你可以这样理解：我们知道化妆术学的好，贼厉害，可以改变一个人的容貌。相应的，动态加载用的好，也贼厉害，可以改变一个网站的容貌。 动态网站使用动态加载常用的手段就是通过调用JavaScript来实现的。怎么实现JavaScript动态加载，我们不必深究，我们只要知道，动态加载的JavaScript脚本，就像化妆术需要用的化妆品，五花八门。有粉底、口红、睫毛膏等等，它们都有各自的用途。动态加载的JavaScript脚本也一样，一个动态加载的网站可能使用很多JavaScript脚本，我们只要找到负责动态加载图片的JavaScript脚本，不就找到我们需要的链接了吗？ 对于初学者，我们不必看懂JavaScript执行的内容是什么，做了哪些事情，因为我们有强大的抓包工具，它自然会帮我们分析。这个强大的抓包工具就是Fiddler： URL：http://www.telerik.com/fiddler PS：也可以使用浏览器自带的Networks，但是我更推荐这个软件，因为它操作起来更高效。 安装方法很简单，傻瓜式安装，一直下一步即可，对于经常使用电脑的人来说，应该没有任何难度。 这个软件的使用方法也很简单，打开软件，然后用浏览器打开我们的目标网站，以Unsplash为例，抓包结果如下： 我们可以看到，上图左侧红框处是我们的GET请求的地址，就是网站的URL，右下角是服务器返回的信息，我们可以看到，这些信息也是我们上一个程序获得的信息。这个不是我们需要的链接，我们继续往下看。 我们发现上图所示的就是一个JavaScript请求，看右下侧服务器返回的信息是一个json格式的数据。这里面，就有我们需要的内容。我们局部放大看一下： 这是Fiddler右侧的信息，上面是请求的Headers信息，包括这个Javascript的请求地 址：http://unsplash.com/napi/feeds/home，其他信息我们先不管，我们看看下面的内容。里面有很多图片的信息，包括图片的id，图片的大小，图片的链接，还有下一页的地址。这个脚本以json格式存储传输的数据，json格式是一种轻量级的数据交换格式，起到封装数据的作用，易于人阅读和编写，同时也易于机器解析和生成。这么多链接，可以看到图片的链接有很多，根据哪个链接下载图片呢？先别急，让我们继续分析： 在这个网站，我们可以按这个按钮进行图片下载。我们抓包分下下这个动作，看看发送了哪些请求。 1234https:&#x2F;&#x2F;unsplash.com&#x2F;photos&#x2F;1PrQ2mHW-Fo&#x2F;download?force&#x3D;truehttps:&#x2F;&#x2F;unsplash.com&#x2F;photos&#x2F;JX7nDtafBcU&#x2F;download?force&#x3D;truehttps:&#x2F;&#x2F;unsplash.com&#x2F;photos&#x2F;HCVbP3zqX4k&#x2F;download?force&#x3D;true123 通过Fiddler抓包，我们发现，点击不同图片的下载按钮，GET请求的地址都是不同的。但是它们很有规律，就是中间有一段代码是不一样的，其他地方都一样。中间那段代码是不是很熟悉？没错，它就是我们之前抓包分析得到json数据中的照片的id。我们只要解析出每个照片的id，就可以获得图片下载的请求地址，然后根据这个请求地址，我们就可以下载图片了。那么，现在的首要任务就是解析json数据了。 json格式的数据也是分层的。可以看到next_page里存放的是下一页的请求地址，很显然Unsplash下一页的内容，也是动态加载的。在photos下面的id里，存放着图片的id，这个就是我们需要获得的图片id号。 怎么编程提取这些json数据呢？我们也是分步完成： 获取整个json数据 解析json数据 编写代码，尝试获取json数据： 123456# -*- coding:UTF-8 -*-import requestsif __name__ &#x3D;&#x3D; &#39;__main__&#39;: target &#x3D; &#39;http:&#x2F;&#x2F;unsplash.com&#x2F;napi&#x2F;feeds&#x2F;home&#39; req &#x3D; requests.get(url&#x3D;target) print(req.text)12345 很遗憾，程序报错了，问题出在哪里？通过错误信息，我们可以看到SSL认证错误，SSL认证是指客户端到服务器端的认证。一个非常简单的解决这个认证错误的方法就是设置requests.get()方法的verify参数。这个参数默认设置为True，也就是执行认证。我们将其设置为False，绕过认证不就可以了？ 有想法就要尝试，编写代码如下： 1234567# -*- coding:UTF-8 -*-import requestsif __name__ &#x3D;&#x3D; &#39;__main__&#39;: target &#x3D; &#39;http:&#x2F;&#x2F;unsplash.com&#x2F;napi&#x2F;feeds&#x2F;home&#39; req &#x3D; requests.get(url&#x3D;target, verify&#x3D;False) print(req.text)123456 认证问题解决了，又有新问题了： 可以看到，我们GET请求又失败了，这是为什么？这个网站反爬虫的手段除了动态加载，还有一个反爬虫手段，那就是验证Request Headers。接下来，让我们分析下这个Requests Headers： 我截取了Fiddler的抓包信息，可以看到Requests Headers里又很多参数，有Accept、Accept-Encoding、Accept-Language、DPR、User-Agent、Viewport-Width、accept-version、Referer、x-unsplash-client、authorization、Connection、Host。它们都是什么意思呢？ 专业的解释能说的太多，我挑重点： User-Agent：这里面存放浏览器的信息。可以看到上图的参数值，它表示我是通过Windows的Chrome浏览器，访问的这个服务器。如果我们不设置这个参数，用Python程序直接发送GET请求，服务器接受到的User-Agent信息就会是一个包含python字样的User-Agent。如果后台设计者验证这个User-Agent参数是否合法，不让带Python字样的User-Agent访问，这样就起到了反爬虫的作用。这是一个最简单的，最常用的反爬虫手段。 Referer：这个参数也可以用于反爬虫，它表示这个请求是从哪发出的。可以看到我们通过浏览器访问网站，这个请求是从https://unsplash.com/，这个地址发出的。如果后台设计者，验证这个参数，对于不是从这个地址跳转过来的请求一律禁止访问，这样就也起到了反爬虫的作用。 authorization：这个参数是基于AAA模型中的身份验证信息允许访问一种资源的行为。在我们用浏览器访问的时候，服务器会为访问者分配这个用户ID。如果后台设计者，验证这个参数，对于没有用户ID的请求一律禁止访问，这样就又起到了反爬虫的作用。 Unsplash是根据哪个参数反爬虫的呢？根据我的测试，是authorization。我们只要通过程序手动添加这个参数，然后再发送GET请求，就可以顺利访问了。怎么什么设置呢？还是requests.get()方法，我们只需要添加headers参数即可。编写代码如下： 12345678# -*- coding:UTF-8 -*-import requestsif __name__ &#x3D;&#x3D; &#39;__main__&#39;: target &#x3D; &#39;http:&#x2F;&#x2F;unsplash.com&#x2F;napi&#x2F;feeds&#x2F;home&#39; headers &#x3D; &#123;&#39;authorization&#39;:&#39;your Client-ID&#39;&#125; req &#x3D; requests.get(url&#x3D;target, headers&#x3D;headers, verify&#x3D;False) print(req.text)1234567 headers参数值是通过字典传入的。记得将上述代码中your Client-ID换成诸位自己抓包获得的信息。代码运行结果如下： 皇天不负有心人，可以看到我们已经顺利获得json数据了，里面有next_page和照片的id。接下来就是解析json数据。根据我们之前分析可知，next_page放在了json数据的最外侧，照片的id放在了photos-&gt;id里。我们使用json.load()方法解析数据，编写代码如下： 123456789101112# -*- coding:UTF-8 -*-import requests, jsonif __name__ &#x3D;&#x3D; &#39;__main__&#39;: target &#x3D; &#39;http:&#x2F;&#x2F;unsplash.com&#x2F;napi&#x2F;feeds&#x2F;home&#39; headers &#x3D; &#123;&#39;authorization&#39;:&#39;your Client-ID&#39;&#125; req &#x3D; requests.get(url&#x3D;target, headers&#x3D;headers, verify&#x3D;False) html &#x3D; json.loads(req.text) next_page &#x3D; html[&#39;next_page&#39;] print(&#39;下一页地址:&#39;,next_page) for each in html[&#39;photos&#39;]: print(&#39;图片ID:&#39;,each[&#39;id&#39;])1234567891011 解析json数据很简单，跟字典操作一样，就是字典套字典。json.load()里面的参数是原始的json格式的数据。程序运行结果如下： 图片的ID已经获得了，再通过字符串处理一下，就生成了我们需要的图片下载请求地址。根据这个地址，我们就可以下载图片了。下载方式，使用直接写入文件的方法。 ###（3）整合代码 每次获取链接加一个1s延时，因为人在浏览页面的时候，翻页的动作不可能太快。我们要让我们的爬虫尽量友好一些。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# -*- coding:UTF-8 -*-import requests, json, time, sysfrom contextlib import closingclass get_photos(object): def __init__(self): self.photos_id &#x3D; [] self.download_server &#x3D; &#39;https:&#x2F;&#x2F;unsplash.com&#x2F;photos&#x2F;xxx&#x2F;download?force&#x3D;trues&#39; self.target &#x3D; &#39;http:&#x2F;&#x2F;unsplash.com&#x2F;napi&#x2F;feeds&#x2F;home&#39; self.headers &#x3D; &#123;&#39;authorization&#39;:&#39;Client-ID c94869b36aa272dd62dfaeefed769d4115fb3189a9d1ec88ed457207747be626&#39;&#125; &quot;&quot;&quot; 函数说明:获取图片ID Parameters: 无 Returns: 无 Modify: 2017-09-13 &quot;&quot;&quot; def get_ids(self): req &#x3D; requests.get(url&#x3D;self.target, headers&#x3D;self.headers, verify&#x3D;False) html &#x3D; json.loads(req.text) next_page &#x3D; html[&#39;next_page&#39;] for each in html[&#39;photos&#39;]: self.photos_id.append(each[&#39;id&#39;]) time.sleep(1) for i in range(5): req &#x3D; requests.get(url&#x3D;next_page, headers&#x3D;self.headers, verify&#x3D;False) html &#x3D; json.loads(req.text) next_page &#x3D; html[&#39;next_page&#39;] for each in html[&#39;photos&#39;]: self.photos_id.append(each[&#39;id&#39;]) time.sleep(1) &quot;&quot;&quot; 函数说明:图片下载 Parameters: 无 Returns: 无 Modify: 2017-09-13 &quot;&quot;&quot; def download(self, photo_id, filename): headers &#x3D; &#123;&#39;User-Agent&#39;:&#39;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;61.0.3163.79 Safari&#x2F;537.36&#39;&#125; target &#x3D; self.download_server.replace(&#39;xxx&#39;, photo_id) with closing(requests.get(url&#x3D;target, stream&#x3D;True, verify &#x3D; False, headers &#x3D; self.headers)) as r: with open(&#39;%d.jpg&#39; % filename, &#39;ab+&#39;) as f: for chunk in r.iter_content(chunk_size &#x3D; 1024): if chunk: f.write(chunk) f.flush()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: gp &#x3D; get_photos() print(&#39;获取图片连接中:&#39;) gp.get_ids() print(&#39;图片下载中:&#39;) for i in range(len(gp.photos_id)): print(&#39; 正在下载第%d张图片&#39; % (i+1)) gp.download(gp.photos_id[i], (i+1))12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 下载速度还行，有的图片下载慢是因为图片太大。可以看到右侧也打印了一些警报信息，这是因为我们没有进行SSL验证。 学会了爬取图片，简单的动态加载的网站也难不倒你了。赶快试试国内的一些图片网站吧！ 3 视频下载视频下载教程，请到这里查看： https://cuijiahua.com/blog/2017/10/spider_tutorial_1.html 四 总结 本次Chat讲解的实战内容，均仅用于学习交流，请勿用于任何商业用途！ 爬虫时效性低，同样的思路过了一个月，甚至一周可能无法使用，但是爬取思路都是如此，完全可以自行分析。 本次实战代码，均已上传我的Github，欢迎Follow、Star：https://github.com/Jack-Cherish/python-spider 如有问题，请留言。如有错误，还望指正，谢谢！","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python 爬虫（一）","slug":"Python-爬虫（一）","date":"2020-06-13T11:58:05.000Z","updated":"2020-06-13T11:59:18.308Z","comments":true,"path":"2020/06/13/Python-爬虫（一）/","link":"","permalink":"http://yoursite.com/2020/06/13/Python-%E7%88%AC%E8%99%AB%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"这是一篇详细介绍 Python 爬虫入门的教程，从实战出发，适合初学者。读者只需在阅读过程紧跟文章思路，理清相应的实现代码，30 分钟即可学会编写简单的 Python 爬虫。 这篇 Python 爬虫教程主要讲解以下 5 部分内容： 了解网页； 使用 requests 库抓取网站数据； 使用 Beautiful Soup 解析网页； 清洗和组织数据； 爬虫攻防战； 了解网页以中国旅游网首页（http://www.cntour.cn/）为例，抓取中国旅游网首页首条信息（标题和链接），数据以明文的形式出面在源码中。在中国旅游网首页，按快捷键【Ctrl+U】打开源码页面，如图 1 所示。 图 1 中国旅游网首页源码 认识网页结构网页一般由三部分组成，分别是 HTML（超文本标记语言）、CSS（层叠样式表）和 JScript（活动脚本语言）。 HTMLHTML 是整个网页的结构，相当于整个网站的框架。带“＜”、“＞”符号的都是属于 HTML 的标签，并且标签都是成对出现的。 常见的标签如下： .. 表示标记中间的元素是网页.. 表示用户可见的内容.. 表示框架.. 表示段落..表示列表..表示图片..表示标题..表示超链接 CSSCSS 表示样式，图 1 中第 13 行＜style type=＂text/css＂＞表示下面引用一个 CSS，在 CSS 中定义了外观。 JScriptJScript 表示功能。交互的内容和各种特效都在 JScript 中，JScript 描述了网站中的各种功能。 如果用人体来比喻，HTML 是人的骨架，并且定义了人的嘴巴、眼睛、耳朵等要长在哪里。CSS 是人的外观细节，如嘴巴长什么样子，眼睛是双眼皮还是单眼皮，是大眼睛还是小眼睛，皮肤是黑色的还是白色的等。JScript 表示人的技能，例如跳舞、唱歌或者演奏乐器等。 写一个简单的 HTML通过编写和修改 HTML，可以更好地理解 HTML。首先打开一个记事本，然后输入下面的内容： Python 3 爬虫与数据清洗入门与实战 Python 3爬虫与数据清洗入门与实战 爬虫 数据清洗 L2Dwidget.init({\"log\":false,\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"pluginRootPath\":\"live2dw/\",\"tagMode\":false}); 输入代码后，保存记事本，然后修改文件名和后缀名为”HTML.html”； 运行该文件后的效果，如图 2 所示。 图 2 这段代码只是用到了 HTML，读者可以自行修改代码中的中文，然后观察其变化。 关于爬虫的合法性几乎每一个网站都有一个名为 robots.txt 的文档，当然也有部分网站没有设定 robots.txt。对于没有设定 robots.txt 的网站可以通过网络爬虫获取没有口令加密的数据，也就是该网站所有页面数据都可以爬取。如果网站有 robots.txt 文档，就要判断是否有禁止访客获取的数据。 以淘宝网为例，在浏览器中访问 https://www.taobao.com/robots.txt，如图 3 所示。 图 3 淘宝网的robots.txt文件内容 淘宝网允许部分爬虫访问它的部分路径，而对于没有得到允许的用户，则全部禁止爬取，代码如下： User-Agent:*Disallow:/ 这一句代码的意思是除前面指定的爬虫外，不允许其他爬虫爬取任何数据。 使用 requests 库请求网站安装 requests 库首先在 PyCharm 中安装 requests 库，为此打开 PyCharm，单击“File”（文件）菜单，选择“Setting for New Projects…”命令，如图 4 所示。 图 4 选择“Project Interpreter”（项目编译器）命令，确认当前选择的编译器，然后单击右上角的加号，如图 5 所示。 图 5 在搜索框输入：requests（注意，一定要输入完整，不然容易出错），然后单击左下角的“Install Package”（安装库）按钮。如图 6 所示： 图 6 安装完成后，会在 Install Package 上显示“Package‘requests’ installed successfully”（库的请求已成功安装），如图 7 所示；如果安装不成功将会显示提示信息。 图 7 安装成功 爬虫的基本原理网页请求的过程分为两个环节： Request （请求）：每一个展示在用户面前的网页都必须经过这一步，也就是向服务器发送访问请求。 Response（响应）：服务器在接收到用户的请求后，会验证请求的有效性，然后向用户（客户端）发送响应的内容，客户端接收服务器响应的内容，将内容展示出来，就是我们所熟悉的网页请求，如图 8 所示。 图 8 Response相应 网页请求的方式也分为两种： GET：最常见的方式，一般用于获取或者查询资源信息，也是大多数网站使用的方式，响应速度快。 POST：相比 GET 方式，多了以表单形式上传参数的功能，因此除查询信息外，还可以修改信息。 所以，在写爬虫前要先确定向谁发送请求，用什么方式发送。 使用 GET 方式抓取数据复制任意一条首页首条新闻的标题，在源码页面按【Ctrl+F】组合键调出搜索框，将标题粘贴在搜索框中，然后按【Enter】键。 如图 8 所示，标题可以在源码中搜索到，请求对象是www.cntour.cn，请求方式是GET（所有在源码中的数据请求方式都是GET），如图 9 所示。 图 9（点此查看高清大图） 确定好请求对象和方式后，在 PyCharm 中输入以下代码： 1import requests #导入requests包url &#x3D; &#39;http:&#x2F;&#x2F;www.cntour.cn&#x2F;&#39;strhtml &#x3D; requests.get(url) #Get方式获取网页数据print(strhtml.text) 运行结果如图 10 所示： 图 10 运行结果效果图（点此查看高清大图） 加载库使用的语句是 import+库的名字。在上述过程中，加载 requests 库的语句是：import requests。 用 GET 方式获取数据需要调用 requests 库中的 get 方法，使用方法是在 requests 后输入英文点号，如下所示： requests.get 将获取到的数据存到 strhtml 变量中，代码如下： strhtml = request.get(url) 这个时候 strhtml 是一个 URL 对象，它代表整个网页，但此时只需要网页中的源码，下面的语句表示网页源码： strhtml.text 使用 POST 方式抓取数据首先输入有道翻译的网址：http://fanyi.youdao.com/，进入有道翻译页面。 按快捷键 F12，进入开发者模式，单击 Network，此时内容为空，如图 11 所示： 图 11 在有道翻译中输入“我爱中国”，单击“翻译”按钮，如图 12 所示： 图 12 在开发者模式中，依次单击“Network”按钮和“XHR”按钮，找到翻译数据，如图 13 所示： 图 13 单击 Headers，发现请求数据的方式为 POST。如图 14 所示： 图 14 找到数据所在之处并且明确请求方式之后，接下来开始撰写爬虫。 首先，将 Headers 中的 URL 复制出来，并赋值给 url，代码如下： url = ‘http://fanyi.youdao.com/translate_o?smartresult=dict&amp;smartresult=rule&#39; POST 的请求获取数据的方式不同于 GET，POST 请求数据必须构建请求头才可以。 Form Data 中的请求参数如图 15 所示： 图 15 将其复制并构建一个新字典： From_data={‘i’:’我愛中國’,’from’:’zh-CHS’,’to’:’en’,’smartresult’:’dict’,’client’:’fanyideskweb’,’salt’:’15477056211258’,’sign’:’b3589f32c38bc9e3876a570b8a992604’,’ts’:’1547705621125’,’bv’:’b33a2f3f9d09bde064c9275bcb33d94e’,’doctype’:’json’,’version’:’2.1’,’keyfrom’:’fanyi.web’,’action’:’FY_BY_REALTIME’,’typoResult’:’false’} 接下来使用 requests.post 方法请求表单数据，代码如下： import requests #导入requests包response = requests.post(url,data=payload) 将字符串格式的数据转换成 JSON 格式数据，并根据数据结构，提取数据，并将翻译结果打印出来，代码如下： 1import jsoncontent &#x3D; json.loads(response.text)print(content[&#39;translateResult&#39;][0][0][&#39;tgt&#39;]) 使用 requests.post 方法抓取有道翻译结果的完整代码如下： 1import requests #导入requests包import jsondef get_translate_date(word&#x3D;None): url &#x3D; &#39;http:&#x2F;&#x2F;fanyi.youdao.com&#x2F;translate_o?smartresult&#x3D;dict&amp;smartresult&#x3D;rule&#39; From_data&#x3D;&#123;&#39;i&#39;:word,&#39;from&#39;:&#39;zh-CHS&#39;,&#39;to&#39;:&#39;en&#39;,&#39;smartresult&#39;:&#39;dict&#39;,&#39;client&#39;:&#39;fanyideskweb&#39;,&#39;salt&#39;:&#39;15477056211258&#39;,&#39;sign&#39;:&#39;b3589f32c38bc9e3876a570b8a992604&#39;,&#39;ts&#39;:&#39;1547705621125&#39;,&#39;bv&#39;:&#39;b33a2f3f9d09bde064c9275bcb33d94e&#39;,&#39;doctype&#39;:&#39;json&#39;,&#39;version&#39;:&#39;2.1&#39;,&#39;keyfrom&#39;:&#39;fanyi.web&#39;,&#39;action&#39;:&#39;FY_BY_REALTIME&#39;,&#39;typoResult&#39;:&#39;false&#39;&#125; #请求表单数据 response &#x3D; requests.post(url,data&#x3D;From_data) #将Json格式字符串转字典 content &#x3D; json.loads(response.text) print(content) #打印翻译后的数据 #print(content[&#39;translateResult&#39;][0][0][&#39;tgt&#39;])if __name__&#x3D;&#x3D;&#39;__main__&#39;: get_translate_date(&#39;我爱中国&#39;) 使用 Beautiful Soup 解析网页通过 requests 库已经可以抓到网页源码，接下来要从源码中找到并提取数据。Beautiful Soup 是 python 的一个库，其最主要的功能是从网页中抓取数据。Beautiful Soup 目前已经被移植到 bs4 库中，也就是说在导入 Beautiful Soup 时需要先安装 bs4 库。 安装 bs4 库的方式如图 16 所示: 图 16 安装好 bs4 库以后，还需安装 lxml 库。如果我们不安装 lxml 库，就会使用 Python 默认的解析器。尽管 Beautiful Soup 既支持 Python 标准库中的 HTML 解析器又支持一些第三方解析器，但是 lxml 库具有功能更加强大、速度更快的特点，因此笔者推荐安装 lxml 库。 安装 Python 第三方库后，输入下面的代码，即可开启 Beautiful Soup 之旅： 1import requests #导入requests包from bs4 import BeautifulSoupurl&#x3D;&#39;http:&#x2F;&#x2F;www.cntour.cn&#x2F;&#39;strhtml&#x3D;requests.get(url)soup&#x3D;BeautifulSoup(strhtml.text,&#39;lxml&#39;)data &#x3D; soup.select(&#39;#main&gt;div&gt;div.mtop.firstMod.clearfix&gt;div.centerBox&gt;ul.newsList&gt;li&gt;a&#39;)print(data) 代码运行结果如图 17 所示。 图 17（点此查看高清大图） Beautiful Soup 库能够轻松解析网页信息，它被集成在 bs4 库中，需要时可以从 bs4 库中调用。其表达语句如下： from bs4 import BeautifulSoup 首先，HTML 文档将被转换成 Unicode 编码格式，然后 Beautiful Soup 选择最合适的解析器来解析这段文档，此处指定 lxml 解析器进行解析。解析后便将复杂的 HTML 文档转换成树形结构，并且每个节点都是 Python 对象。这里将解析后的文档存储到新建的变量 soup 中，代码如下： soup=BeautifulSoup(strhtml.text,’lxml’) 接下来用 select（选择器）定位数据，定位数据时需要使用浏览器的开发者模式，将鼠标光标停留在对应的数据位置并右击，然后在快捷菜单中选择“检查”命令，如图 18 所示： 图 18 随后在浏览器右侧会弹出开发者界面，右侧高亮的代码（参见图 19(b)）对应着左侧高亮的数据文本（参见图 19(a)）。右击右侧高亮数据，在弹出的快捷菜单中选择“Copy”➔“Copy Selector”命令，便可以自动复制路径。 图 19 复制路径 将路径粘贴在文档中，代码如下: #main &gt; div &gt; div.mtop.firstMod.clearfix &gt; div.centerBox &gt; ul.newsList &gt; li:nth-child(1) &gt; a 由于这条路径是选中的第一条的路径，而我们需要获取所有的头条新闻，因此将 li：nth-child（1）中冒号（包含冒号）后面的部分删掉，代码如下： #main &gt; div &gt; div.mtop.firstMod.clearfix &gt; div.centerBox &gt; ul.newsList &gt; li &gt; a 使用 soup.select 引用这个路径，代码如下： data = soup.select(‘#main &gt; div &gt; div.mtop.firstMod.clearfix &gt; div.centerBox &gt; ul.newsList &gt; li &gt; a’) 清洗和组织数据至此，获得了一段目标的 HTML 代码，但还没有把数据提取出来，接下来在 PyCharm 中输入以下代码： 1for item in data: result&#x3D;&#123; &#39;title&#39;:item.get_text(), &#39;link&#39;:item.get(&#39;href&#39;) &#125;print(result) 代码运行结果如图 20 所示： 图 20（点此查看高清大图） 首先明确要提取的数据是标题和链接，标题在＜a＞标签中，提取标签的正文用 get_text() 方法。链接在＜a＞标签的 href 属性中，提取标签中的 href 属性用 get() 方法，在括号中指定要提取的属性数据，即 get(＇href＇)。 从图 20 中可以发现，文章的链接中有一个数字 ID。下面用正则表达式提取这个 ID。需要使用的正则符号如下: \\d匹配数字+匹配前一个字符1次或多次 在 Python 中调用正则表达式时使用 re 库，这个库不用安装，可以直接调用。在 PyCharm 中输入以下代码: 1import refor item in data: result&#x3D;&#123; &quot;title&quot;:item.get_text(), &quot;link&quot;:item.get(&#39;href&#39;), &#39;ID&#39;:re.findall(&#39;\\d+&#39;,item.get(&#39;href&#39;)) &#125;print(result) 运行结果如图 21 所示： 图 21 这里使用 re 库的 findall 方法，第一个参数表示正则表达式，第二个参数表示要提取的文本。 爬虫攻防战爬虫是模拟人的浏览访问行为，进行数据的批量抓取。当抓取的数据量逐渐增大时，会给被访问的服务器造成很大的压力，甚至有可能崩溃。换句话就是说，服务器是不喜欢有人抓取自己的数据的。那么，网站方面就会针对这些爬虫者，采取一些反爬策略。 服务器第一种识别爬虫的方式就是通过检查连接的 useragent 来识别到底是浏览器访问，还是代码访问的。如果是代码访问的话，访问量增大时，服务器会直接封掉来访 IP。 那么应对这种初级的反爬机制，我们应该采取何种举措？ 还是以前面创建好的爬虫为例。在进行访问时，我们在开发者环境下不仅可以找到 URL、Form Data，还可以在 Request headers 中构造浏览器的请求头，封装自己。服务器识别浏览器访问的方法就是判断 keyword 是否为 Request headers 下的 User-Agent，如图 22 所示。 图 22 因此，我们只需要构造这个请求头的参数。创建请求头部信息即可，代码如下： headers={‘User-Agent’:’Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36’}response = request.get(url,headers=headers) 写到这里，很多读者会认为修改 User-Agent 很太简单。确实很简单，但是正常人1秒看一个图，而个爬虫1秒可以抓取好多张图，比如 1 秒抓取上百张图，那么服务器的压力必然会增大。也就是说，如果在一个 IP 下批量访问下载图片，这个行为不符合正常人类的行为，肯定要被封 IP。 其原理也很简单，就是统计每个IP的访问频率，该频率超过阈值，就会返回一个验证码，如果真的是用户访问的话，用户就会填写，然后继续访问，如果是代码访问的话，就会被封 IP。 这个问题的解决方案有两个，第一个就是常用的增设延时，每 3 秒钟抓取一次，代码如下： import timetime.sleep(3) 但是，我们写爬虫的目的是为了高效批量抓取数据，这里设置 3 秒钟抓取一次，效率未免太低。其实，还有一个更重要的解决办法，那就是从本质上解决问题。 不管如何访问，服务器的目的就是查出哪些为代码访问，然后封锁 IP。解决办法：为避免被封 IP，在数据采集时经常会使用代理。当然，requests 也有相应的 proxies 属性。 首先，构建自己的代理 IP 池，将其以字典的形式赋值给 proxies，然后传输给 requests，代码如下： 1proxies&#x3D;&#123; &quot;http&quot;:&quot;http:&#x2F;&#x2F;10.10.1.10:3128&quot;, &quot;https&quot;:&quot;http:&#x2F;&#x2F;10.10.1.10:1080&quot;,&#125;response &#x3D; requests.get(url, proxies&#x3D;proxies) 扩展阅读本文仅对 Python 爬虫及实现过程做了简明扼要地介绍，仅能使初学者对 python 爬虫有一个浅显的认识，并不能让你完全掌握 Python 爬虫。 如果你想对 Python 爬虫有更深入的了解，我推荐你阅读： Python爬虫入门教程 Python3网络爬虫入门教程 Python爬虫教程——慕课网","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python pip","slug":"Python-pip","date":"2020-06-13T11:56:46.000Z","updated":"2020-06-13T11:57:22.897Z","comments":true,"path":"2020/06/13/Python-pip/","link":"","permalink":"http://yoursite.com/2020/06/13/Python-pip/","excerpt":"","text":"pip 是 Python 包管理工具，该工具提供了对Python 包的查找、下载、安装、卸载的功能。 目前如果你在 python.org 下载最新版本的安装包，则是已经自带了该工具。 Python 2.7.9 + 或 Python 3.4+ 以上版本都自带 pip 工具。 pip 官网：https://pypi.org/project/pip/ 你可以通过以下命令来判断是否已安装： 1pip --version 如果你还未安装，则可以使用以下方法来安装： 12$ curl https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py -o get-pip.py # 下载安装脚本$ sudo python get-pip.py # 运行安装脚本 注意：用哪个版本的 Python 运行安装脚本，pip 就被关联到哪个版本，如果是 Python3 则执行以下命令： 1$ sudo python3 get-pip.py # 运行安装脚本。 一般情况 pip 对应的是 Python 2.7，pip3 对应的是 Python 3.x。 部分 Linux 发行版可直接用包管理器安装 pip，如 Debian 和 Ubuntu： 1sudo apt-get install python-pip pip 最常用命令显示版本和路径 1pip --version 获取帮助 1pip --help 升级 pip 1pip install -U pip 如果这个升级命令出现问题 ，可以使用以下命令： 1sudo easy_install --upgrade pip 安装包 123pip install SomePackage # 最新版本pip install SomePackage&#x3D;&#x3D;1.0.4 # 指定版本pip install &#39;SomePackage&gt;&#x3D;1.0.4&#39; # 最小版本 比如我要安装 Django。用以下的一条命令就可以，方便快捷。 1pip install Django&#x3D;&#x3D;1.7 升级包 1pip install --upgrade SomePackage 升级指定的包，通过使用==, &gt;=, &lt;=, &gt;, &lt; 来指定一个版本号。 卸载包 1pip uninstall SomePackage 搜索包 1pip search SomePackage 显示安装包信息 1pip show 查看指定包的详细信息 1pip show -f SomePackage 列出已安装的包 1pip list 查看可升级的包 1pip list -o 注意事项如果 Python2 和 Python3 同时有 pip，则使用方法如下： Python2： 1python2 -m pip install XXX Python3: 1python3 -m pip install XXX","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python PyInstaller","slug":"Python-PyInstaller","date":"2020-06-13T11:55:39.000Z","updated":"2020-06-13T11:56:14.005Z","comments":true,"path":"2020/06/13/Python-PyInstaller/","link":"","permalink":"http://yoursite.com/2020/06/13/Python-PyInstaller/","excerpt":"","text":"在创建了独立应用（自包含该应用的依赖包）之后，还可以使用 PyInstaller 将 Python 程序生成可直接运行的程序，这个程序就可以被分发到对应的 Windows 或 Mac OS X 平台上运行。 安装 PyInstallePython 默认并不包含 PyInstaller 模块，因此需要自行安装 PyInstaller 模块。 安装 PyInstaller 模块与安装其他 Python 模块一样，使用 pip 命令安装即可。在命令行输入如下命令： pip install pyinstaller 强烈建议使用 pip 在线安装的方式来安装 PyInstaller 模块，不要使用离线包的方式来安装，因为 PyInstaller 模块还依赖其他模块，pip 在安装 PyInstaller 模块时会先安装它的依赖模块。 运行上面命令，应该看到如下输出结果： Successfully installed pyinstaller-x.x.x 其中的 x.x.x 代表 PyInstaller 的版本。 在 PyInstaller 模块安装成功之后，在 Python 的安装目录下的 Scripts(D:\\Python\\Python36\\Scripts) 目录下会增加一个 pyinstaller.exe 程序，接下来就可以使用该工具将 Python 程序生成 EXE 程序了。 PyInstaller生成可执行程序PyInstaller 工具的命令语法如下： pyinstaller 选项 Python 源文件 不管这个 Python 应用是单文件的应用，还是多文件的应用，只要在使用 pyinstaller 命令时编译作为程序入口的 Python 程序即可。 PyInstaller工具是跨平台的，它既可以在 Windows平台上使用，也可以在 Mac OS X 平台上运行。在不同的平台上使用 PyInstaller 工具的方法是一样的，它们支持的选项也是一样的。 下面先创建一个 app 目录，在该目录下创建一个 app.py 文件，文件中包含如下代码： 1from say_hello import *def main(): print(&#39;程序开始执行&#39;) print(say_hello(&#39;孙悟空&#39;))# 增加调用main()函数if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 接下来使用命令行工具进入到此 app 目录下，执行如下命令： pyinstaller -F app.py 执行上面命令，将看到详细的生成过程。当生成完成后，将会在此 app 目录下看到多了一个 dist 目录，并在该目录下看到有一个 app.exe 文件，这就是使用 PyInstaller 工具生成的 EXE 程序。 在命令行窗口中进入 dist 目录下，在该目录执行 app.exe ，将会看到该程序生成如下输出结果： 程序开始执行孙悟空，您好！ 由于该程序没有图形用户界面，因此如果读者试图通过双击来运行该程序，则只能看到程序窗口一闪就消失了，这样将无法看到该程序的输出结果。 在上面命令中使用了-F 选项，该选项指定生成单独的 EXE 文件，因此，在 dist 目录下生成了一个单独的大约为 6MB 的 app.exe 文件（在 Mac OS X 平台上生成的文件就叫 app，没有后缀）；与 -F 选项对应的是 -D 选项（默认选项），该选项指定生成一个目录（包含多个文件）来作为程序。 下面先将 PyInstaller 工具在 app 目录下生成的 build、dist 目录删除，并将 app.spec 文件也删除，然后使用如下命令来生成 EXE 文件。 pyinstaller -D app.py 执行上面命令，将看到详细的生成过程。当生成完成后，将会在 app 目录下看到多了一个 dist 目录，并在该目录下看到有一个 app 子目录，在该子目录下包含了大量 .dll 文件和 .pyz 文件，它们都是 app.exe 程序的支撑文件。在命令行窗口中运行该 app.exe 程序，同样可以看到与前一个 app.exe 程序相同的输出结果。 PyInstaller 不仅支持 -F、-D 选项，而且也支持如表 1 所示的常用选项。 -h，–help 查看该模块的帮助信息 -F，-onefile 产生单个的可执行文件 -D，–onedir 产生一个目录（包含多个文件）作为可执行程序 -a，–ascii 不包含 Unicode 字符集支持 -d，–debug 产生 debug 版本的可执行文件 -w，–windowed，–noconsolc 指定程序运行时不显示命令行窗口（仅对 Windows 有效） -c，–nowindowed，–console 指定使用命令行窗口运行程序（仅对 Windows 有效） -o DIR，–out=DIR 指定 spec 文件的生成目录。如果没有指定，则默认使用当前目录来生成 spec 文件 -p DIR，–path=DIR 设置 Python 导入模块的路径（和设置 PYTHONPATH 环境变量的作用相似）。也可使用路径分隔符（Windows 使用分号，Linux 使用冒号）来分隔多个路径 -n NAME，–name=NAME 指定项目（产生的 spec）名字。如果省略该选项，那么第一个脚本的主文件名将作为 spec 的名字 在表 1 中列出的只是 PyInstaller 模块所支持的常用选项，如果需要了解 PyInstaller 选项的详细信息，则可通过 pyinstaller -h 来查看。 下面再创建一个带图形用户界面，可以访问 MySQL 数据库的应用程序。 在 app 当前所在目录再创建一个 dbapp 目录，并在该目录下创建 Python 程序，其中 exec_select.py 程序负责查询数据，main.py 程序负责创建图形用户界面来显示查询结果。 exec_select.py 文件包含的代码如下： 1# 导入访问MySQL的模块import mysql.connectordef query_db(): # ①、连接数据库 conn &#x3D; conn &#x3D; mysql.connector.connect(user&#x3D;&#39;root&#39;, password&#x3D;&#39;32147&#39;, host&#x3D;&#39;localhost&#39;, port&#x3D;&#39;3306&#39;, database&#x3D;&#39;python&#39;, use_unicode&#x3D;True) # ②、获取游标 c &#x3D; conn.cursor() # ③、调用执行select语句查询数据 c.execute(&#39;select * from user_tb where user_id &gt; %s&#39;, (2,)) # 通过游标的description属性获取列信息 description &#x3D; c.description # 使用fetchall获取游标中的所有结果集 rows &#x3D; c.fetchall() # ④、关闭游标 c.close() # ⑤、关闭连接 conn.close() return description, rows mian.py 文件包含的代码如下： 1from exec_select import *from tkinter import *def main(): description, rows &#x3D; query_db() # 创建窗口 win &#x3D; Tk() win.title(&#39;数据库查询&#39;) # 通过description获取列信息 for i, col in enumerate(description): lb &#x3D; Button(win, text&#x3D;col[0], padx&#x3D;50, pady&#x3D;6) lb.grid(row&#x3D;0, column&#x3D;i) # 直接使用for循环查询得到的结果集 for i, row in enumerate(rows): for j in range(len(row)): en &#x3D; Label(win, text&#x3D;row[j]) en.grid(row&#x3D;i+1, column&#x3D;j) win.mainloop()if __name__ &#x3D;&#x3D; &#39;__main__&#39;: main() 通过命令行工具进入 dbapp 目录下，在该目录下执行如下命令： Pyinstaller -F -w main.py 上面命令中的 -F 选项指定生成单个的可执行程序，-w 选项指定生成图形用户界面程序（不需要命令行界面）。运行上面命令，该工具同样在 dbapp 目录下生成了一个 dist 子目录，并在该子目录下生成了一个 main.exe 文件。 直接双击运行 main.exe 程序（该程序有图形用户界面，因此可以双击运行），读者可自行查看运行结果。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python爬虫爬取小姐姐图片","slug":"python爬虫爬取小姐姐图片","date":"2020-06-13T11:29:49.000Z","updated":"2020-06-13T11:54:01.011Z","comments":true,"path":"2020/06/13/python爬虫爬取小姐姐图片/","link":"","permalink":"http://yoursite.com/2020/06/13/python%E7%88%AC%E8%99%AB%E7%88%AC%E5%8F%96%E5%B0%8F%E5%A7%90%E5%A7%90%E5%9B%BE%E7%89%87/","excerpt":"","text":"接触爬虫的第一天第一步：现将python环境搭建好，工欲利其事必先利其器！第二步：寻找目标网站，我选择的网站是http://www.win4000.com，里面有一个美女板块，里面有各种小姐姐的照片（你懂的） 第三步：分析目标网站的html源码及网页规则通过分析我发现，该网页每个人物的每个图片都是http://www.win4000.com/meinv1_2.htmlhttp://www.win4000.com/meinv1_3.htmlhttp://www.win4000.com/meinv2_1.htmlhttp://www.win4000.com/meinv2_2.html并且所有图片地址都存放在一个中 12345678910111213141516171819202122232425262728293031323334# coding:utf-8from bs4 import BeautifulSoup #引用BeautifulSoup库import requests #引用requestsimport os #osos.system (\"title Py爬取小姐姐，李天行版权所有\")print (\"爬取的图片都在D:/img文件夹下\")root = 'D://img//' #配置存储路径，我配置的是自己电脑中的D:/img文件夹for page in range(1,1000): #配置爬取页码，我这边配置的是1000个人的图片 for p in range(1,20): #配置爬取每个人多少张的参数，我这边配置的是每个人20张 url = 'http://www.win4000.com/meinv'+str(page)+'_'+str(p)+'.html' r = requests.get(url) #使用requests中的get方法获取整个网页 r.encoding='utf-8' #设定网页所使用的编码方式，错误的编码方式会导致乱码 if r.status_code!=404: #判断生成后的链接是不是能访问，只有能访问才能爬取下载 demo = r.text #将爬取后的对象通过text方法提取出所有的html soup = BeautifulSoup(demo, \"html.parser\")#使用BeautifulSoup库进行整合，第二个参数使用lxml一样的，lxml兼容性好较好，速度较快 text = soup.find_all('img',class_ = 'pic-large')#选取整合后我们需要的部分内容，选取后的数据为list数组 for img in text: imagr_url = img.get('data-original') #取出img标签中data-original中的值 file_name = root + imagr_url.split('/')[-1] #取出图片地址中文件及文件扩展名与本地存储路径进行拼接 try: if not os.path.exists(root): #判断文件夹是否存在，不存在则创建文件夹 os.mkdir(root) if not os.path.exists(file_name): #判断图片文件是否存在，存在则进行提示 s = requests.get(imagr_url) #通过requests.get方式获取文件 # 使用with语句可以不用自己手动关闭已经打开的文件流 with open(file_name, \"wb\") as f: # 开始写文件，wb代表写二进制文件 f.write(s.content) print(\"爬取完成\") else: print(\"文件已存在\") except Exception as e: print(\"爬取失败:\" + str(e)) 哈哈哈哈大功告成，以下是成果展示 总结：1、该方式爬取为单进程爬取，只能一张一张爬取2、进行图片请求时一定要注意不要使用之前使用过的变量3、细心、认真、不浮躁","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python爬取你想要的小姐姐","slug":"Python爬取你想要的小姐姐","date":"2020-06-13T10:57:41.000Z","updated":"2020-06-13T11:23:39.013Z","comments":true,"path":"2020/06/13/Python爬取你想要的小姐姐/","link":"","permalink":"http://yoursite.com/2020/06/13/Python%E7%88%AC%E5%8F%96%E4%BD%A0%E6%83%B3%E8%A6%81%E7%9A%84%E5%B0%8F%E5%A7%90%E5%A7%90/","excerpt":"","text":"一、准备 \\1. 原地址 \\2. 检查html发现，网页是有规则的分页, 最大图片的class为pic-large 二、代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869 1 import requests 2 import os 3 from bs4 import BeautifulSoup 4 5 url &#x3D; &#39;http:&#x2F;&#x2F;www.win4000.com&#x2F;wallpaper_detail_157712.html&#39; 6 imgmkdir &#x3D; &#39;D:&#x2F;&#x2F;Download&#x2F;&#x2F;ghost_1&#x2F;&#x2F;&#39; 7 8 9 # 获取网页url10 def getUrlList():11 imgUrlList &#x3D; []12 for i in range(0, 10):13 imgUrl &#x3D; &#39;&#39;14 url_split &#x3D; url.split(&#39;.html&#39;)15 if not i &#x3D;&#x3D; 0:16 imgUrl +&#x3D; url_split[0] + &#39;_&#39; + str(i) + &#39;.html&#39;17 # print(imgUrl)18 imgUrlList.append(imgUrl)19 20 return imgUrlList21 22 23 # 下载图片24 def downImg(imgUrl):25 try:26 if not os.path.exists(imgmkdir):27 os.mkdir(imgmkdir)28 if not os.path.exists(imgUrl):29 r &#x3D; requests.get(imgUrl)30 r.raise_for_status()31 # 使用with语句可以不用自己手动关闭已经打开的文件流32 imgpath &#x3D; imgmkdir + imgUrl.split(&#39;&#x2F;&#39;)[-1]33 # 开始写文件, wb表示写二进制文件34 with open(imgpath, &#39;wb&#39;) as f:35 f.write(r.content)36 print(imgUrl + &#39;【爬取完成】&#39;)37 else:38 print(imgUrl.split(&#39;&#x2F;&#39;)[-1] + &#39;【文件已存在】&#39;)39 except Exception as e:40 print(&quot;爬取失败&quot; + str(e))41 42 43 # 获取imgHtml标签44 def getcontent(soup):45 for i in soup.find_all(&#39;img&#39;, class_&#x3D;&#39;pic-large&#39;):46 imgsrc &#x3D; i[&#39;src&#39;]47 if imgsrc.find(&#39;http&#39;) &gt;&#x3D; 0 or imgsrc.find(&#39;https&#39;) &gt;&#x3D; 0:48 # 下载图片49 downImg(imgsrc)50 51 52 # 根据url获取html源码53 def getHtmlByUrl(htmlUrl):54 htmlText &#x3D; requests.get(htmlUrl).content55 # 使用beautifulSoup解析html56 soup &#x3D; BeautifulSoup(htmlText, &#39;lxml&#39;)57 58 return soup59 60 61 def main():62 htmlUrlList &#x3D; getUrlList()63 for url in htmlUrlList:64 htmltext &#x3D; getHtmlByUrl(url)65 getcontent(htmltext)66 67 68 if __name__ &#x3D;&#x3D; &#39;__main__&#39;:69 main() 三、结果 四、总结 代码用比较笨的方法来获取，先试水 五、本人（副社长）升级的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596# -*-coding:utf-8-*-import requestsimport osfrom bs4 import BeautifulSoupurl = 'http://www.win4000.com/wallpaper_detail_157712.html'a=0imgmkdir = 'D://迅雷下载//'# 获取网页urldef getUrlList(): imgUrlList = [] for i in range(0, 10): imgUrl = '' url_split = url.split('.html') if not i == 0: imgUrl += url_split[0] + '_' + str(i) + '.html' # print(imgUrl) imgUrlList.append(imgUrl) return imgUrlList# 下载图片def downImg(imgUrl): try: if not os.path.exists(imgmkdir): os.mkdir(imgmkdir) if not os.path.exists(imgUrl): r = requests.get(imgUrl) r.raise_for_status() # 使用with语句可以不用自己手动关闭已经打开的文件流 imgpath = imgmkdir + imgUrl.split('/')[-1] # 开始写文件, wb表示写二进制文件 with open(imgpath, 'wb') as f: f.write(r.content) print(imgUrl + '【爬取完成】') else: print(imgUrl.split('/')[-1] + '【文件已存在】') except Exception as e: print(\"爬取失败\" + str(e))# 获取imgHtml标签def getcontent(soup): for i in soup.find_all('img', class_='pic-large'): imgsrc = i['src'] if imgsrc.find('http') &gt;= 0 or imgsrc.find('https') &gt;= 0: # 下载图片 downImg(imgsrc)# 根据url获取html源码def getHtmlByUrl(htmlUrl): htmlText = requests.get(htmlUrl).content # 使用beautifulSoup解析html soup = BeautifulSoup(htmlText, 'lxml') return soupdef main(): htmlUrlList = getUrlList() for url in htmlUrlList: htmltext = getHtmlByUrl(url) getcontent(htmltext)if __name__ == '__main__': while 1: main() if a==0: a=0 if a==1: url = 'http://www.win4000.com/wallpaper_detail_169808.html' if a==2: url = 'http://www.win4000.com/wallpaper_detail_169594.html' if a==3: url = 'http://www.win4000.com/wallpaper_detail_169553.html' if a==4: url = 'http://www.win4000.com/wallpaper_detail_169629.html' if a==5: url = 'http://www.win4000.com/wallpaper_detail_169317.html' if a==6: url = 'http://www.win4000.com/wallpaper_detail_169116.html' if a==7: url = 'http://www.win4000.com/wallpaper_detail_169163.html' if a==8: url = 'http://www.win4000.com/wallpaper_detail_168984.html' if a==9: url = 'http://www.win4000.com/wallpaper_detail_168684.html' if a==10: url = 'http://www.win4000.com/wallpaper_detail_168524.html' a=a+1","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python如何脱单（四）","slug":"Python如何脱单（四）","date":"2020-06-13T10:55:46.000Z","updated":"2020-06-13T10:56:28.585Z","comments":true,"path":"2020/06/13/Python如何脱单（四）/","link":"","permalink":"http://yoursite.com/2020/06/13/Python%E5%A6%82%E4%BD%95%E8%84%B1%E5%8D%95%EF%BC%88%E5%9B%9B%EF%BC%89/","excerpt":"","text":"哄女朋友最高的境界是什么？ 除了用心之外，每天不重复的甜言蜜语必然是少不了的。虽然语文老师上学的时候也教了一些东西，但是日子长了必然“江郎才尽”。 大家都是混科技圈的，借助自动化的手段能不能一次性的解决问题呢？ 嗯，显然是可以的。Github作为全球最大的同性交友网站，小伙伴们不仅可以在上面交流编程技巧，还能学到如何开发一个自动哄女友神器。 先附上Github地址： https://github.com/sfyc23/EverydayWechat 这个自动给女友发送微信暖心话的项目，已经连续霸榜Github趋势榜好几天了。作者用Python3和Itchat微信接口开发了一款小工具，可以定时给朋友发送每日天气、提醒、每日一句。通过调用图灵机器人，也可以智能自动回复信息。 操作简单且容易上手，即使是小白，只要配置好了Python环境，安装好必要的Python库，代码下载之后，只要CMD一下即可实现。 在手把手教大家操作之前，文摘菌先带大家看下效果~ 首先，我定的时间是22:20，一到时间文摘菌的账号就收到了发送的信息，包括英文和中文情话。北京的天气以及在一起的多少天。 调用图灵机器人之后，两个账号便可以对话，图灵机器人还算强大，当我发送：这是个测试之后，图灵机器人回复：你不放心我吗？☹☹☹☹ 注：这个小工具的项目中的天气信息来自SOJSON API接口，暖心情话来自金山词霸上面的每日一句，带英文的哟~图灵机器人使用需要申请密钥，每天免费数量只有100条。如果使用超了。可使用青云客智能聊天机器人，这个不限制次数。 手把手教学实现哄女友神器 来吧，先视频演示一下使用教程~ 首先，把Python安装好，并配置好环境，个人建议新手安装anaconda，具体安装教程，可自行谷歌搜索~ 然后安装必要的Python库，环境配置好的同学可以直接用pip install +库名 进行安装。必须安装的库为：requests、beautifulsoup4、itchat、apscheduler、pyyaml、lxml、simplejson。记住了，小伙伴，一个库都不能少哟~ 然后进入Github地址下载项目的全部文件（就是这么简单粗暴），解压过后，找到 _config.yaml 用Python IDE打开。然后进行一系列的配置~ 就是这个文件 一、配置自动回复机器人。 1.开启自动回复： 将 is_auto_relay 设置为：True。 2.配置图灵机器人: 打开图灵机器人官网：http://www.turingapi.com 进行注册。 创建机器人，得到 apikey，userid。 将 apikey，userid 填入到 _config.yaml 文件中的： turing_conf: apiKey: ‘你所获取apiKey’ userId: ‘你所获取的userId’ \\3. 指定自动回复的好友名单: # 指定自动回复的好友名单。 auto_reply_names: - ‘好友1’ - ‘好友2’ 注意： 只能自动回复文字类消息； 群消息自动回复还未现实。（待完成）； 如果消息发送太频繁，微信会限制登录网页端登录。放心，并不会封号； 并不是对所有人自动回复，只是回复auto_reply_names中的人。 当没有图灵机器人 apikey 与 UserId，或者数量超出时。会使用备用的青云客智能聊天机器人获取数据。 二、配置定时提醒 1.开启并设置提醒时间： 如： alarm_info: is_alarm: True #定时发送时间 alarm_timed: ‘9:30’ 2.填写需要发送的好友。. 如： girlfriend_infos: - #女友微信昵称或者备注名，不能输入微信号。 wechat_name: ‘文摘菌’ #女友所在城市，用于发送天气。（可空） city_name: ‘北京’ # 从那天开始勾搭的（可空）(最终效果为：宝贝这是我们在一起的第 111 天) start_date: ‘2019-06-13’ # 后缀（可空） sweet_words: ‘来自最爱你的我。’ #如果你有多个人需要发送，则参照这个样式，复制即可 #如不需要，则删除或注解下面所有的数据 - wechat_name: ‘happy’ city_name: ‘朝阳区’ start_date: ‘2018-11-11’ sweet_words: ‘来自你俊美的老公。’ 然后，直接将run.py文件直接拖到命令窗口界面（视频中有演示），会出现二维码，扫描之后，实现网页登录。如下☟ 发送成功如下☟ 自动回复成功如下☟ 注意事项： 检查是否是最新的代码，检查是否是 Python3.5+，检查依赖有没有安装完整。 先检查微信是否可登录 微信网页版，如网页端不能用，此项目也不能用。 请更新你的 itchat 为最新版本。 与微信相关的可以先去 itchat issues 是否有相似问题。 微信名只能是昵称或者备注名，不能输入微信号。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python如何脱单（三）","slug":"Python如何脱单（三）","date":"2020-06-13T10:54:28.000Z","updated":"2020-06-13T10:55:16.909Z","comments":true,"path":"2020/06/13/Python如何脱单（三）/","link":"","permalink":"http://yoursite.com/2020/06/13/Python%E5%A6%82%E4%BD%95%E8%84%B1%E5%8D%95%EF%BC%88%E4%B8%89%EF%BC%89/","excerpt":"","text":"用 Python 制作的给父母天气预报提醒的小工具天气变冷了，给父母制作一个天气提醒小助手，这篇文章我同步到博客上之后，有读者在评论区留言，对于部分微信没有网页版接口，导致无法实现这个功能，这位读者建议，建议用发短信的方式，这样，就不会受限于微信的限制。 这是一个好方法，今天的教程就是教大家怎么发送免费短信给女朋友。 发送短信接口，我知道的常见的有两个平台，一个是 twilio，可以免费发短信 500 条，可发任意信息，一个是腾讯云，可以免费发短信 100 条，需要申请短信发送内容模板。 鉴于 twilio 免费次数多一些，所以，这次我们就 twilio来发送当天的天气信息给爸妈了。 twilio注册要发送短信，我们需要现在 twilio 官网注册一个账号。 1https:&#x2F;&#x2F;www.twilio.com&#x2F; 点击 Sign Up 注册一个账号。 填写邮箱和密码等资料，提交后会有一个判断是否为机器人的验证，点击左右箭头使图案显示为正图就可以了。 再到刚才填写的邮箱中去验证下，需要填入手机号验证。 刚开始用了移动号发了两次都没有收到验证码，不知道什么原因，之后换了电信后就收到了验证码。 验证成功后会提示选择是否通过代码调用。 选择 yes 后再选择对应的语言，我们当然是选择 Python 了。 获取试用号选择使用用途后，可以就可以获取一个试用的号码了，点击 Get a Trial Number 按钮。 我们可以看到系统给我提供的这个号码。 点击确定后就会出现成功的页面，显示 Twilio 提供的号码，这个号码就是用来发送短信的。 获取号码成功后自动跳回到主页，下方有 Python 调用短信接口的示例。 进入接口调用说明后，我们看到右边直接由 Python 调用接口发短信的示例。 我们直接拿来用即可，把代码中 account_sid 和 auth_token 替换成自己的，这个两个值在刚才显示号码那个页面。 再把 message 中的 body 换成你自己的文本，把发送信息的号码换成刚官方提供的号码。 接收号验证接收号码在使用前，需要在 Twilio 上验证下，点击右侧的 verified numbers 进入，添加号码。 因为这是免费版，所以只支持一个号码，如果之前有验证号码的话，我们需要点击右侧的 X 把这个号码号码删除才能添加新的号码。 点击验证号码的按钮后，在弹出的页面选择左下方的 text you instead，也就是用短信验证码来验证新添加的号码，你要发给女朋友，当然，这个接收的号码都填女朋友的了。 填入号码后，点击验证，等待验证码。 我分别试了移动号、联通号、电信号，发现电信号和联通卡能正常收到验证码通过验证，移动号发了几次都收不到验证码，卡里是有余额的，可能是移动卡不支持这个接口，大家可以试试。 代码调试运行代码前，不要忘了把 twilio 库用 pip 命令安装下。 1pip install twilio 然后把代码中的几个值替换成自己的。 把刚才验证成功的号添加到代码中，运行代码，成功后就会收到发送的短信。 然后我们把之前的天气信息用短信发出去，当然你可以发送其他信息。这里我用之前的天气信息。 之前的代码中把微信相关的去掉，天气接口部分保留。 把其中的 key 换成自己的，具体操作详见这篇文章天气变冷了，给父母制作一个天气提醒小助手。 把刚才发送短信的内容替换成天气接口返回的信息 msg，定时操作的代码和之前一样。 运行代码后的效果如下： 同样，我还是把程序放在服务器上，第二天同一时间会继续发送当天的天气信息，我设置的是相隔 24 小时，当然，你可以改变相隔时间。 没有服务器的小伙伴可以看看腾讯云的双十一活动价了，88元一年，平时用来放放小工具，做个人网站是非常划算的。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python如何脱单（二）","slug":"Python如何脱单（二）","date":"2020-06-13T10:52:40.000Z","updated":"2020-06-13T10:53:21.524Z","comments":true,"path":"2020/06/13/Python如何脱单（二）/","link":"","permalink":"http://yoursite.com/2020/06/13/Python%E5%A6%82%E4%BD%95%E8%84%B1%E5%8D%95%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"","text":"七夕就要到了，在这个有情人终成眷属的好日子里，小安在这里给大家带来Python的小福利，在七夕利用Python制造两个人之间的甜蜜。二人世界里少不了属于两个人之间的甜言蜜语，而这些悄悄话也是记录了两个人从相识到相知再到在一起的甜蜜。 如果我们把这些甜言蜜语都收集起来，做成一个心爱的甜心，在七夕节的当天送给自己的另一半。这样既用心，而且还很甜蜜的操作，是不是很酷！说干就干，接下来，小安就带领大家，从数据的收集，再到数据的预处理，最终形成一个爱心展示，为大家制作一个七夕节的小惊喜。 ****数据的准备**** 首先，小安由于平时玩QQ比较多，所以决定以QQ来为大家做展示。这里小安怕会泄露个人的隐私，索性就以平时交流比较多的群聊天记录作为数据材料，大家只需要按照步骤来操作即可。 数据的获取，大家直接按照上图所示，找到自己的“目标”，然后右键，点击保存聊天记录即可，小安这里呢，将数据保存为txt文件，方便后续的操作。(因为小安是单身，没有mm跟我聊天，每天都是数据分析、机器学习研究和数据挖掘，所以只有技术的聊天） 保存的数据如下图所示： \\数据的处理** 数据获取完毕之后，接下来就是数据的预处理了，上面大家可以发现，数据中充斥着大量的数字、标点符号、字母等干扰因素，而我们平时都是以中文交流，所以在进行数据处理的时候，直接选择匹配中文是一个非常高效而且明智的选择。数据处理的代码如下图所示： 我们将处理好的数据放到新的文件夹里，以方便后续操作。接下来，就是定制特定爱心的时间了，我们利用的是jieba分词和WordCloud的词云制作，代码如下图所示: 产生的效果如下图所示： 到了这里，就结束了吗？No,No,No怎么可能，七夕节的礼物就要付出更多的精力！ \\在线词云做爱心** 下面小安为大家安利一个在线的词云制作，定制出更加完美的词云。在线词云制作的链接为：http://yciyun.com/，界面如下图所示： 在模板模块里，大家可以选择是心形还是其他形状。在配置里大家可以选择更改背景的颜色。最重要的是数据模块，大家需要注册，然后才能在自定义编辑里更改数值，而且由于其字体限制为3号到9号。 可能大家会想，这个多的数值要更改到什么时候为止呢，别担心，小安已经帮大家写好程序了，大家只需要运行程序中的online_wordcloud函数即可。 最后，为大家展示的经过在线词云制作的爱心图片： 大家如果想让背景透明的话，需要开通会员，大家喜欢的话，可以直接开通。将上面的爱心图制作成大幅图画，在周围点缀上两人的甜蜜照片，做成画框，这样的一副作品简直是七夕节最美的礼物了，大家赶快动手做起来吧。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python—如何脱单（一）","slug":"Python—如何脱单（一）","date":"2020-06-13T10:48:06.000Z","updated":"2020-06-13T10:50:30.909Z","comments":true,"path":"2020/06/13/Python—如何脱单（一）/","link":"","permalink":"http://yoursite.com/2020/06/13/Python%E2%80%94%E5%A6%82%E4%BD%95%E8%84%B1%E5%8D%95%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"","text":"学习一门语言最好的方式就是有项目驱动，或者说你得有目的的去学，这样你才能学的更快。作为一个小白，我的出发点就是利用Python哄女朋友开心啦。今天给大家介绍两个Python人专属的撩妹技巧。 1.用Python画玫瑰花代码： #!/usr/bin/env python # -- coding:utf-8 -- ‘’’ Created on sep 20, 2018 @author: stormwen ‘’’ import turtle # 设置初始位置 turtle.penup() turtle.left(90) turtle.fd(200) turtle.pendown() turtle.right(90) # 花蕊 turtle.fillcolor(“red”) turtle.begin_fill() turtle.circle(10, 180) turtle.circle(25, 110) turtle.left(50) turtle.circle(60, 45) turtle.circle(20, 170) turtle.right(24) turtle.fd(30) turtle.left(10) turtle.circle(30, 110) turtle.fd(20) turtle.left(40) turtle.circle(90, 70) turtle.circle(30, 150) turtle.right(30) turtle.fd(15) turtle.circle(80, 90) turtle.left(15) turtle.fd(45) turtle.right(165) turtle.fd(20) turtle.left(155) turtle.circle(150, 80) turtle.left(50) turtle.circle(150, 90) turtle.end_fill() # 花瓣1 turtle.left(150) turtle.circle(-90, 70) turtle.left(20) turtle.circle(75, 105) turtle.setheading(60) turtle.circle(80, 98) turtle.circle(-90, 40) # 花瓣2 turtle.left(180) turtle.circle(90, 40) turtle.circle(-80, 98) turtle.setheading(-83) # 叶子1 turtle.fd(30) turtle.left(90) turtle.fd(25) turtle.left(45) turtle.fillcolor(“green”) turtle.begin_fill() turtle.circle(-80, 90) turtle.right(90) turtle.circle(-80, 90) turtle.end_fill() turtle.right(135) turtle.fd(60) turtle.left(180) turtle.fd(85) turtle.left(90) turtle.fd(80) # 叶子2 turtle.right(90) turtle.right(45) turtle.fillcolor(“green”) turtle.begin_fill() turtle.circle(80, 90) turtle.left(90) turtle.circle(80, 90) turtle.end_fill() turtle.left(135) turtle.fd(60) turtle.left(180) turtle.fd(60) turtle.right(90) turtle.circle(200, 60) turtle.done() 可以根据女朋友喜欢的颜色，进行调试哦。效果展示： 2.一行代码画心：代码： #!/usr/bin/env python # -- coding:utf-8 -- #@Time :2018/9/20 1:00pm #@Author:stormwen #Software:Pycharm print(‘\\n’.join([‘’.join([(‘Miss u’[(x-y)% len(‘Miss u’)]if ((x0.05)2+(y*0.1)2-1)3-(x*0.05)2(y0.1)*3 &lt;= 0 else ‘ ‘)for xin range(-30, 30)])for yin range(30, -30, -1)])) 结果展示： 好啦，今天的Python就学到这啦，如果你有更好的图形，欢迎交流呀。 作者：叫我小包总链接：https://www.jianshu.com/p/7d7966ad4d4a来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python语法大纲(部分)","slug":"Python语法大全（部分）","date":"2020-06-13T10:41:15.000Z","updated":"2020-06-13T10:46:09.833Z","comments":true,"path":"2020/06/13/Python语法大全（部分）/","link":"","permalink":"http://yoursite.com/2020/06/13/Python%E8%AF%AD%E6%B3%95%E5%A4%A7%E5%85%A8%EF%BC%88%E9%83%A8%E5%88%86%EF%BC%89/","excerpt":"","text":"本文章包含了Python一系列基本知识，其中包括：基本数据类型（整数，浮点数，复数，字符串）；分支语句；异常处理；函数；局部变量与全局变量；递归；组合数据类型（集合，元组，列表，字典）；文件基本操作 \\基本数据类型** 一，数字类型及操作 ​ （1）整数类型 可正可负，无取值范围限制 pow（x，y）：计算x^y （2）浮点数类型 存在不确定尾数 round(x,d)：对x四舍五入，d为小数截取位数 e/E：a*10^b （3）复数类型 z=a+bj z.real=a z.imag=b 二，数值运算操作符 eg：x//y :整数除 10//3=3 x%y :求模 10%3=1 x**y=x^y 三,数值运算函数 abs(x) :绝对值 abs(-10)=10 divmod(x,y) :商余 divmod(10,3)=(3,1) pow(x,y,z) :幂余，（x**y）%z max(x1,x2,…xn) :求最大值 min(x1,x2,…xn) :求最小值 int(x) ：将x变成整数 float(x) :将x变成浮点数 comlex(x) :将x变成浮点数 四，字符串类型的表示（由一对单引号或双引号表示的字符有序序列） &lt;字符串&gt;[M:N:K], 根据步长K对字符串进行切片 特殊字符：”\\b”:回退 “\\n”:换行（光标移到下行首） “\\r”:回车（光标移到本行首 ​ 五，字符串处理函数 len(x) :长度 str(x) :任意类型x所对应的字符串形式 chr(x) :x为Unicode编码，返回其对应的字符 ord（x）：相反 六，字符串处理方法 str.lower/upper() :返回全部字符的小/大写 “ABc”.lower()=”abc” str.split(sep) :返回一个列表，由str根据sep被分割的部分组成 “A,B,C”.split(“,”)=[‘A’,’B’,’C’] str.count(sub) :返回子串sub在str出现的次数 “a apple a day”.count(a)=4 str.replace(old,new) :将所有的old子串被替换为new python”.replace(“n”,”.i”)=”pytho.i” str.center(width,char) :字符串根据宽度width居中 “python”.center(8,”=”)= ’=python=’ str.strip(chars) :从str中去掉其左侧和右侧chars列出的字符 “python”.strip(“pn”)=”ytho” str.join(iter) :在iter变量除最后元素外每个元素加一个str “,”.join(“12345”)=”1,2,3,4,5” 七，字符串类型的格式化 程序的控制结构 一，程序的分支结构 ​ （1）单分支结构： ​ if（条件）： ​ &lt;语句块&gt; ​ （2）二分支结构： ​ if（条件）： 紧凑形式： ​ &lt;语句块1&gt; &lt;表达式1&gt; if &lt;条件&gt; else &lt;表达式2&gt; ​ else: ​ &lt;语句块2&gt; ​ （3）多分支结构： ​ if（条件1）： ​ &lt;语句块1&gt; ​ elif（条件2）： ​ &lt;语句块2&gt; ​ …… ​ else: ​ &lt;语句块N&gt; 二,程序的异常处理 （1）异常处理的基本使用： try： &lt;语句块1&gt; except: &lt;语句块2&gt; （2）异常处理的高级使用： try: ​ &lt;语句块1&gt; except: ​ &lt;语句块2&gt; else: ​ &lt;语句块3&gt; #在不发生异常时执行 finally: . &lt;语句块4&gt; #一定执行 三，程序的循环结构 （1）遍历循环： ​ for &lt;循环变量&gt; in &lt;遍历结构&gt;: ​ &lt;语句块&gt; （2）无限循环： ​ while&lt;条件&gt;: ​ &lt;语句块&gt; （3）循环控制保留字 ​ break：跳出并结束当前整个循环 ​ continue：结束当次循环 函数和代码复用 一，函数的定义和使用 （1）函数的定义： ​ a， 一般函数 ​ def&lt;函数名&gt;(参数（0个或多个）): ​ &lt;函数体&gt; ​ return &lt;返回值&gt; b， lambda函数 ​ &lt;函数名&gt;=lambda&lt;参数&gt;:&lt;表达式&gt; （2）函数的返回值 ​ 函数可以返回0个或多个结果 （3）局部变量和全局变量 #1：局部变量和全局变量是不同变量。可重名；函数运算结束后，局部变量被释放；可通过global保留字在函数内使用全局变量 #2：局部变量为组合数据类型且未被创建，等于全局变量 二，代码复用和函数递归 （1）递归的定义：（数学归纳法的编程体现） ​ 链条：计算过程存在递归链条 基例：存在一个或多个不需要再次递归的基例 （2）递归的实现 函数+分支语句 组合数据类型 一，集合类型及操作 （1）集合类型的定义（多个 元素[唯一，不可更改] 的无序组合） ​ 集合用{}表示，元素间用，分隔 ​ 建立集合类型用{}或set（） （2）集合操作符 （3）集合处理方法 二，序列类型及操作 （1）元组类型： #1 元组是一种序列类型，一旦创建就不能修改 #2 使用（）或tuple（）创建，元素间用，分隔。可以使用或不使用() #3 元组继承了序列的全部操作，因为不难修改，所以没有特殊操作 （2）列表类型 #1 列表是一种序列类型，创建后可以被修改 #2 使用[ ]或list（）创建，元素间用，分隔。各元素类型可以不同 #3 列表操作： （3）字典类型（映射的体现） #1 键值对的集合，键值对之间无序 #2 采用{}和dict（）创建，键值对用：表示 #3 字典操作： 文件处理 一，文件的使用 （1）文件的打开和关闭 （2）文件内容的读取 （3）数据文件的写入","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python语法大全","slug":"Python语法大纲","date":"2020-06-13T10:41:15.000Z","updated":"2020-06-13T10:41:15.764Z","comments":true,"path":"2020/06/13/Python语法大纲/","link":"","permalink":"http://yoursite.com/2020/06/13/Python%E8%AF%AD%E6%B3%95%E5%A4%A7%E7%BA%B2/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Python 练习100例","slug":"Python-练习100例","date":"2020-06-13T10:32:00.000Z","updated":"2020-06-13T10:32:21.607Z","comments":true,"path":"2020/06/13/Python-练习100例/","link":"","permalink":"http://yoursite.com/2020/06/13/Python-%E7%BB%83%E4%B9%A0100%E4%BE%8B/","excerpt":"","text":"以下实例在Python2.7下测试通过： Python 练习实例1 Python 练习实例2 Python 练习实例3 Python 练习实例4 Python 练习实例5 Python 练习实例6 Python 练习实例7 Python 练习实例8 Python 练习实例9 Python 练习实例10 Python 练习实例11 Python 练习实例12 Python 练习实例13 Python 练习实例14 Python 练习实例15 Python 练习实例16 Python 练习实例17 Python 练习实例18 Python 练习实例19 Python 练习实例20 Python 练习实例21 Python 练习实例22 Python 练习实例23 Python 练习实例24 Python 练习实例25 Python 练习实例26 Python 练习实例27 Python 练习实例28 Python 练习实例29 Python 练习实例30 Python 练习实例31 Python 练习实例32 Python 练习实例33 Python 练习实例34 Python 练习实例35 Python 练习实例36 Python 练习实例37 Python 练习实例38 Python 练习实例39 Python 练习实例40 Python 练习实例41 Python 练习实例42 Python 练习实例43 Python 练习实例44 Python 练习实例45 Python 练习实例46 Python 练习实例47 Python 练习实例48 Python 练习实例49 Python 练习实例50 Python 练习实例51 Python 练习实例52 Python 练习实例53 Python 练习实例54 Python 练习实例55 Python 练习实例56 Python 练习实例57 Python 练习实例58 Python 练习实例59 Python 练习实例60 Python 练习实例61 Python 练习实例62 Python 练习实例63 Python 练习实例64 Python 练习实例65 Python 练习实例66 Python 练习实例67 Python 练习实例68 Python 练习实例69 Python 练习实例70 Python 练习实例71 Python 练习实例72 Python 练习实例73 Python 练习实例74 Python 练习实例75 Python 练习实例76 Python 练习实例77 Python 练习实例78 Python 练习实例79 Python 练习实例80 Python 练习实例81 Python 练习实例82 Python 练习实例83 Python 练习实例84 Python 练习实例85 Python 练习实例86 Python 练习实例87 Python 练习实例88 Python 练习实例89 Python 练习实例90 Python 练习实例91 Python 练习实例92 Python 练习实例93 Python 练习实例94 Python 练习实例95 Python 练习实例96 Python 练习实例97 Python 练习实例98 Python 练习实例99 Python 练习实例100","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python SMTP发送邮件","slug":"Python-SMTP发送邮件","date":"2020-06-13T10:30:35.000Z","updated":"2020-06-13T10:30:59.830Z","comments":true,"path":"2020/06/13/Python-SMTP发送邮件/","link":"","permalink":"http://yoursite.com/2020/06/13/Python-SMTP%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/","excerpt":"","text":"SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。 python的smtplib提供了一种很方便的途径发送电子邮件。它对smtp协议进行了简单的封装。 Python创建 SMTP 对象语法如下： 123import smtplibsmtpObj &#x3D; smtplib.SMTP( [host [, port [, local_hostname]]] ) 参数说明： host: SMTP 服务器主机。 你可以指定主机的ip地址或者域名如: runoob.com，这个是可选参数。 port: 如果你提供了 host 参数, 你需要指定 SMTP 服务使用的端口号，一般情况下 SMTP 端口号为25。 local_hostname: 如果 SMTP 在你的本机上，你只需要指定服务器地址为 localhost 即可。 Python SMTP 对象使用 sendmail 方法发送邮件，语法如下： 1SMTP.sendmail(from_addr, to_addrs, msg[, mail_options, rcpt_options]) 参数说明： from_addr: 邮件发送者地址。 to_addrs: 字符串列表，邮件发送地址。 msg: 发送消息 这里要注意一下第三个参数，msg 是字符串，表示邮件。我们知道邮件一般由标题，发信人，收件人，邮件内容，附件等构成，发送邮件的时候，要注意 msg 的格式。这个格式就是 smtp 协议中定义的格式。 实例以下执行实例需要你本机已安装了支持 SMTP 的服务，如：sendmail。 以下是一个使用 Python 发送邮件简单的实例： 实例#!/usr/bin/python # -- coding: UTF-8 -- import smtplib from email.mime.text import MIMEText from email.header import Header sender = ‘from@runoob.com’ receivers = [‘429240967@qq.com’] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 # 三个参数：第一个为文本内容，第二个 plain 设置文本格式，第三个 utf-8 设置编码 message = MIMEText(‘Python 邮件发送测试…’, ‘plain’, ‘utf-8’) message[‘From’] = Header(“菜鸟教程”, ‘utf-8’) # 发送者 message[‘To’] = Header(“测试”, ‘utf-8’) # 接收者 subject = ‘Python SMTP 邮件测试’ message[‘Subject’] = Header(subject, ‘utf-8’) try: smtpObj = smtplib.SMTP(‘localhost’) smtpObj.sendmail(sender, receivers, message.as_string()) print “邮件发送成功” except smtplib.SMTPException: print “Error: 无法发送邮件” 我们使用三个引号来设置邮件信息，标准邮件需要三个头部信息： From, To, 和 Subject ，每个信息直接使用空行分割。 我们通过实例化 smtplib 模块的 SMTP 对象 smtpObj 来连接到 SMTP 访问，并使用 sendmail 方法来发送信息。 执行以上程序，如果你本机安装 sendmail（邮件传输代理程序），就会输出： 12$ python test.py 邮件发送成功 查看我们的收件箱(一般在垃圾箱)，就可以查看到邮件信息： 如果我们本机没有 sendmail 访问，也可以使用其他邮件服务商的 SMTP 访问（QQ、网易、Google等）。 实例#!/usr/bin/python # -- coding: UTF-8 -- import smtplib from email.mime.text import MIMEText from email.header import Header # 第三方 SMTP 服务 mail_host=”smtp.XXX.com” #设置服务器 mail_user=”XXXX” #用户名 mail_pass=”XXXXXX” #口令 sender = ‘from@runoob.com’ receivers = [‘429240967@qq.com’] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 message = MIMEText(‘Python 邮件发送测试…’, ‘plain’, ‘utf-8’) message[‘From’] = Header(“菜鸟教程”, ‘utf-8’) message[‘To’] = Header(“测试”, ‘utf-8’) subject = ‘Python SMTP 邮件测试’ message[‘Subject’] = Header(subject, ‘utf-8’) try: smtpObj = smtplib.SMTP() smtpObj.connect(mail_host, 25) # 25 为 SMTP 端口号 smtpObj.login(mail_user,mail_pass) smtpObj.sendmail(sender, receivers, message.as_string()) print “邮件发送成功” except smtplib.SMTPException: print “Error: 无法发送邮件” 使用Python发送HTML格式的邮件Python发送HTML格式的邮件与发送纯文本消息的邮件不同之处就是将MIMEText中_subtype设置为html。具体代码如下： 实例#!/usr/bin/python # -- coding: UTF-8 -- import smtplib from email.mime.text import MIMEText from email.header import Header sender = ‘from@runoob.com’ receivers = [‘429240967@qq.com’] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 mail_msg = “”” Python 邮件发送测试… 这是一个链接 “”” message = MIMEText(mail_msg, ‘html’, ‘utf-8’) message[‘From’] = Header(“菜鸟教程”, ‘utf-8’) message[‘To’] = Header(“测试”, ‘utf-8’) subject = ‘Python SMTP 邮件测试’ message[‘Subject’] = Header(subject, ‘utf-8’) try: smtpObj = smtplib.SMTP(‘localhost’) smtpObj.sendmail(sender, receivers, message.as_string()) print “邮件发送成功” except smtplib.SMTPException: print “Error: 无法发送邮件” 执行以上程序，如果你本机安装sendmail，就会输出： 12$ python test.py 邮件发送成功 查看我们的收件箱(一般在垃圾箱)，就可以查看到邮件信息： Python 发送带附件的邮件发送带附件的邮件，首先要创建MIMEMultipart()实例，然后构造附件，如果有多个附件，可依次构造，最后利用smtplib.smtp发送。 实例#!/usr/bin/python # -- coding: UTF-8 -- import smtplib from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart from email.header import Header sender = ‘from@runoob.com’ receivers = [‘429240967@qq.com’] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 #创建一个带附件的实例 message = MIMEMultipart() message[‘From’] = Header(“菜鸟教程”, ‘utf-8’) message[‘To’] = Header(“测试”, ‘utf-8’) subject = ‘Python SMTP 邮件测试’ message[‘Subject’] = Header(subject, ‘utf-8’) #邮件正文内容 message.attach(MIMEText(‘这是菜鸟教程Python 邮件发送测试……’, ‘plain’, ‘utf-8’)) # 构造附件1，传送当前目录下的 test.txt 文件 att1 = MIMEText(open(‘test.txt’, ‘rb’).read(), ‘base64’, ‘utf-8’) att1[“Content-Type”] = ‘application/octet-stream’ # 这里的filename可以任意写，写什么名字，邮件中显示什么名字 att1[“Content-Disposition”] = ‘attachment; filename=”test.txt”‘ message.attach(att1) # 构造附件2，传送当前目录下的 runoob.txt 文件 att2 = MIMEText(open(‘runoob.txt’, ‘rb’).read(), ‘base64’, ‘utf-8’) att2[“Content-Type”] = ‘application/octet-stream’ att2[“Content-Disposition”] = ‘attachment; filename=”runoob.txt”‘ message.attach(att2) try: smtpObj = smtplib.SMTP(‘localhost’) smtpObj.sendmail(sender, receivers, message.as_string()) print “邮件发送成功” except smtplib.SMTPException: print “Error: 无法发送邮件” 12$ python test.py 邮件发送成功 查看我们的收件箱(一般在垃圾箱)，就可以查看到邮件信息： 在 HTML 文本中添加图片邮件的 HTML 文本中一般邮件服务商添加外链是无效的，正确添加图片的实例如下所示： 实例#!/usr/bin/python # -- coding: UTF-8 -- import smtplib from email.mime.image import MIMEImage from email.mime.multipart import MIMEMultipart from email.mime.text import MIMEText from email.header import Header sender = ‘from@runoob.com’ receivers = [‘429240967@qq.com’] # 接收邮件，可设置为你的QQ邮箱或者其他邮箱 msgRoot = MIMEMultipart(‘related’) msgRoot[‘From’] = Header(“菜鸟教程”, ‘utf-8’) msgRoot[‘To’] = Header(“测试”, ‘utf-8’) subject = ‘Python SMTP 邮件测试’ msgRoot[‘Subject’] = Header(subject, ‘utf-8’) msgAlternative = MIMEMultipart(‘alternative’) msgRoot.attach(msgAlternative) mail_msg = “”” Python 邮件发送测试… 菜鸟教程链接 图片演示： “”” msgAlternative.attach(MIMEText(mail_msg, ‘html’, ‘utf-8’)) # 指定图片为当前目录 fp = open(‘test.png’, ‘rb’) msgImage = MIMEImage(fp.read()) fp.close() # 定义图片 ID，在 HTML 文本中引用 msgImage.add_header(‘Content-ID’, ‘‘) msgRoot.attach(msgImage) try: smtpObj = smtplib.SMTP(‘localhost’) smtpObj.sendmail(sender, receivers, msgRoot.as_string()) print “邮件发送成功” except smtplib.SMTPException: print “Error: 无法发送邮件” 12$ python test.py 邮件发送成功 查看我们的收件箱(如果在垃圾箱可能需要移动到收件箱才可正常显示)，就可以查看到邮件信息： 使用第三方 SMTP 服务发送这里使用了 QQ 邮箱(你也可以使用 163，Gmail等)的 SMTP 服务，需要做以下配置： QQ 邮箱通过生成授权码来设置密码： QQ 邮箱 SMTP 服务器地址：smtp.qq.com，ssl 端口：465。 以下实例你需要修改：发件人邮箱（你的QQ邮箱），密码，收件人邮箱（可发给自己）。 QQ SMTP#!/usr/bin/python # -- coding: UTF-8 -- import smtplib from email.mime.text import MIMEText from email.utils import formataddr my_sender=’429240967@qq.com’ # 发件人邮箱账号 my_pass = ‘xxxxxxxxxx’ # 发件人邮箱密码 my_user=’429240967@qq.com’ # 收件人邮箱账号，我这边发送给自己 def mail(): ret=True try: msg=MIMEText(‘填写邮件内容’,’plain’,’utf-8’) msg[‘From’]=formataddr([“FromRunoob”,my_sender]) # 括号里的对应发件人邮箱昵称、发件人邮箱账号 msg[‘To’]=formataddr([“FK”,my_user]) # 括号里的对应收件人邮箱昵称、收件人邮箱账号 msg[‘Subject’]=”菜鸟教程发送邮件测试” # 邮件的主题，也可以说是标题 server=smtplib.SMTP_SSL(“smtp.qq.com”, 465) # 发件人邮箱中的SMTP服务器，端口是25 server.login(my_sender, my_pass) # 括号中对应的是发件人邮箱账号、邮箱密码 server.sendmail(my_sender,[my_user,],msg.as_string()) # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件 server.quit() # 关闭连接 except Exception: # 如果 try 中的语句没有执行，则会执行下面的 ret=False ret=False return ret ret=mail() if ret: print(“邮件发送成功”) else: print(“邮件发送失败”) 12$ python test.py 邮件发送成功 发送成功后，登陆收件人邮箱即可查看： 更多内容请参阅：https://docs.python.org/2/library/email-examples.html。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python 网络编程","slug":"Python-网络编程","date":"2020-06-13T10:29:04.000Z","updated":"2020-06-13T10:29:35.261Z","comments":true,"path":"2020/06/13/Python-网络编程/","link":"","permalink":"http://yoursite.com/2020/06/13/Python-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","excerpt":"","text":"Python 提供了两个级别访问的网络服务。： 低级别的网络服务支持基本的 Socket，它提供了标准的 BSD Sockets API，可以访问底层操作系统Socket接口的全部方法。 高级别的网络服务模块 SocketServer， 它提供了服务器中心类，可以简化网络服务器的开发。 什么是 Socket?Socket又称”套接字”，应用程序通常通过”套接字”向网络发出请求或者应答网络请求，使主机间或者一台计算机上的进程间可以通讯。 socket()函数Python 中，我们用 socket（）函数来创建套接字，语法格式如下： 1socket.socket([family[, type[, proto]]]) 参数 family: 套接字家族可以使AF_UNIX或者AF_INET type: 套接字类型可以根据是面向连接的还是非连接分为SOCK_STREAM或SOCK_DGRAM protocol: 一般不填默认为0. Socket 对象(内建)方法 函数 描述 服务器端套接字 s.bind() 绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。 s.listen() 开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。 s.accept() 被动接受TCP客户端连接,(阻塞式)等待连接的到来 客户端套接字 s.connect() 主动初始化TCP服务器连接，。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。 s.connect_ex() connect()函数的扩展版本,出错时返回出错码,而不是抛出异常 公共用途的套接字函数 s.recv() 接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。 s.send() 发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。 s.sendall() 完整发送TCP数据，完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。 s.recvfrom() 接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。 s.sendto() 发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。 s.close() 关闭套接字 s.getpeername() 返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。 s.getsockname() 返回套接字自己的地址。通常是一个元组(ipaddr,port) s.setsockopt(level,optname,value) 设置给定套接字选项的值。 s.getsockopt(level,optname[.buflen]) 返回套接字选项的值。 s.settimeout(timeout) 设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()） s.gettimeout() 返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。 s.fileno() 返回套接字的文件描述符。 s.setblocking(flag) 如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。 s.makefile() 创建一个与该套接字相关连的文件 简单实例服务端我们使用 socket 模块的 socket 函数来创建一个 socket 对象。socket 对象可以通过调用其他函数来设置一个 socket 服务。 现在我们可以通过调用 bind(hostname, port) 函数来指定服务的 port(端口)。 接着，我们调用 socket 对象的 accept 方法。该方法等待客户端的连接，并返回 connection 对象，表示已连接到客户端。 完整代码如下： 实例#!/usr/bin/python # -- coding: UTF-8 -- # 文件名：server.py import socket # 导入 socket 模块 s = socket.socket() # 创建 socket 对象 host = socket.gethostname() # 获取本地主机名 port = 12345 # 设置端口 s.bind((host, port)) # 绑定端口 s.listen(5) # 等待客户端连接 while True: c,addr = s.accept() # 建立客户端连接 print ‘连接地址：’, addr c.send(‘欢迎访问菜鸟教程！’) c.close() # 关闭连接 客户端接下来我们写一个简单的客户端实例连接到以上创建的服务。端口号为 12345。 socket.connect(hosname, port ) 方法打开一个 TCP 连接到主机为 hostname 端口为 port 的服务商。连接后我们就可以从服务端获取数据，记住，操作完成后需要关闭连接。 完整代码如下： 实例#!/usr/bin/python # -- coding: UTF-8 -- # 文件名：client.py import socket # 导入 socket 模块 s = socket.socket() # 创建 socket 对象 host = socket.gethostname() # 获取本地主机名 port = 12345 # 设置端口号 s.connect((host, port)) print s.recv(1024) s.close() 现在我们打开两个终端，第一个终端执行 server.py 文件： 1$ python server.py 第二个终端执行 client.py 文件： 12$ python client.py 欢迎访问菜鸟教程！ 这时我们再打开第一个终端，就会看到有以下信息输出： 1连接地址： (&#39;192.168.0.118&#39;, 62461) Python Internet 模块以下列出了 Python 网络编程的一些重要模块： 协议 功能用处 端口号 Python 模块 HTTP 网页访问 80 httplib, urllib, xmlrpclib NNTP 阅读和张贴新闻文章，俗称为”帖子” 119 nntplib FTP 文件传输 20 ftplib, urllib SMTP 发送邮件 25 smtplib POP3 接收邮件 110 poplib IMAP4 获取邮件 143 imaplib Telnet 命令行 23 telnetlib Gopher 信息查找 70 gopherlib, urllib 更多内容可以参阅官网的 Python Socket Library and Modules。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python 操作 MySQL 数据库","slug":"Python-操作-MySQL-数据库","date":"2020-06-13T10:28:09.000Z","updated":"2020-06-13T10:28:37.510Z","comments":true,"path":"2020/06/13/Python-操作-MySQL-数据库/","link":"","permalink":"http://yoursite.com/2020/06/13/Python-%E6%93%8D%E4%BD%9C-MySQL-%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"Python 标准数据库接口为 Python DB-API，Python DB-API为开发人员提供了数据库应用编程接口。 Python 数据库接口支持非常多的数据库，你可以选择适合你项目的数据库： GadFly mSQL MySQL PostgreSQL Microsoft SQL Server 2000 Informix Interbase Oracle Sybase 你可以访问Python数据库接口及API查看详细的支持数据库列表。 不同的数据库你需要下载不同的DB API模块，例如你需要访问Oracle数据库和Mysql数据，你需要下载Oracle和MySQL数据库模块。 DB-API 是一个规范. 它定义了一系列必须的对象和数据库存取方式, 以便为各种各样的底层数据库系统和多种多样的数据库接口程序提供一致的访问接口 。 Python的DB-API，为大多数的数据库实现了接口，使用它连接各数据库后，就可以用相同的方式操作各数据库。 Python DB-API使用流程： 引入 API 模块。 获取与数据库的连接。 执行SQL语句和存储过程。 关闭数据库连接。 什么是MySQLdb?MySQLdb 是用于Python链接Mysql数据库的接口，它实现了 Python 数据库 API 规范 V2.0，基于 MySQL C API 上建立的。 如何安装MySQLdb?为了用DB-API编写MySQL脚本，必须确保已经安装了MySQL。复制以下代码，并执行： 1234#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-import MySQLdb 如果执行后的输出结果如下所示，意味着你没有安装 MySQLdb 模块： 1234Traceback (most recent call last): File &quot;test.py&quot;, line 3, in &lt;module&gt; import MySQLdbImportError: No module named MySQLdb 安装MySQLdb，请访问 http://sourceforge.net/projects/mysql-python ，(Linux平台可以访问：https://pypi.python.org/pypi/MySQL-python)从这里可选择适合您的平台的安装包，分为预编译的二进制文件和源代码安装包。 如果您选择二进制文件发行版本的话，安装过程基本安装提示即可完成。如果从源代码进行安装的话，则需要切换到MySQLdb发行版本的顶级目录，并键入下列命令: 12345$ gunzip MySQL-python-1.2.2.tar.gz$ tar -xvf MySQL-python-1.2.2.tar$ cd MySQL-python-1.2.2$ python setup.py build$ python setup.py install 注意：请确保您有root权限来安装上述模块。 数据库连接连接数据库前，请先确认以下事项： 您已经创建了数据库 TESTDB. 在TESTDB数据库中您已经创建了表 EMPLOYEE EMPLOYEE表字段为 FIRST_NAME, LAST_NAME, AGE, SEX 和 INCOME。 连接数据库TESTDB使用的用户名为 “testuser” ，密码为 “test123”,你可以可以自己设定或者直接使用root用户名及其密码，Mysql数据库用户授权请使用Grant命令。 在你的机子上已经安装了 Python MySQLdb 模块。 如果您对sql语句不熟悉，可以访问我们的 SQL基础教程 实例：以下实例链接Mysql的TESTDB数据库： 123456789101112131415161718192021#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db &#x3D; MySQLdb.connect(&quot;localhost&quot;, &quot;testuser&quot;, &quot;test123&quot;, &quot;TESTDB&quot;, charset&#x3D;&#39;utf8&#39; )# 使用cursor()方法获取操作游标 cursor &#x3D; db.cursor()# 使用execute方法执行SQL语句cursor.execute(&quot;SELECT VERSION()&quot;)# 使用 fetchone() 方法获取一条数据data &#x3D; cursor.fetchone()print &quot;Database version : %s &quot; % data# 关闭数据库连接db.close() 执行以上脚本输出结果如下： 1Database version : 5.0.45 创建数据库表如果数据库连接存在我们可以使用execute()方法来为数据库创建表，如下所示创建表EMPLOYEE： 1234567891011121314151617181920212223242526#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db &#x3D; MySQLdb.connect(&quot;localhost&quot;, &quot;testuser&quot;, &quot;test123&quot;, &quot;TESTDB&quot;, charset&#x3D;&#39;utf8&#39; )# 使用cursor()方法获取操作游标 cursor &#x3D; db.cursor()# 如果数据表已经存在使用 execute() 方法删除表。cursor.execute(&quot;DROP TABLE IF EXISTS EMPLOYEE&quot;)# 创建数据表SQL语句sql &#x3D; &quot;&quot;&quot;CREATE TABLE EMPLOYEE ( FIRST_NAME CHAR(20) NOT NULL, LAST_NAME CHAR(20), AGE INT, SEX CHAR(1), INCOME FLOAT )&quot;&quot;&quot;cursor.execute(sql)# 关闭数据库连接db.close() 数据库插入操作以下实例使用执行 SQL INSERT 语句向表 EMPLOYEE 插入记录： 1234567891011121314151617181920212223242526#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db &#x3D; MySQLdb.connect(&quot;localhost&quot;, &quot;testuser&quot;, &quot;test123&quot;, &quot;TESTDB&quot;, charset&#x3D;&#39;utf8&#39; )# 使用cursor()方法获取操作游标 cursor &#x3D; db.cursor()# SQL 插入语句sql &#x3D; &quot;&quot;&quot;INSERT INTO EMPLOYEE(FIRST_NAME, LAST_NAME, AGE, SEX, INCOME) VALUES (&#39;Mac&#39;, &#39;Mohan&#39;, 20, &#39;M&#39;, 2000)&quot;&quot;&quot;try: # 执行sql语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # Rollback in case there is any error db.rollback()# 关闭数据库连接db.close() 以上例子也可以写成如下形式： 123456789101112131415161718192021222324252627#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db &#x3D; MySQLdb.connect(&quot;localhost&quot;, &quot;testuser&quot;, &quot;test123&quot;, &quot;TESTDB&quot;, charset&#x3D;&#39;utf8&#39; )# 使用cursor()方法获取操作游标 cursor &#x3D; db.cursor()# SQL 插入语句sql &#x3D; &quot;INSERT INTO EMPLOYEE(FIRST_NAME, \\ LAST_NAME, AGE, SEX, INCOME) \\ VALUES (%s, %s, %s, %s, %s )&quot; % \\ (&#39;Mac&#39;, &#39;Mohan&#39;, 20, &#39;M&#39;, 2000)try: # 执行sql语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # 发生错误时回滚 db.rollback()# 关闭数据库连接db.close() 实例：以下代码使用变量向SQL语句中传递参数: 1234567..................................user_id &#x3D; &quot;test123&quot;password &#x3D; &quot;password&quot;con.execute(&#39;insert into Login values(%s, %s)&#39; % \\ (user_id, password)).................................. 数据库查询操作Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。 fetchone(): 该方法获取下一个查询结果集。结果集是一个对象 fetchall():接收全部的返回结果行. rowcount: 这是一个只读属性，并返回执行execute()方法后影响的行数。 实例：查询EMPLOYEE表中salary（工资）字段大于1000的所有数据： 123456789101112131415161718192021222324252627282930313233#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db &#x3D; MySQLdb.connect(&quot;localhost&quot;, &quot;testuser&quot;, &quot;test123&quot;, &quot;TESTDB&quot;, charset&#x3D;&#39;utf8&#39; )# 使用cursor()方法获取操作游标 cursor &#x3D; db.cursor()# SQL 查询语句sql &#x3D; &quot;SELECT * FROM EMPLOYEE \\ WHERE INCOME &gt; %s&quot; % (1000)try: # 执行SQL语句 cursor.execute(sql) # 获取所有记录列表 results &#x3D; cursor.fetchall() for row in results: fname &#x3D; row[0] lname &#x3D; row[1] age &#x3D; row[2] sex &#x3D; row[3] income &#x3D; row[4] # 打印结果 print &quot;fname&#x3D;%s,lname&#x3D;%s,age&#x3D;%s,sex&#x3D;%s,income&#x3D;%s&quot; % \\ (fname, lname, age, sex, income )except: print &quot;Error: unable to fecth data&quot;# 关闭数据库连接db.close() 以上脚本执行结果如下： 1fname&#x3D;Mac, lname&#x3D;Mohan, age&#x3D;20, sex&#x3D;M, income&#x3D;2000 数据库更新操作更新操作用于更新数据表的的数据，以下实例将 EMPLOYEE 表中的 SEX 字段为 ‘M’ 的 AGE 字段递增 1： 123456789101112131415161718192021222324#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-import MySQLdb# 打开数据库连接db &#x3D; MySQLdb.connect(&quot;localhost&quot;, &quot;testuser&quot;, &quot;test123&quot;, &quot;TESTDB&quot;, charset&#x3D;&#39;utf8&#39; )# 使用cursor()方法获取操作游标 cursor &#x3D; db.cursor()# SQL 更新语句sql &#x3D; &quot;UPDATE EMPLOYEE SET AGE &#x3D; AGE + 1 WHERE SEX &#x3D; &#39;%c&#39;&quot; % (&#39;M&#39;)try: # 执行SQL语句 cursor.execute(sql) # 提交到数据库执行 db.commit()except: # 发生错误时回滚 db.rollback()# 关闭数据库连接db.close() 删除操作删除操作用于删除数据表中的数据，以下实例演示了删除数据表 EMPLOYEE 中 AGE 大于 20 的所有数据：#!/usr/bin/python # -*- coding: UTF-8 -*- import MySQLdb # 打开数据库连接 db = MySQLdb.connect(&quot;localhost&quot;, &quot;testuser&quot;, &quot;test123&quot;, &quot;TESTDB&quot;, charset=&#39;utf8&#39; ) # 使用cursor()方法获取操作游标 cursor = db.cursor() # SQL 删除语句 sql = &quot;DELETE FROM EMPLOYEE WHERE AGE &gt; %s&quot; % (20) try: # 执行SQL语句 cursor.execute(sql) # 提交修改 db.commit() except: # 发生错误时回滚 db.rollback() # 关闭连接 db.close()执行事务事务机制可以确保数据一致性。 事务应该具有4个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为ACID特性。 原子性（atomicity）。一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。 一致性（consistency）。事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。 隔离性（isolation）。一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 持久性（durability）。持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 Python DB API 2.0 的事务提供了两个方法 commit 或 rollback。 实例：12345678910# SQL删除记录语句sql &#x3D; &quot;DELETE FROM EMPLOYEE WHERE AGE &gt; %s&quot; % (20)try: # 执行SQL语句 cursor.execute(sql) # 向数据库提交 db.commit()except: # 发生错误时回滚 db.rollback() 对于支持事务的数据库， 在Python数据库编程中，当游标建立之时，就自动开始了一个隐形的数据库事务。 commit()方法游标的所有更新操作，rollback（）方法回滚当前游标的所有操作。每一个方法都开始了一个新的事务。 错误处理DB API中定义了一些数据库操作的错误及异常，下表列出了这些错误和异常: 异常 描述 Warning 当有严重警告时触发，例如插入数据是被截断等等。必须是 StandardError 的子类。 Error 警告以外所有其他错误类。必须是 StandardError 的子类。 InterfaceError 当有数据库接口模块本身的错误（而不是数据库的错误）发生时触发。 必须是Error的子类。 DatabaseError 和数据库有关的错误发生时触发。 必须是Error的子类。 DataError 当有数据处理时的错误发生时触发，例如：除零错误，数据超范围等等。 必须是DatabaseError的子类。 OperationalError 指非用户控制的，而是操作数据库时发生的错误。例如：连接意外断开、 数据库名未找到、事务处理失败、内存分配错误等等操作数据库是发生的错误。 必须是DatabaseError的子类。 IntegrityError 完整性相关的错误，例如外键检查失败等。必须是DatabaseError子类。 InternalError 数据库的内部错误，例如游标（cursor）失效了、事务同步失败等等。 必须是DatabaseError子类。 ProgrammingError 程序错误，例如数据表（table）没找到或已存在、SQL语句语法错误、 参数数量错误等等。必须是DatabaseError的子类。 NotSupportedError 不支持错误，指使用了数据库不支持的函数或API等。例如在连接对象上 使用.rollback()函数，然而数据库并不支持事务或者事务已关闭。 必须是DatabaseError的子类。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python CGI编程","slug":"Python-CGI编程","date":"2020-06-13T10:27:18.000Z","updated":"2020-06-13T10:27:44.943Z","comments":true,"path":"2020/06/13/Python-CGI编程/","link":"","permalink":"http://yoursite.com/2020/06/13/Python-CGI%E7%BC%96%E7%A8%8B/","excerpt":"","text":"什么是 CGI CGI 目前由 NCSA 维护，NCSA 定义 CGI 如下： CGI(Common Gateway Interface)，通用网关接口，它是一段程序，运行在服务器上如：HTTP 服务器，提供同客户端 HTML 页面的接口。 网页浏览为了更好的了解 CGI 是如何工作的，我们可以从在网页上点击一个链接或 URL 的流程： 1、使用你的浏览器访问 URL 并连接到 HTTP web 服务器。 2、Web 服务器接收到请求信息后会解析 URL，并查找访问的文件在服务器上是否存在，如果存在返回文件的内容，否则返回错误信息。 3、浏览器从服务器上接收信息，并显示接收的文件或者错误信息。 CGI 程序可以是 Python 脚本，PERL 脚本，SHELL 脚本，C 或者 C++ 程序等。 CGI架构图 Web 服务器支持及配置在你进行 CGI 编程前，确保您的 Web 服务器支持 CGI 及已经配置了 CGI 的处理程序。 Apache 支持 CGI 配置： 设置好CGI目录： 1ScriptAlias &#x2F;cgi-bin&#x2F; &#x2F;var&#x2F;www&#x2F;cgi-bin&#x2F; 所有的HTTP服务器执行 CGI 程序都保存在一个预先配置的目录。这个目录被称为 CGI 目录，并按照惯例，它被命名为 /var/www/cgi-bin 目录。 CGI 文件的扩展名为 .cgi，python 也可以使用 .py 扩展名。 默认情况下，Linux 服务器配置运行的 cgi-bin 目录中为 /var/www。 如果你想指定其他运行 CGI 脚本的目录，可以修改 httpd.conf 配置文件，如下所示： 123456&lt;Directory &quot;&#x2F;var&#x2F;www&#x2F;cgi-bin&quot;&gt; AllowOverride None Options +ExecCGI Order allow,deny Allow from all&lt;&#x2F;Directory&gt; 在 AddHandler 中添加 .py 后缀，这样我们就可以访问 .py 结尾的 python 脚本文件： 1AddHandler cgi-script .cgi .pl .py 第一个CGI程序我们使用 Python 创建第一个 CGI 程序，文件名为 hello.py，文件位于 /var/www/cgi-bin 目录中，内容如下： 1234567891011121314#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-print &quot;Content-type:text&#x2F;html&quot;print # 空行，告诉服务器结束头部print &#39;&lt;html&gt;&#39;print &#39;&lt;head&gt;&#39;print &#39;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&#39;print &#39;&lt;title&gt;Hello World - 我的第一个 CGI 程序！&lt;&#x2F;title&gt;&#39;print &#39;&lt;&#x2F;head&gt;&#39;print &#39;&lt;body&gt;&#39;print &#39;&lt;h2&gt;Hello World! 我是来自菜鸟教程的第一CGI程序&lt;&#x2F;h2&gt;&#39;print &#39;&lt;&#x2F;body&gt;&#39;print &#39;&lt;&#x2F;html&gt;&#39; 文件保存后修改 hello.py，修改文件权限为 755： 1chmod 755 hello.py 以上程序在浏览器访问 http://localhost/cgi-bin/hello.py 显示结果如下： 1Hello World! 我是来自菜鸟教程的第一CGI程序 这个的hello.py脚本是一个简单的Python脚本，脚本第一行的输出内容”Content-type:text/html”发送到浏览器并告知浏览器显示的内容类型为”text/html”。 用 print 输出一个空行用于告诉服务器结束头部信息。 HTTP头部hello.py文件内容中的” Content-type:text/html”即为HTTP头部的一部分，它会发送给浏览器告诉浏览器文件的内容类型。 HTTP头部的格式如下： 1HTTP 字段名: 字段内容 例如： 1Content-type: text&#x2F;html 以下表格介绍了CGI程序中HTTP头部经常使用的信息： 头 描述 Content-type: 请求的与实体对应的MIME信息。例如: Content-type:text/html Expires: Date 响应过期的日期和时间 Location: URL 用来重定向接收方到非请求URL的位置来完成请求或标识新的资源 Last-modified: Date 请求资源的最后修改时间 Content-length: N 请求的内容长度 Set-Cookie: String 设置Http Cookie CGI环境变量所有的CGI程序都接收以下的环境变量，这些变量在CGI程序中发挥了重要的作用： 变量名 描述 CONTENT_TYPE 这个环境变量的值指示所传递来的信息的MIME类型。目前，环境变量CONTENT_TYPE一般都是：application/x-www-form-urlencoded,他表示数据来自于HTML表单。 CONTENT_LENGTH 如果服务器与CGI程序信息的传递方式是POST，这个环境变量即使从标准输入STDIN中可以读到的有效数据的字节数。这个环境变量在读取所输入的数据时必须使用。 HTTP_COOKIE 客户机内的 COOKIE 内容。 HTTP_USER_AGENT 提供包含了版本数或其他专有数据的客户浏览器信息。 PATH_INFO 这个环境变量的值表示紧接在CGI程序名之后的其他路径信息。它常常作为CGI程序的参数出现。 QUERY_STRING 如果服务器与CGI程序信息的传递方式是GET，这个环境变量的值即使所传递的信息。这个信息经跟在CGI程序名的后面，两者中间用一个问号’?’分隔。 REMOTE_ADDR 这个环境变量的值是发送请求的客户机的IP地址，例如上面的192.168.1.67。这个值总是存在的。而且它是Web客户机需要提供给Web服务器的唯一标识，可以在CGI程序中用它来区分不同的Web客户机。 REMOTE_HOST 这个环境变量的值包含发送CGI请求的客户机的主机名。如果不支持你想查询，则无需定义此环境变量。 REQUEST_METHOD 提供脚本被调用的方法。对于使用 HTTP/1.0 协议的脚本，仅 GET 和 POST 有意义。 SCRIPT_FILENAME CGI脚本的完整路径 SCRIPT_NAME CGI脚本的的名称 SERVER_NAME 这是你的 WEB 服务器的主机名、别名或IP地址。 SERVER_SOFTWARE 这个环境变量的值包含了调用CGI程序的HTTP服务器的名称和版本号。例如，上面的值为Apache/2.2.14(Unix) 以下是一个简单的CGI脚本输出CGI的环境变量： 1234567891011121314#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-# filename:test.pyimport osprint &quot;Content-type: text&#x2F;html&quot;printprint &quot;&lt;meta charset&#x3D;\\&quot;utf-8\\&quot;&gt;&quot;print &quot;&lt;b&gt;环境变量&lt;&#x2F;b&gt;&lt;br&gt;&quot;;print &quot;&lt;ul&gt;&quot;for key in os.environ.keys(): print &quot;&lt;li&gt;&lt;span style&#x3D;&#39;color:green&#39;&gt;%30s &lt;&#x2F;span&gt; : %s &lt;&#x2F;li&gt;&quot; % (key,os.environ[key])print &quot;&lt;&#x2F;ul&gt;&quot; 将以上点保存为 test.py ,并修改文件权限为 755，执行结果如下： GET和POST方法浏览器客户端通过两种方法向服务器传递信息，这两种方法就是 GET 方法和 POST 方法。 使用GET方法传输数据GET方法发送编码后的用户信息到服务端，数据信息包含在请求页面的URL上，以”?”号分割, 如下所示： 1http:&#x2F;&#x2F;www.test.com&#x2F;cgi-bin&#x2F;hello.py?key1&#x3D;value1&amp;key2&#x3D;value2 有关 GET 请求的其他一些注释： GET 请求可被缓存 GET 请求保留在浏览器历史记录中 GET 请求可被收藏为书签 GET 请求不应在处理敏感数据时使用 GET 请求有长度限制 GET 请求只应当用于取回数据 简单的url实例：GET方法以下是一个简单的URL，使用GET方法向hello_get.py程序发送两个参数： 1&#x2F;cgi-bin&#x2F;test.py?name&#x3D;菜鸟教程&amp;url&#x3D;http:&#x2F;&#x2F;www.runoob.com 以下为hello_get.py文件的代码： 1234567891011121314151617181920212223242526#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-# filename：test.py# CGI处理模块import cgi, cgitb # 创建 FieldStorage 的实例化form &#x3D; cgi.FieldStorage() # 获取数据site_name &#x3D; form.getvalue(&#39;name&#39;)site_url &#x3D; form.getvalue(&#39;url&#39;)print &quot;Content-type:text&#x2F;html&quot;printprint &quot;&lt;html&gt;&quot;print &quot;&lt;head&gt;&quot;print &quot;&lt;meta charset&#x3D;\\&quot;utf-8\\&quot;&gt;&quot;print &quot;&lt;title&gt;菜鸟教程 CGI 测试实例&lt;&#x2F;title&gt;&quot;print &quot;&lt;&#x2F;head&gt;&quot;print &quot;&lt;body&gt;&quot;print &quot;&lt;h2&gt;%s官网：%s&lt;&#x2F;h2&gt;&quot; % (site_name, site_url)print &quot;&lt;&#x2F;body&gt;&quot;print &quot;&lt;&#x2F;html&gt;&quot; 文件保存后修改 hello_get.py，修改文件权限为 755： 1chmod 755 hello_get.py 浏览器请求输出结果： 简单的表单实例：GET方法以下是一个通过HTML的表单使用GET方法向服务器发送两个数据，提交的服务器脚本同样是hello_get.py文件，hello_get.html 代码如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;form action&#x3D;&quot;&#x2F;cgi-bin&#x2F;hello_get.py&quot; method&#x3D;&quot;get&quot;&gt;站点名称: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot;&gt; &lt;br &#x2F;&gt;站点 URL: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;url&quot; &#x2F;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 默认情况下 cgi-bin 目录只能存放脚本文件，我们将 hello_get.html 存储在 test 目录下，修改文件权限为 755： 1chmod 755 hello_get.html Gif 演示如下所示： 使用POST方法传递数据使用POST方法向服务器传递数据是更安全可靠的，像一些敏感信息如用户密码等需要使用POST传输数据。 以下同样是hello_get.py ，它也可以处理浏览器提交的POST表单数据: 123456789101112131415161718192021222324#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-# CGI处理模块import cgi, cgitb # 创建 FieldStorage 的实例化form &#x3D; cgi.FieldStorage() # 获取数据site_name &#x3D; form.getvalue(&#39;name&#39;)site_url &#x3D; form.getvalue(&#39;url&#39;)print &quot;Content-type:text&#x2F;html&quot;printprint &quot;&lt;html&gt;&quot;print &quot;&lt;head&gt;&quot;print &quot;&lt;meta charset&#x3D;\\&quot;utf-8\\&quot;&gt;&quot;print &quot;&lt;title&gt;菜鸟教程 CGI 测试实例&lt;&#x2F;title&gt;&quot;print &quot;&lt;&#x2F;head&gt;&quot;print &quot;&lt;body&gt;&quot;print &quot;&lt;h2&gt;%s官网：%s&lt;&#x2F;h2&gt;&quot; % (site_name, site_url)print &quot;&lt;&#x2F;body&gt;&quot;print &quot;&lt;&#x2F;html&gt;&quot; 以下为表单通过POST方法（method=”post”）向服务器脚本 hello_get.py 提交数据: 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;form action&#x3D;&quot;&#x2F;cgi-bin&#x2F;hello_get.py&quot; method&#x3D;&quot;post&quot;&gt;站点名称: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot;&gt; &lt;br &#x2F;&gt;站点 URL: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;url&quot; &#x2F;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; Gif 演示如下所示： 通过CGI程序传递checkbox数据checkbox用于提交一个或者多个选项数据，HTML代码如下： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;form action&#x3D;&quot;&#x2F;cgi-bin&#x2F;checkbox.py&quot; method&#x3D;&quot;POST&quot; target&#x3D;&quot;_blank&quot;&gt;&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;runoob&quot; value&#x3D;&quot;on&quot; &#x2F;&gt; 菜鸟教程&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;google&quot; value&#x3D;&quot;on&quot; &#x2F;&gt; Google&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;选择站点&quot; &#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; 以下为 checkbox.py 文件的代码： 1234567891011121314151617181920212223242526272829303132#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-# 引入 CGI 处理模块 import cgi, cgitb # 创建 FieldStorage的实例 form &#x3D; cgi.FieldStorage() # 接收字段数据if form.getvalue(&#39;google&#39;): google_flag &#x3D; &quot;是&quot;else: google_flag &#x3D; &quot;否&quot;if form.getvalue(&#39;runoob&#39;): runoob_flag &#x3D; &quot;是&quot;else: runoob_flag &#x3D; &quot;否&quot;print &quot;Content-type:text&#x2F;html&quot;printprint &quot;&lt;html&gt;&quot;print &quot;&lt;head&gt;&quot;print &quot;&lt;meta charset&#x3D;\\&quot;utf-8\\&quot;&gt;&quot;print &quot;&lt;title&gt;菜鸟教程 CGI 测试实例&lt;&#x2F;title&gt;&quot;print &quot;&lt;&#x2F;head&gt;&quot;print &quot;&lt;body&gt;&quot;print &quot;&lt;h2&gt; 菜鸟教程是否选择了 : %s&lt;&#x2F;h2&gt;&quot; % runoob_flagprint &quot;&lt;h2&gt; Google 是否选择了 : %s&lt;&#x2F;h2&gt;&quot; % google_flagprint &quot;&lt;&#x2F;body&gt;&quot;print &quot;&lt;&#x2F;html&gt;&quot; 修改 checkbox.py 权限： 1chmod 755 checkbox.py 浏览器访问 Gif 演示图： 通过CGI程序传递Radio数据Radio 只向服务器传递一个数据，HTML代码如下： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;form action&#x3D;&quot;&#x2F;cgi-bin&#x2F;radiobutton.py&quot; method&#x3D;&quot;post&quot; target&#x3D;&quot;_blank&quot;&gt;&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;site&quot; value&#x3D;&quot;runoob&quot; &#x2F;&gt; 菜鸟教程&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;site&quot; value&#x3D;&quot;google&quot; &#x2F;&gt; Google&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; radiobutton.py 脚本代码如下： 1234567891011121314151617181920212223242526#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-# 引入 CGI 处理模块 import cgi, cgitb # 创建 FieldStorage的实例 form &#x3D; cgi.FieldStorage() # 接收字段数据if form.getvalue(&#39;site&#39;): site &#x3D; form.getvalue(&#39;site&#39;)else: site &#x3D; &quot;提交数据为空&quot;print &quot;Content-type:text&#x2F;html&quot;printprint &quot;&lt;html&gt;&quot;print &quot;&lt;head&gt;&quot;print &quot;&lt;meta charset&#x3D;\\&quot;utf-8\\&quot;&gt;&quot;print &quot;&lt;title&gt;菜鸟教程 CGI 测试实例&lt;&#x2F;title&gt;&quot;print &quot;&lt;&#x2F;head&gt;&quot;print &quot;&lt;body&gt;&quot;print &quot;&lt;h2&gt; 选中的网站是 %s&lt;&#x2F;h2&gt;&quot; % siteprint &quot;&lt;&#x2F;body&gt;&quot;print &quot;&lt;&#x2F;html&gt;&quot; 修改 radiobutton.py 权限： 1chmod 755 radiobutton.py 浏览器访问 Gif 演示图： 通过CGI程序传递 Textarea 数据Textarea 向服务器传递多行数据，HTML代码如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;form action&#x3D;&quot;&#x2F;cgi-bin&#x2F;textarea.py&quot; method&#x3D;&quot;post&quot; target&#x3D;&quot;_blank&quot;&gt;&lt;textarea name&#x3D;&quot;textcontent&quot; cols&#x3D;&quot;40&quot; rows&#x3D;&quot;4&quot;&gt;在这里输入内容...&lt;&#x2F;textarea&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; textarea.py 脚本代码如下： 1234567891011121314151617181920212223242526#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-# 引入 CGI 处理模块 import cgi, cgitb # 创建 FieldStorage的实例 form &#x3D; cgi.FieldStorage() # 接收字段数据if form.getvalue(&#39;textcontent&#39;): text_content &#x3D; form.getvalue(&#39;textcontent&#39;)else: text_content &#x3D; &quot;没有内容&quot;print &quot;Content-type:text&#x2F;html&quot;printprint &quot;&lt;html&gt;&quot;print &quot;&lt;head&gt;&quot;;print &quot;&lt;meta charset&#x3D;\\&quot;utf-8\\&quot;&gt;&quot;print &quot;&lt;title&gt;菜鸟教程 CGI 测试实例&lt;&#x2F;title&gt;&quot;print &quot;&lt;&#x2F;head&gt;&quot;print &quot;&lt;body&gt;&quot;print &quot;&lt;h2&gt; 输入的内容是：%s&lt;&#x2F;h2&gt;&quot; % text_contentprint &quot;&lt;&#x2F;body&gt;&quot;print &quot;&lt;&#x2F;html&gt;&quot; 修改 textarea.py 权限： 1chmod 755 textarea.py 浏览器访问 Gif 演示图： 通过CGI程序传递下拉数据。HTML 下拉框代码如下： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;form action&#x3D;&quot;&#x2F;cgi-bin&#x2F;dropdown.py&quot; method&#x3D;&quot;post&quot; target&#x3D;&quot;_blank&quot;&gt;&lt;select name&#x3D;&quot;dropdown&quot;&gt;&lt;option value&#x3D;&quot;runoob&quot; selected&gt;菜鸟教程&lt;&#x2F;option&gt;&lt;option value&#x3D;&quot;google&quot;&gt;Google&lt;&#x2F;option&gt;&lt;&#x2F;select&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&#x2F;&gt;&lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; dropdown.py 脚本代码如下所示： 1234567891011121314151617181920212223242526#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-# 引入 CGI 处理模块 import cgi, cgitb # 创建 FieldStorage的实例 form &#x3D; cgi.FieldStorage() # 接收字段数据if form.getvalue(&#39;dropdown&#39;): dropdown_value &#x3D; form.getvalue(&#39;dropdown&#39;)else: dropdown_value &#x3D; &quot;没有内容&quot;print &quot;Content-type:text&#x2F;html&quot;printprint &quot;&lt;html&gt;&quot;print &quot;&lt;head&gt;&quot;print &quot;&lt;meta charset&#x3D;\\&quot;utf-8\\&quot;&gt;&quot;print &quot;&lt;title&gt;菜鸟教程 CGI 测试实例&lt;&#x2F;title&gt;&quot;print &quot;&lt;&#x2F;head&gt;&quot;print &quot;&lt;body&gt;&quot;print &quot;&lt;h2&gt; 选中的选项是：%s&lt;&#x2F;h2&gt;&quot; % dropdown_valueprint &quot;&lt;&#x2F;body&gt;&quot;print &quot;&lt;&#x2F;html&gt;&quot; 修改 dropdown.py 权限： 1chmod 755 dropdown.py 浏览器访问 Gif 演示图： CGI中使用Cookie在 http 协议一个很大的缺点就是不对用户身份的进行判断，这样给编程人员带来很大的不便， 而 cookie 功能的出现弥补了这个不足。 cookie 就是在客户访问脚本的同时，通过客户的浏览器，在客户硬盘上写入纪录数据 ，当下次客户访问脚本时取回数据信息，从而达到身份判别的功能，cookie 常用在身份校验中。 cookie的语法http cookie的发送是通过http头部来实现的，他早于文件的传递，头部set-cookie的语法如下： 1Set-cookie:name&#x3D;name;expires&#x3D;date;path&#x3D;path;domain&#x3D;domain;secure name=name: 需要设置cookie的值(name不能使用”;“和”,“号),有多个name值时用 “;“ 分隔，例如：name1=name1;name2=name2;name3=name3。 expires=date: cookie的有效期限,格式： expires=”Wdy,DD-Mon-YYYY HH:MM:SS” path=path: 设置cookie支持的路径,如果path是一个路径，则cookie对这个目录下的所有文件及子目录生效，例如： path=”/cgi-bin/“，如果path是一个文件，则cookie指对这个文件生效，例如：path=”/cgi-bin/cookie.cgi”。 domain=domain: 对cookie生效的域名，例如：domain=”www.runoob.com&quot; secure: 如果给出此标志，表示cookie只能通过SSL协议的https服务器来传递。 cookie的接收是通过设置环境变量HTTP_COOKIE来实现的，CGI程序可以通过检索该变量获取cookie信息。 Cookie设置Cookie的设置非常简单，cookie会在http头部单独发送。以下实例在cookie中设置了name 和 expires： 1234567891011121314151617#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-# print &#39;Content-Type: text&#x2F;html&#39;print &#39;Set-Cookie: name&#x3D;&quot;菜鸟教程&quot;;expires&#x3D;Wed, 28 Aug 2016 18:30:00 GMT&#39;printprint &quot;&quot;&quot;&lt;html&gt; &lt;head&gt; &lt;meta charset&#x3D;&quot;utf-8&quot;&gt; &lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt; &lt;&#x2F;head&gt; &lt;body&gt; &lt;h1&gt;Cookie set OK!&lt;&#x2F;h1&gt; &lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&quot;&quot;&quot; 将以上代码保存到 cookie_set.py，并修改 cookie_set.py 权限： 1chmod 755 cookie_set.py 以上实例使用了 Set-Cookie 头信息来设置Cookie信息，可选项中设置了Cookie的其他属性，如过期时间Expires，域名Domain，路径Path。这些信息设置在 “Content-type:text/html”之前。 检索Cookie信息Cookie信息检索页非常简单，Cookie信息存储在CGI的环境变量HTTP_COOKIE中，存储格式如下： 1key1&#x3D;value1;key2&#x3D;value2;key3&#x3D;value3.... 以下是一个简单的CGI检索cookie信息的程序： 1234567891011121314151617181920212223242526272829303132333435#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-# 导入模块import osimport Cookieprint &quot;Content-type: text&#x2F;html&quot;printprint &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h1&gt;读取cookie信息&lt;&#x2F;h1&gt;&quot;&quot;&quot;if &#39;HTTP_COOKIE&#39; in os.environ: cookie_string&#x3D;os.environ.get(&#39;HTTP_COOKIE&#39;) c&#x3D;Cookie.SimpleCookie() c.load(cookie_string) try: data&#x3D;c[&#39;name&#39;].value print &quot;cookie data: &quot;+data+&quot;&lt;br&gt;&quot; except KeyError: print &quot;cookie 没有设置或者已过期&lt;br&gt;&quot;print &quot;&quot;&quot;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&quot;&quot;&quot; 将以上代码保存到 cookie_get.py，并修改 cookie_get.py 权限： 1chmod 755 cookie_get.py 以上 cookie 设置颜色 Gif 如下所示： 文件上传实例HTML设置上传文件的表单需要设置 enctype 属性为 multipart/form-data，代码如下所示： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;form enctype&#x3D;&quot;multipart&#x2F;form-data&quot; action&#x3D;&quot;&#x2F;cgi-bin&#x2F;save_file.py&quot; method&#x3D;&quot;post&quot;&gt; &lt;p&gt;选中文件: &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;filename&quot; &#x2F;&gt;&lt;&#x2F;p&gt; &lt;p&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;上传&quot; &#x2F;&gt;&lt;&#x2F;p&gt; &lt;&#x2F;form&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt; save_file.py脚本文件代码如下： 12345678910111213141516171819202122232425262728293031323334#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-import cgi, osimport cgitb; cgitb.enable()form &#x3D; cgi.FieldStorage()# 获取文件名fileitem &#x3D; form[&#39;filename&#39;]# 检测文件是否上传if fileitem.filename: # 设置文件路径 fn &#x3D; os.path.basename(fileitem.filename) open(&#39;&#x2F;tmp&#x2F;&#39; + fn, &#39;wb&#39;).write(fileitem.file.read()) message &#x3D; &#39;文件 &quot;&#39; + fn + &#39;&quot; 上传成功&#39; else: message &#x3D; &#39;文件没有上传&#39; print &quot;&quot;&quot;\\Content-Type: text&#x2F;html\\n&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt; &lt;p&gt;%s&lt;&#x2F;p&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&quot;&quot;&quot; % (message,) 将以上代码保存到 save_file.py，并修改 save_file.py 权限： 1chmod 755 save_file.py 以上 cookie 设置颜色 Gif 如下所示： 如果你使用的系统是Unix/Linux，你必须替换文件分隔符，在window下只需要使用open()语句即可： 1fn &#x3D; os.path.basename(fileitem.filename.replace(&quot;\\\\&quot;, &quot;&#x2F;&quot; )) 文件下载对话框我们先在当前目录下创建 foo.txt 文件，用于程序的下载。 文件下载通过设置HTTP头信息来实现，功能代码如下： 1234567891011121314#!&#x2F;usr&#x2F;bin&#x2F;python# -*- coding: UTF-8 -*-# HTTP 头部print &quot;Content-Disposition: attachment; filename&#x3D;\\&quot;foo.txt\\&quot;&quot;;print# 打开文件fo &#x3D; open(&quot;foo.txt&quot;, &quot;rb&quot;)str &#x3D; fo.read();print str# 关闭文件fo.close()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python 正则表达式","slug":"Python-正则表达式","date":"2020-06-13T10:26:07.000Z","updated":"2020-06-13T10:26:52.173Z","comments":true,"path":"2020/06/13/Python-正则表达式/","link":"","permalink":"http://yoursite.com/2020/06/13/Python-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。 Python 自1.5版本起增加了re 模块，它提供 Perl 风格的正则表达式模式。 re 模块使 Python 语言拥有全部的正则表达式功能。 compile 函数根据一个模式字符串和可选的标志参数生成一个正则表达式对象。该对象拥有一系列方法用于正则表达式匹配和替换。 re 模块也提供了与这些方法功能完全一致的函数，这些函数使用一个模式字符串做为它们的第一个参数。 本章节主要介绍Python中常用的正则表达式处理函数。 re.match函数re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 函数语法： 1re.match(pattern, string, flags&#x3D;0) 函数参数说明： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 匹配成功re.match方法返回一个匹配的对象，否则返回None。 我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 匹配对象方法 描述 group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 实例#!/usr/bin/python # -- coding: UTF-8 -- import re print(re.match(‘www’, ‘www.runoob.com&#39;).span()) # 在起始位置匹配 print(re.match(‘com’, ‘www.runoob.com&#39;)) # 不在起始位置匹配 以上实例运行输出结果为： 12(0, 3)None 实例#!/usr/bin/python import re line = “Cats are smarter than dogs” matchObj = re.match( r’(.) are (.?) .*’, line, re.M|re.I) if matchObj: print “matchObj.group() : “, matchObj.group() print “matchObj.group(1) : “, matchObj.group(1) print “matchObj.group(2) : “, matchObj.group(2) else: print “No match!!” 以上实例执行结果如下： 123matchObj.group() : Cats are smarter than dogsmatchObj.group(1) : CatsmatchObj.group(2) : smarter re.search方法re.search 扫描整个字符串并返回第一个成功的匹配。 函数语法： 1re.search(pattern, string, flags&#x3D;0) 函数参数说明： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。 匹配成功re.search方法返回一个匹配的对象，否则返回None。 我们可以使用group(num) 或 groups() 匹配对象函数来获取匹配表达式。 匹配对象方法 描述 group(num=0) 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。 groups() 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号。 实例#!/usr/bin/python # -- coding: UTF-8 -- import re print(re.search(‘www’, ‘www.runoob.com&#39;).span()) # 在起始位置匹配 print(re.search(‘com’, ‘www.runoob.com&#39;).span()) # 不在起始位置匹配 以上实例运行输出结果为： 12(0, 3)(11, 14) 实例#!/usr/bin/python import re line = “Cats are smarter than dogs”; searchObj = re.search( r’(.) are (.?) .*’, line, re.M|re.I) if searchObj: print “searchObj.group() : “, searchObj.group() print “searchObj.group(1) : “, searchObj.group(1) print “searchObj.group(2) : “, searchObj.group(2) else: print “Nothing found!!” 以上实例执行结果如下： 123searchObj.group() : Cats are smarter than dogssearchObj.group(1) : CatssearchObj.group(2) : smarter re.match与re.search的区别re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None；而re.search匹配整个字符串，直到找到一个匹配。 实例#!/usr/bin/python import re line = “Cats are smarter than dogs”; matchObj = re.match( r’dogs’, line, re.M|re.I) if matchObj: print “match –&gt; matchObj.group() : “, matchObj.group() else: print “No match!!” matchObj = re.search( r’dogs’, line, re.M|re.I) if matchObj: print “search –&gt; searchObj.group() : “, matchObj.group() else: print “No match!!” 以上实例运行结果如下： 12No match!!search --&gt; searchObj.group() : dogs 检索和替换Python 的 re 模块提供了re.sub用于替换字符串中的匹配项。 语法： 1re.sub(pattern, repl, string, count&#x3D;0, flags&#x3D;0) 参数： pattern : 正则中的模式字符串。 repl : 替换的字符串，也可为一个函数。 string : 要被查找替换的原始字符串。 count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。 实例#!/usr/bin/python # -- coding: UTF-8 -- import re phone = “2004-959-559 # 这是一个国外电话号码” # 删除字符串中的 Python注释 num = re.sub(r’#.*$’, “”, phone) print “电话号码是: “, num # 删除非数字(-)的字符串 num = re.sub(r’\\D’, “”, phone) print “电话号码是 : “, num 以上实例执行结果如下： 12电话号码是: 2004-959-559 电话号码是 : 2004959559 repl 参数是一个函数以下实例中将字符串中的匹配的数字乘以 2： 实例#!/usr/bin/python # -- coding: UTF-8 -- import re # 将匹配的数字乘以 2 def double(matched): value = int(matched.group(‘value’)) return str(value * 2) s = ‘A23G4HFD567’ print(re.sub(‘(?P\\d+)’, double, s)) 执行输出结果为： 1A46G8HFD1134 re.compile 函数compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 语法格式为： 1re.compile(pattern[, flags]) 参数： pattern : 一个字符串形式的正则表达式 flags : 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为： re.I 忽略大小写 re.L 表示特殊字符集 \\w, \\W, \\b, \\B, \\s, \\S 依赖于当前环境 re.M 多行模式 re.S 即为 . 并且包括换行符在内的任意字符（. 不包括换行符） re.U 表示特殊字符集 \\w, \\W, \\b, \\B, \\d, \\D, \\s, \\S 依赖于 Unicode 字符属性数据库 re.X 为了增加可读性，忽略空格和 # 后面的注释 实例实例&gt;&gt;&gt;import re &gt;&gt;&gt; pattern = re.compile(r’\\d+’) # 用于匹配至少一个数字 &gt;&gt;&gt; m = pattern.match(‘one12twothree34four’) # 查找头部，没有匹配 &gt;&gt;&gt; print m None &gt;&gt;&gt; m = pattern.match(‘one12twothree34four’, 2, 10) # 从’e’的位置开始匹配，没有匹配 &gt;&gt;&gt; print m None &gt;&gt;&gt; m = pattern.match(‘one12twothree34four’, 3, 10) # 从’1’的位置开始匹配，正好匹配 &gt;&gt;&gt; print m # 返回一个 Match 对象 &lt;_sre.SRE_Match object at 0x10a42aac0&gt; &gt;&gt;&gt; m.group(0) # 可省略 0 ‘12’ &gt;&gt;&gt; m.start(0) # 可省略 0 3 &gt;&gt;&gt; m.end(0) # 可省略 0 5 &gt;&gt;&gt; m.span(0) # 可省略 0 (3, 5) 在上面，当匹配成功时返回一个 Match 对象，其中： group([group1, …]) 方法用于获得一个或多个分组匹配的字符串，当要获得整个匹配的子串时，可直接使用 group() 或 group(0)； start([group]) 方法用于获取分组匹配的子串在整个字符串中的起始位置（子串第一个字符的索引），参数默认值为 0； end([group]) 方法用于获取分组匹配的子串在整个字符串中的结束位置（子串最后一个字符的索引+1），参数默认值为 0； span([group]) 方法返回 (start(group), end(group))。 再看看一个例子： 实例&gt;&gt;&gt;import re &gt;&gt;&gt; pattern = re.compile(r’([a-z]+) ([a-z]+)’, re.I) # re.I 表示忽略大小写 &gt;&gt;&gt; m = pattern.match(‘Hello World Wide Web’) &gt;&gt;&gt; print m # 匹配成功，返回一个 Match 对象 &lt;_sre.SRE_Match object at 0x10bea83e8&gt; &gt;&gt;&gt; m.group(0) # 返回匹配成功的整个子串 ‘Hello World’ &gt;&gt;&gt; m.span(0) # 返回匹配成功的整个子串的索引 (0, 11) &gt;&gt;&gt; m.group(1) # 返回第一个分组匹配成功的子串 ‘Hello’ &gt;&gt;&gt; m.span(1) # 返回第一个分组匹配成功的子串的索引 (0, 5) &gt;&gt;&gt; m.group(2) # 返回第二个分组匹配成功的子串 ‘World’ &gt;&gt;&gt; m.span(2) # 返回第二个分组匹配成功的子串 (6, 11) &gt;&gt;&gt; m.groups() # 等价于 (m.group(1), m.group(2), …) (‘Hello’, ‘World’) &gt;&gt;&gt; m.group(3) # 不存在第三个分组 Traceback (most recent call last): File ““, line 1, in IndexError: no such group findall在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果没有找到匹配的，则返回空列表。 注意： match 和 search 是匹配一次 findall 匹配所有。 语法格式为： 1findall(string[, pos[, endpos]]) 参数： string : 待匹配的字符串。 pos : 可选参数，指定字符串的起始位置，默认为 0。 endpos : 可选参数，指定字符串的结束位置，默认为字符串的长度。 查找字符串中的所有数字： 实例# -- coding:UTF8 -- import re pattern = re.compile(r’\\d+’) # 查找数字 result1 = pattern.findall(‘runoob 123 google 456’) result2 = pattern.findall(‘run88oob123google456’, 0, 10) print(result1) print(result2) 输出结果： 12[&#39;123&#39;, &#39;456&#39;][&#39;88&#39;, &#39;12&#39;] re.finditer和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。 1re.finditer(pattern, string, flags&#x3D;0) 参数： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 实例# -- coding: UTF-8 -- import re it = re.finditer(r”\\d+”,”12a32bc43jf3”) for match in it: print (match.group() ) 输出结果： 123412 32 43 3 re.splitsplit 方法按照能够匹配的子串将字符串分割后返回列表，它的使用形式如下： 1re.split(pattern, string[, maxsplit&#x3D;0, flags&#x3D;0]) 参数： 参数 描述 pattern 匹配的正则表达式 string 要匹配的字符串。 maxsplit 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。 flags 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。参见：正则表达式修饰符 - 可选标志 实例&gt;&gt;&gt;import re &gt;&gt;&gt; re.split(‘\\W+’, ‘runoob, runoob, runoob.’) [‘runoob’, ‘runoob’, ‘runoob’, ‘’] &gt;&gt;&gt; re.split(‘(\\W+)’, ‘ runoob, runoob, runoob.’) [‘’, ‘ ‘, ‘runoob’, ‘, ‘, ‘runoob’, ‘, ‘, ‘runoob’, ‘.’, ‘’] &gt;&gt;&gt; re.split(‘\\W+’, ‘ runoob, runoob, runoob.’, 1) [‘’, ‘runoob, runoob, runoob.’] &gt;&gt;&gt; re.split(‘a*’, ‘hello world’) # 对于一个找不到匹配的字符串而言，split 不会对其作出分割 [‘hello world’] 正则表达式对象re.RegexObjectre.compile() 返回 RegexObject 对象。 re.MatchObjectgroup() 返回被 RE 匹配的字符串。 start() 返回匹配开始的位置 end() 返回匹配结束的位置 span() 返回一个元组包含匹配 (开始,结束) 的位置 正则表达式修饰符 - 可选标志正则表达式可以包含一些可选标志修饰符来控制匹配的模式。修饰符被指定为一个可选的标志。多个标志可以通过按位 OR(|) 它们来指定。如 re.I | re.M 被设置成 I 和 M 标志： 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使 . 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。 正则表达式模式模式字符串使用特殊的语法来表示一个正则表达式： 字母和数字表示他们自身。一个正则表达式模式中的字母和数字匹配同样的字符串。 多数字母和数字前加一个反斜杠时会拥有不同的含义。 标点符号只有被转义时才匹配自身，否则它们表示特殊的含义。 反斜杠本身需要使用反斜杠转义。 由于正则表达式通常都包含反斜杠，所以你最好使用原始字符串来表示它们。模式元素(如 r’\\t’，等价于 ‘\\t’)匹配相应的特殊字符。 下表列出了正则表达式模式语法中的特殊元素。如果你使用模式的同时提供了可选的标志参数，某些模式元素的含义会改变。 模式 描述 ^ 匹配字符串的开头 $ 匹配字符串的末尾。 . 匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。 […] 用来表示一组字符,单独列出：[amk] 匹配 ‘a’，’m’或’k’ [^…] 不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。 re* 匹配0个或多个的表达式。 re+ 匹配1个或多个的表达式。 re? 匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式 re{ n} 精确匹配 n 个前面表达式。例如， o{2} 不能匹配 “Bob” 中的 “o”，但是能匹配 “food” 中的两个 o。 re{ n,} 匹配 n 个前面表达式。例如， o{2,} 不能匹配”Bob”中的”o”，但能匹配 “foooood”中的所有 o。”o{1,}” 等价于 “o+”。”o{0,}” 则等价于 “o*”。 re{ n, m} 匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式 a| b 匹配a或b (re) 对正则表达式分组并记住匹配的文本 (?imx) 正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。 (?-imx) 正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。 (?: re) 类似 (…), 但是不表示一个组 (?imx: re) 在括号中使用i, m, 或 x 可选标志 (?-imx: re) 在括号中不使用i, m, 或 x 可选标志 (?#…) 注释. (?= re) 前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。 (?! re) 前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功 (?&gt; re) 匹配的独立模式，省去回溯。 \\w 匹配字母数字及下划线 \\W 匹配非字母数字及下划线 \\s 匹配任意空白字符，等价于 [\\t\\n\\r\\f]. \\S 匹配任意非空字符 \\d 匹配任意数字，等价于 [0-9]. \\D 匹配任意非数字 \\A 匹配字符串开始 \\Z 匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。 \\z 匹配字符串结束 \\G 匹配最后匹配完成的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\n, \\t, 等. 匹配一个换行符。匹配一个制表符。等 \\1…\\9 匹配第n个分组的内容。 \\10 匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。 正则表达式实例字符匹配 实例 描述 python 匹配 “python”. 字符类 实例 描述 [Pp]ython 匹配 “Python” 或 “python” rub[ye] 匹配 “ruby” 或 “rube” [aeiou] 匹配中括号内的任意一个字母 [0-9] 匹配任何数字。类似于 [0123456789] [a-z] 匹配任何小写字母 [A-Z] 匹配任何大写字母 [a-zA-Z0-9] 匹配任何字母及数字 [^aeiou] 除了aeiou字母以外的所有字符 [^0-9] 匹配除了数字外的字符 特殊字符类 实例 描述 . 匹配除 “\\n” 之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用象 ‘[.\\n]’ 的模式。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\w 匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。 \\W 匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python 内置函数","slug":"Python-内置函数","date":"2020-06-13T10:25:02.000Z","updated":"2020-06-13T10:25:41.105Z","comments":true,"path":"2020/06/13/Python-内置函数/","link":"","permalink":"http://yoursite.com/2020/06/13/Python-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/","excerpt":"","text":"Python 内置函数 内置函数 abs() divmod() input() open() staticmethod() all() enumerate() int() ord() str() any() eval() isinstance() pow() sum() basestring() execfile() issubclass() print() super() bin() file() iter() property() tuple() bool() filter() len() range() type() bytearray() float() list() raw_input() unichr() callable() format() locals() reduce() unicode() chr() frozenset() long() reload() vars() classmethod() getattr() map() repr() xrange() cmp() globals() max() reverse() zip() compile() hasattr() memoryview() round() import() complex() hash() min() set() delattr() help() next() setattr() dict() hex() object() slice() dir() id() oct() sorted() exec 内置表达式","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python面向对象（难）","slug":"python面向对象（难）","date":"2020-06-13T10:19:11.000Z","updated":"2020-06-13T10:20:54.526Z","comments":true,"path":"2020/06/13/python面向对象（难）/","link":"","permalink":"http://yoursite.com/2020/06/13/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%EF%BC%88%E9%9A%BE%EF%BC%89/","excerpt":"","text":"阅读目录 楔子 面向过程vs面向对象 初识面向对象 类的相关知识 对象的相关知识 对象之间的交互 类命名空间与对象、实例的命名空间 类的组合用法 初识面向对象小结 面向对象的三大特性 继承 多态 封装 面向对象的更多说明 面向对象的软件开发 几个概念的说明 面向对象常用术语 楔子你现在是一家游戏公司的开发人员，现在需要你开发一款叫做&lt;人狗大战&gt;的游戏，你就思考呀，人狗作战，那至少需要2个角色，一个是人， 一个是狗，且人和狗都有不同的技能，比如人拿棍打狗， 狗可以咬人，怎么描述这种不同的角色和他们的功能呢？ 你搜罗了自己掌握的所有技能，写出了下面的代码来描述这两个角色 人和狗的角色定制1 上面两个方法相当于造了两个模子，游戏里的每个人和每条狗都拥有相同里的属性。游戏开始，你根据一个人或一只狗传入的具体信息来塑造一个具体的人或者狗，怎么生成呢？ 生成具体的人和狗 两个角色对象生成了，狗和人还有不同的功能呀，狗会咬人，人会打狗，对不对? 怎么实现呢，。。想到了， 可以每个功能再写一个函数，想执行哪个功能，直接 调用 就可以了，对不？ bark和walk 调用walk和bark 上面的功能实现的简直是完美！ 但是仔细玩耍一会，你就不小心干了下面这件事 在玩耍中犯了一个小错误 事实 上，从你写的代码上来看，这并没出错。很显然，人是不能调用狗的功能的，但在你的程序例没有做限制，如何在代码级别实现这个限制呢？ 限制功能全新代码 生成具体的人和狗 无法调用了 你是如此的机智，这样就实现了限制人只能用人自己的功能啦。 刚刚你用的这种编程思想其实就是简单的面向对象编程，我们创造了两个模子表示游戏里所有的人和狗之后，剩下的狗叫或者人走对于这两个模子来说就不重要了。具体人he狗之间的交互就等着你去使用了。假如你和狗打起来了，这时候你是走路还是拿棍子打狗就由你自己决定了。那你的每一个决定可能都影响着你这场游戏的输赢。这也是不确定的。和我们之前写代码按部就班的走，最终都会实现我们要完成的事情不太一样了。 尽管如此，我们也只完成了这个游戏非常小的一部分。还有很多功能都没有实现。 刚才你只是阻止了两个完全 不同的角色 之前的功能混用， 但有没有可能 ，同一个种角色，但有些属性是不同的呢？ 比如 ，大家都打过cs吧，cs里有警察和恐怖份子，但因为都 是人， 所以你写一个角色叫 person(), 警察和恐怖份子都 可以 互相射击，但警察不可以杀人质，恐怖分子可以，这怎么实现呢？ 你想了说想，说，简单，只需要在杀人质的功能里加个判断，如果是警察，就不让杀不就ok了么。 没错， 这虽然 解决了杀人质的问题，但其实你会发现，警察和恐怖分子的区别还有很多，同时又有很多共性，如果 在每个区别处都 单独做判断，那得累死。 你想了想说， 那就直接写2个角色吧， 反正 这么多区别， 我的哥， 不能写两个角色呀，因为他们还有很多共性 ， 写两个不同的角色，就代表 相同的功能 也要重写了，是不是我的哥？ 。。。 好了， 话题就给你点到这， 再多说你的智商也理解不了了！ 面向过程 VS 面向对象面向过程的程序设计的核心是过程（流水线式思维），过程即解决问题的步骤，面向过程的设计就好比精心设计好一条流水线，考虑周全什么时候处理什么东西。 优点是：极大的降低了写程序的复杂度，只需要顺着要执行的步骤，堆叠代码即可。 缺点是：一套流水线或者流程就是用来解决一个问题，代码牵一发而动全身。 应用场景：一旦完成基本很少改变的场景，著名的例子有Linux內核，git，以及Apache HTTP Server等。 面向对象的程序设计的核心是对象（上帝式思维），要理解对象为何物，必须把自己当成上帝，上帝眼里世间存在的万物皆为对象，不存在的也可以创造出来。面向对象的程序设计好比如来设计西游记，如来要解决的问题是把经书传给东土大唐，如来想了想解决这个问题需要四个人：唐僧，沙和尚，猪八戒，孙悟空，每个人都有各自的特征和技能（这就是对象的概念，特征和技能分别对应对象的属性和方法），然而这并不好玩，于是如来又安排了一群妖魔鬼怪，为了防止师徒四人在取经路上被搞死，又安排了一群神仙保驾护航，这些都是对象。然后取经开始，师徒四人与妖魔鬼怪神仙互相缠斗着直到最后取得真经。如来根本不会管师徒四人按照什么流程去取。 面向对象的程序设计的 优点是：解决了程序的扩展性。对某一个对象单独修改，会立刻反映到整个体系中，如对游戏中一个人物参数的特征和技能修改都很容易。 缺点：可控性差，无法向面向过程的程序设计流水线式的可以很精准的预测问题的处理流程与结果，面向对象的程序一旦开始就由对象之间的交互解决问题，即便是上帝也无法预测最终结果。于是我们经常看到一个游戏人某一参数的修改极有可能导致阴霸的技能出现，一刀砍死3个人，这个游戏就失去平衡。 应用场景：需求经常变化的软件，一般需求的变化都集中在用户层，互联网应用，企业内部软件，游戏等都是面向对象的程序设计大显身手的好地方。 在python 中面向对象的程序设计并不是全部。 面向对象编程可以使程序的维护和扩展变得更简单，并且可以大大提高程序开发效率 ，另外，基于面向对象的程序可以使它人更加容易理解你的代码逻辑，从而使团队开发变得更从容。 了解一些名词：类、对象、实例、实例化 类：具有相同特征的一类事物(人、狗、老虎) 对象／实例：具体的某一个事物（隔壁阿花、楼下旺财） 实例化：类——&gt;对象的过程（这在生活中表现的不明显，我们在后面再慢慢解释） 初识类和对象python中一切皆为对象，类型的本质就是类，所以，不管你信不信，你已经使用了很长时间的类了 12345&gt;&gt;&gt; dict #类型dict就是类dict&lt;class &#39;dict&#39;&gt;&gt;&gt;&gt; d&#x3D;dict(name&#x3D;&#39;eva&#39;) #实例化&gt;&gt;&gt; d.pop(&#39;name&#39;) #向d发一条消息，执行d的方法pop&#39;eva&#39; 从上面的例子来看，字典就是一类数据结构，我一说字典你就知道是那个用{}表示，里面由k-v键值对的东西，它还具有一些增删改查的方法。但是我一说字典你能知道字典里具体存了哪些内容么？不能，所以我们说对于一个类来说，它具有相同的特征属性和方法。 而具体的{‘name’:’eva’}这个字典，它是一个字典，可以使用字典的所有方法，并且里面有了具体的值，它就是字典的一个对象。对象就是已经实实在在存在的某一个具体的个体。 再举一个其他的例子，通俗一点，比如你现在有一个动物园，你想描述这个动物园，那么动物园里的每一种动物就是一个类，老虎、天鹅、鳄鱼、熊。他们都有相同的属性，比如身高体重出生时间和品种，还有各种动作，比如鳄鱼会游泳，天鹅会飞，老虎会跑，熊会吃。 但是这些老虎熊啥的都不是具体的某一只，而是一类动物。虽然他们都有身高体重，但是你却没有办法确定这个值是多少。如果这个时候给你一只具体的老虎，而你还没死，那你就能给他量量身高称称体重，这些数值是不是就变成具体的了？那么具体的这一只老虎就是一个具体的实例，也是一个对象。不止这一只，其实每一只具体的老虎都有自己的身高体重，那么每一只老虎都是老虎类的一个对象。 在python中，用变量表示特征，用函数表示技能，因而具有相同特征和技能的一类事物就是‘类’，对象是则是这一类事物中具体的一个。 类的相关知识初识类声明 声明函数 声明类 1234class Person: #定义一个人类 role &#x3D; &#39;person&#39; #人的角色属性都是人 def walk(self): #人都可以走路，也就是有一个走路方法，也叫动态属性 print(&quot;person is walking...&quot;) 类有两种作用：属性引用和实例化属性引用（类名.属性）12345678class Person: #定义一个人类 role &#x3D; &#39;person&#39; #人的角色属性都是人 def walk(self): #人都可以走路，也就是有一个走路方法 print(&quot;person is walking...&quot;)print(Person.role) #查看人的role属性print(Person.walk) #引用人的走路方法，注意，这里不是在调用 实例化：类名加括号就是实例化，会自动触发init函数的运行，可以用它来为每个实例定制自己的特征1234567891011class Person: #定义一个人类 role &#x3D; &#39;person&#39; #人的角色属性都是人 def __init__(self,name): self.name &#x3D; name # 每一个角色都有自己的昵称; def walk(self): #人都可以走路，也就是有一个走路方法 print(&quot;person is walking...&quot;)print(Person.role) #查看人的role属性print(Person.walk) #引用人的走路方法，注意，这里不是在调用 实例化的过程就是类——&gt;对象的过程 原本我们只有一个Person类，在这个过程中，产生了一个egg对象，有自己具体的名字、攻击力和生命值。 语法：对象名 = 类名(参数) 123egg &#x3D; Person(&#39;egon&#39;) #类名()就等于在执行Person.__init__()#执行完__init__()就会返回一个对象。这个对象类似一个字典，存着属于这个人本身的一些属性和方法。#你可以偷偷的理解：egg &#x3D; &#123;&#39;name&#39;:&#39;egon&#39;,&#39;walk&#39;:walk&#125; 查看属性&amp;调用方法12print(egg.name) #查看属性直接 对象名.属性名print(egg.walk()) #调用方法，对象名.方法名() 关于selfself：在实例化时自动将对象/实例本身传给init的第一个参数，你也可以给他起个别的名字，但是正常人都不会这么做。因为你瞎改别人就不认识 类属性的补充 类属性的补充 对象的相关知识回到咱们的人狗大战：现在我们需要对我们的类做出一点点改变人类除了可以走路之外，还应该具备一些攻击技能。 123456789101112class Person: # 定义一个人类 role &#x3D; &#39;person&#39; # 人的角色属性都是人 def __init__(self, name, aggressivity, life_value): self.name &#x3D; name # 每一个角色都有自己的昵称; self.aggressivity &#x3D; aggressivity # 每一个角色都有自己的攻击力; self.life_value &#x3D; life_value # 每一个角色都有自己的生命值; def attack(self,dog): # 人可以攻击狗，这里的狗也是一个对象。 # 人攻击狗，那么狗的生命值就会根据人的攻击力而下降 dog.life_value -&#x3D; self.aggressivit 对象是关于类而实际存在的一个例子，即实例对象/实例只有一种作用：属性引用1234egg &#x3D; Person(&#39;egon&#39;,10,1000)print(egg.name)print(egg.aggressivity)print(egg.life_value) 当然了，你也可以引用一个方法，因为方法也是一个属性，只不过是一个类似函数的属性，我们也管它叫动态属性。引用动态属性并不是执行这个方法，要想调用方法和调用函数是一样的，都需要在后面加上括号 1print(egg.attack) 我知道在类里说，你可能还有好多地方不能理解。那我们就用函数来解释一下这个类呀，对象呀到底是个啥，你偷偷的用这个理解就好了，不要告诉别人 帮你了解面向对象 面向对象小结——定义及调用的固定模式 小结 练一练 对象之间的交互现在我们已经有一个人类了，通过给人类一些具体的属性我们就可以拿到一个实实在在的人。现在我们要再创建一个狗类，狗就不能打人了，只能咬人，所以我们给狗一个bite方法。有了狗类，我们还要实例化一只实实在在的狗出来。然后人和狗就可以打架了。现在我们就来让他们打一架吧！ 创建一个狗类123456789101112class Dog: # 定义一个狗类 role &#x3D; &#39;dog&#39; # 狗的角色属性都是狗 def __init__(self, name, breed, aggressivity, life_value): self.name &#x3D; name # 每一只狗都有自己的昵称; self.breed &#x3D; breed # 每一只狗都有自己的品种; self.aggressivity &#x3D; aggressivity # 每一只狗都有自己的攻击力; self.life_value &#x3D; life_value # 每一只狗都有自己的生命值; def bite(self,people): # 狗可以咬人，这里的狗也是一个对象。 # 狗咬人，那么人的生命值就会根据狗的攻击力而下降 dog.life_value -&#x3D; self.aggressivit 实例化一只实实在在的二哈1ha2 &#x3D; Dog(&#39;二愣子&#39;,&#39;哈士奇&#39;,10,1000) #创造了一只实实在在的狗ha2 交互 egon打ha2一下123print(ha2.life_value) #看看ha2的生命值egg.attack(ha2) #egg打了ha2一下print(ha2.life_value) #ha2掉了10点血 完整的代码 egon大战哈士奇 一个简单的例子帮你理解面向对象 类命名空间与对象、实例的命名空间创建一个类就会创建一个类的名称空间，用来存储类中定义的所有名字，这些名字称为类的属性 而类有两种属性：静态属性和动态属性 静态属性就是直接在类中定义的变量 动态属性就是定义在类中的方法 其中类的数据属性是共享给所有对象的1234&gt;&gt;&gt;id(egg.role)4341594072&gt;&gt;&gt;id(Person.role)4341594072 而类的动态属性是绑定到所有对象的1234&gt;&gt;&gt;egg.attack&lt;bound method Person.attack of &lt;__main__.Person object at 0x101285860&gt;&gt;&gt;&gt;&gt;Person.attack&lt;function Person.attack at 0x10127abf8&gt; 创建一个对象/实例就会创建一个对象/实例的名称空间，存放对象/实例的名字，称为对象/实例的属性 在obj.name会先从obj自己的名称空间里找name，找不到则去类中找，类也找不到就找父类…最后都找不到就抛出异常 面向对象的组合用法软件重用的重要方式除了继承之外还有另外一种方式，即：组合 组合指的是，在一个类中以另外一个类的对象作为数据属性，称为类的组合 1234567891011121314class Weapon: def prick(self, obj): # 这是该装备的主动技能,扎死对方 obj.life_value -&#x3D; 500 # 假设攻击力是500class Person: # 定义一个人类 role &#x3D; &#39;person&#39; # 人的角色属性都是人 def __init__(self, name): self.name &#x3D; name # 每一个角色都有自己的昵称; self.weapon &#x3D; Weapon() # 给角色绑定一个武器; egg &#x3D; Person(&#39;egon&#39;)egg.weapon.prick() #egg组合了一个武器的对象，可以直接egg.weapon来使用组合类中的所有方法 圆环是由两个圆组成的，圆环的面积是外面圆的面积减去内部圆的面积。圆环的周长是内部圆的周长加上外部圆的周长。这个时候，我们就首先实现一个圆形类，计算一个圆的周长和面积。然后在”环形类”中组合圆形的实例作为自己的属性来用 1234567891011121314151617181920212223242526272829303132333435363738394041from math import piclass Circle: &#39;&#39;&#39; 定义了一个圆形类； 提供计算面积(area)和周长(perimeter)的方法 &#39;&#39;&#39; def __init__(self,radius): self.radius &#x3D; radius def area(self): return pi * self.radius * self.radius def perimeter(self): return 2 * pi *self.radiuscircle &#x3D; Circle(10) #实例化一个圆area1 &#x3D; circle.area() #计算圆面积per1 &#x3D; circle.perimeter() #计算圆周长print(area1,per1) #打印圆面积和周长class Ring: &#39;&#39;&#39; 定义了一个圆环类 提供圆环的面积和周长的方法 &#39;&#39;&#39; def __init__(self,radius_outside,radius_inside): self.outsid_circle &#x3D; Circle(radius_outside) self.inside_circle &#x3D; Circle(radius_inside) def area(self): return self.outsid_circle.area() - self.inside_circle.area() def perimeter(self): return self.outsid_circle.perimeter() + self.inside_circle.perimeter()ring &#x3D; Ring(10,5) #实例化一个环形print(ring.perimeter()) #计算环形的周长print(ring.area()) #计算环形的面积 用组合的方式建立了类与组合的类之间的关系，它是一种‘有’的关系,比如教授有生日，教授教python课程 1234567891011121314151617181920212223242526272829303132class BirthDate: def __init__(self,year,month,day): self.year&#x3D;year self.month&#x3D;month self.day&#x3D;dayclass Couse: def __init__(self,name,price,period): self.name&#x3D;name self.price&#x3D;price self.period&#x3D;periodclass Teacher: def __init__(self,name,gender,birth,course): self.name&#x3D;name self.gender&#x3D;gender self.birth&#x3D;birth self.course&#x3D;course def teach(self): print(&#39;teaching&#39;)p1&#x3D;Teacher(&#39;egon&#39;,&#39;male&#39;, BirthDate(&#39;1995&#39;,&#39;1&#39;,&#39;27&#39;), Couse(&#39;python&#39;,&#39;28000&#39;,&#39;4 months&#39;) ) print(p1.birth.year,p1.birth.month,p1.birth.day) print(p1.course.name,p1.course.price,p1.course.period)&#39;&#39;&#39; 运行结果: 1 27 python 28000 4 months &#39;&#39;&#39; 当类之间有显著不同，并且较小的类是较大的类所需要的组件时，用组合比较好 初识面向对象小结定义一个人类 123456789101112class Person: # 定义一个人类 role &#x3D; &#39;person&#39; # 人的角色属性都是人 def __init__(self, name, aggressivity, life_value, money): self.name &#x3D; name # 每一个角色都有自己的昵称; self.aggressivity &#x3D; aggressivity # 每一个角色都有自己的攻击力; self.life_value &#x3D; life_value # 每一个角色都有自己的生命值; self.money &#x3D; money def attack(self,dog): # 人可以攻击狗，这里的狗也是一个对象。 # 人攻击狗，那么狗的生命值就会根据人的攻击力而下降 dog.life_value -&#x3D; self.aggressivity 定义一个狗类 12345678910111213class Dog: # 定义一个狗类 role &#x3D; &#39;dog&#39; # 狗的角色属性都是狗 def __init__(self, name, breed, aggressivity, life_value): self.name &#x3D; name # 每一只狗都有自己的昵称; self.breed &#x3D; breed # 每一只狗都有自己的品种; self.aggressivity &#x3D; aggressivity # 每一只狗都有自己的攻击力; self.life_value &#x3D; life_value # 每一只狗都有自己的生命值; def bite(self,people): # 狗可以咬人，这里的狗也是一个对象。 # 狗咬人，那么人的生命值就会根据狗的攻击力而下降 people.life_value -&#x3D; self.aggressivity 接下来，又创建一个新的兵器类。 1234567891011121314class Weapon: def __init__(self,name, price, aggrev, life_value): self.name &#x3D; name self.price &#x3D; price self.aggrev &#x3D; aggrev self.life_value &#x3D; life_value def update(self, obj): #obj就是要带这个装备的人 obj.money -&#x3D; self.price # 用这个武器的人花钱买所以对应的钱要减少 obj.aggressivity +&#x3D; self.aggrev # 带上这个装备可以让人增加攻击 obj.life_value +&#x3D; self.life_value # 带上这个装备可以让人增加生命值 def prick(self, obj): # 这是该装备的主动技能,扎死对方 obj.life_value -&#x3D; 500 # 假设攻击力是500 测试交互 12345678910111213141516lance &#x3D; Weapon(&#39;长矛&#39;,200,6,100)egg &#x3D; Person(&#39;egon&#39;,10,1000,600) #创造了一个实实在在的人eggha2 &#x3D; Dog(&#39;二愣子&#39;,&#39;哈士奇&#39;,10,1000) #创造了一只实实在在的狗ha2#egg独自力战&quot;二愣子&quot;深感吃力，决定穷毕生积蓄买一把武器if egg.money &gt; lance.price: #如果egg的钱比装备的价格多，可以买一把长矛 lance.update(egg) #egg花钱买了一个长矛防身，且自身属性得到了提高 egg.weapon &#x3D; lance #egg装备上了长矛print(egg.money,egg.life_value,egg.aggressivity)print(ha2.life_value)egg.attack(ha2) #egg打了ha2一下print(ha2.life_value)egg.weapon.prick(ha2) #发动武器技能print(ha2.life_value) #ha2不敌狡猾的人类用武器取胜，血槽空了一半 按照这种思路一点一点的设计类和对象，最终你完全可以实现一个对战类游戏。 面向对象的三大特性继承什么是继承继承是一种创建新类的方式，在python中，新建的类可以继承一个或多个父类，父类又可称为基类或超类，新建的类称为派生类或子类 python中类的继承分为：单继承和多继承 1234567891011class ParentClass1: #定义父类 passclass ParentClass2: #定义父类 passclass SubClass1(ParentClass1): #单继承，基类是ParentClass1，派生类是SubClass passclass SubClass2(ParentClass1,ParentClass2): #python支持多继承，用逗号分隔开多个继承的类 pass 查看继承 1234&gt;&gt;&gt; SubClass1.__bases__ #__base__只查看从左到右继承的第一个子类，__bases__则是查看所有继承的父类(&lt;class &#39;__main__.ParentClass1&#39;&gt;,)&gt;&gt;&gt; SubClass2.__bases__(&lt;class &#39;__main__.ParentClass1&#39;&gt;, &lt;class &#39;__main__.ParentClass2&#39;&gt;) 提示：如果没有指定基类，python的类会默认继承object类，object是所有python类的基类，它提供了一些常见方法（如str）的实现。 1234&gt;&gt;&gt; ParentClass1.__bases__(&lt;class &#39;object&#39;&gt;,)&gt;&gt;&gt; ParentClass2.__bases__(&lt;class &#39;object&#39;&gt;,) 继承与抽象（先抽象再继承）抽象即抽取类似或者说比较像的部分。 抽象分成两个层次： 1.将奥巴马和梅西这俩对象比较像的部分抽取成类； 2.将人，猪，狗这三个类比较像的部分抽取成父类。 抽象最主要的作用是划分类别（可以隔离关注点，降低复杂度） 继承：是基于抽象的结果，通过编程语言去实现它，肯定是先经历抽象这个过程，才能通过继承的方式去表达出抽象的结构。 抽象只是分析和设计的过程中，一个动作或者说一种技巧，通过抽象可以得到类 继承与重用性 使用继承来解决代码重用的例子 在开发程序的过程中，如果我们定义了一个类A，然后又想新建立另外一个类B，但是类B的大部分内容与类A的相同时 我们不可能从头开始写一个类B，这就用到了类的继承的概念。 通过继承的方式新建类B，让B继承A，B会‘遗传’A的所有属性(数据属性和函数属性)，实现代码重用 12345678910111213141516171819202122class Animal: &#39;&#39;&#39; 人和狗都是动物，所以创造一个Animal基类 &#39;&#39;&#39; def __init__(self, name, aggressivity, life_value): self.name &#x3D; name # 人和狗都有自己的昵称; self.aggressivity &#x3D; aggressivity # 人和狗都有自己的攻击力; self.life_value &#x3D; life_value # 人和狗都有自己的生命值; def eat(self): print(&#39;%s is eating&#39;%self.name)class Dog(Animal): passclass Person(Animal): passegg &#x3D; Person(&#39;egon&#39;,10,1000)ha2 &#x3D; Dog(&#39;二愣子&#39;,50,1000)egg.eat()ha2.eat() 提示：用已经有的类建立一个新的类，这样就重用了已经有的软件中的一部分设置大部分，大大生了编程工作量，这就是常说的软件重用，不仅可以重用自己的类，也可以继承别人的，比如标准库，来定制新的数据类型，这样就是大大缩短了软件开发周期，对大型软件开发来说，意义重大. 派生当然子类也可以添加自己新的属性或者在自己这里重新定义这些属性（不会影响到父类），需要注意的是，一旦重新定义了自己的属性且与父类重名，那么调用新增的属性时，就以自己为准了。 123456789101112131415161718192021222324252627282930313233343536373839class Animal: &#39;&#39;&#39; 人和狗都是动物，所以创造一个Animal基类 &#39;&#39;&#39; def __init__(self, name, aggressivity, life_value): self.name &#x3D; name # 人和狗都有自己的昵称; self.aggressivity &#x3D; aggressivity # 人和狗都有自己的攻击力; self.life_value &#x3D; life_value # 人和狗都有自己的生命值; def eat(self): print(&#39;%s is eating&#39;%self.name)class Dog(Animal): &#39;&#39;&#39; 狗类，继承Animal类 &#39;&#39;&#39; def bite(self, people): &#39;&#39;&#39; 派生：狗有咬人的技能 :param people: &#39;&#39;&#39; people.life_value -&#x3D; self.aggressivityclass Person(Animal): &#39;&#39;&#39; 人类，继承Animal &#39;&#39;&#39; def attack(self, dog): &#39;&#39;&#39; 派生：人有攻击的技能 :param dog: &#39;&#39;&#39; dog.life_value -&#x3D; self.aggressivityegg &#x3D; Person(&#39;egon&#39;,10,1000)ha2 &#x3D; Dog(&#39;二愣子&#39;,50,1000)print(ha2.life_value)print(egg.attack(ha2))print(ha2.life_value) 注意：像ha2.life_value之类的属性引用，会先从实例中找life_value然后去类中找，然后再去父类中找…直到最顶级的父类。 在子类中，新建的重名的函数属性，在编辑函数内功能的时候，有可能需要重用父类中重名的那个函数功能，应该是用调用普通函数的方式，即：类名.func()，此时就与调用普通函数无异了，因此即便是self参数也要为其传值. 在python3中，子类执行父类的方法也可以直接用super方法. 帮你了解super 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Animal: &#39;&#39;&#39; 人和狗都是动物，所以创造一个Animal基类 &#39;&#39;&#39; def __init__(self, name, aggressivity, life_value): self.name &#x3D; name # 人和狗都有自己的昵称; self.aggressivity &#x3D; aggressivity # 人和狗都有自己的攻击力; self.life_value &#x3D; life_value # 人和狗都有自己的生命值; def eat(self): print(&#39;%s is eating&#39;%self.name)class Dog(Animal): &#39;&#39;&#39; 狗类，继承Animal类 &#39;&#39;&#39; def __init__(self,name,breed,aggressivity,life_value): super().__init__(name, aggressivity, life_value) #执行父类Animal的init方法 self.breed &#x3D; breed #派生出了新的属性 def bite(self, people): &#39;&#39;&#39; 派生出了新的技能：狗有咬人的技能 :param people: &#39;&#39;&#39; people.life_value -&#x3D; self.aggressivity def eat(self): # Animal.eat(self) #super().eat() print(&#39;from Dog&#39;)class Person(Animal): &#39;&#39;&#39; 人类，继承Animal &#39;&#39;&#39; def __init__(self,name,aggressivity, life_value,money): #Animal.__init__(self, name, aggressivity, life_value) #super(Person, self).__init__(name, aggressivity, life_value) super().__init__(name,aggressivity, life_value) #执行父类的init方法 self.money &#x3D; money #派生出了新的属性 def attack(self, dog): &#39;&#39;&#39; 派生出了新的技能：人有攻击的技能 :param dog: &#39;&#39;&#39; dog.life_value -&#x3D; self.aggressivity def eat(self): #super().eat() Animal.eat(self) print(&#39;from Person&#39;)egg &#x3D; Person(&#39;egon&#39;,10,1000,600)ha2 &#x3D; Dog(&#39;二愣子&#39;,&#39;哈士奇&#39;,10,1000)print(egg.name)print(ha2.name)egg.eat() 通过继承建立了派生类与基类之间的关系，它是一种’是’的关系，比如白马是马，人是动物。 当类之间有很多相同的功能，提取这些共同的功能做成基类，用继承比较好，比如教授是老师 1234567891011121314&gt;&gt;&gt; class Teacher:... def __init__(self,name,gender):... self.name&#x3D;name... self.gender&#x3D;gender... def teach(self):... print(&#39;teaching&#39;)... &gt;&gt;&gt; &gt;&gt;&gt; class Professor(Teacher):... pass... &gt;&gt;&gt; p1&#x3D;Professor(&#39;egon&#39;,&#39;male&#39;)&gt;&gt;&gt; p1.teach()teaching 抽象类与接口类接口类继承有两种用途： 一：继承基类的方法，并且做出自己的改变或者扩展（代码重用） 二：声明某个子类兼容于某基类，定义一个接口类Interface，接口类中定义了一些接口名（就是函数名）且并未实现接口的功能，子类继承接口类，并且实现接口中的功能 12345678910111213141516171819202122232425class Alipay: &#39;&#39;&#39; 支付宝支付 &#39;&#39;&#39; def pay(self,money): print(&#39;支付宝支付了%s元&#39;%money)class Applepay: &#39;&#39;&#39; apple pay支付 &#39;&#39;&#39; def pay(self,money): print(&#39;apple pay支付了%s元&#39;%money)def pay(payment,money): &#39;&#39;&#39; 支付函数，总体负责支付 对应支付的对象和要支付的金额 &#39;&#39;&#39; payment.pay(money)p &#x3D; Alipay()pay(p,200) 开发中容易出现的问题 12345678910111213141516171819202122232425262728293031class Alipay: &#39;&#39;&#39; 支付宝支付 &#39;&#39;&#39; def pay(self,money): print(&#39;支付宝支付了%s元&#39;%money)class Applepay: &#39;&#39;&#39; apple pay支付 &#39;&#39;&#39; def pay(self,money): print(&#39;apple pay支付了%s元&#39;%money)class Wechatpay: def fuqian(self,money): &#39;&#39;&#39; 实现了pay的功能，但是名字不一样 &#39;&#39;&#39; print(&#39;微信支付了%s元&#39;%money)def pay(payment,money): &#39;&#39;&#39; 支付函数，总体负责支付 对应支付的对象和要支付的金额 &#39;&#39;&#39; payment.pay(money)p &#x3D; Wechatpay()pay(p,200) #执行会报错 接口初成：手动报异常：NotImplementedError来解决开发中遇到的问题 1234567891011class Payment: def pay(self): raise NotImplementedErrorclass Wechatpay(Payment): def fuqian(self,money): print(&#39;微信支付了%s元&#39;%money)p &#x3D; Wechatpay() #这里不报错pay(p,200) #这里报错了 借用abc模块来实现接口 12345678910111213from abc import ABCMeta,abstractmethodclass Payment(metaclass&#x3D;ABCMeta): @abstractmethod def pay(self,money): passclass Wechatpay(Payment): def fuqian(self,money): print(&#39;微信支付了%s元&#39;%money)p &#x3D; Wechatpay() #不调就报错了 实践中，继承的第一种含义意义并不很大，甚至常常是有害的。因为它使得子类与基类出现强耦合。 继承的第二种含义非常重要。它又叫“接口继承”。接口继承实质上是要求“做出一个良好的抽象，这个抽象规定了一个兼容接口，使得外部调用者无需关心具体细节，可一视同仁的处理实现了特定接口的所有对象”——这在程序设计上，叫做归一化。 归一化使得高层的外部使用者可以不加区分的处理所有接口兼容的对象集合——就好象linux的泛文件概念一样，所有东西都可以当文件处理，不必关心它是内存、磁盘、网络还是屏幕（当然，对底层设计者，当然也可以区分出“字符设备”和“块设备”，然后做出针对性的设计：细致到什么程度，视需求而定）。 12依赖倒置原则：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该应该依赖细节；细节应该依赖抽象。换言之，要针对接口编程，而不是针对实现编程 在python中根本就没有一个叫做interface的关键字，上面的代码只是看起来像接口，其实并没有起到接口的作用，子类完全可以不用去实现接口 ，如果非要去模仿接口的概念，可以借助第三方模块： http://pypi.python.org/pypi/zope.interface twisted的twisted\\internet\\interface.py里使用zope.interface 文档https://zopeinterface.readthedocs.io/en/latest/ 设计模式：https://github.com/faif/python-patterns 为何要用接口 抽象类什么是抽象类 与java一样，python也有抽象类的概念但是同样需要借助模块实现，*抽象类是一个特殊的类，它的特殊之处在于只能被继承，不能被实例化*** 为什么要有抽象类 如果说类是从一堆对象中抽取相同的内容而来的，那么抽象类就是从一堆类中抽取相同的内容而来的，内容包括数据属性和函数属性。 比如我们有香蕉的类，有苹果的类，有桃子的类，从这些类抽取相同的内容就是水果这个抽象的类，你吃水果时，要么是吃一个具体的香蕉，要么是吃一个具体的桃子。。。。。。你永远无法吃到一个叫做水果的东西。 从设计角度去看，如果类是从现实对象抽象而来的，那么抽象类就是基于类抽象而来的。 从实现角度来看，抽象类与普通类的不同之处在于：抽象类中有抽象方法，该类不能被实例化，只能被继承，且子类必须实现抽象方法。这一点与接口有点类似，但其实是不同的，即将揭晓答案 在python中实现抽象类 View Code 抽象类与接口类抽象类的本质还是类，指的是一组类的相似性，包括数据属性（如all_type）和函数属性（如read、write），而接口只强调函数属性的相似性。 抽象类是一个介于类和接口直接的一个概念，同时具备类和接口的部分特性，可以用来实现归一化设计 在python中，并没有接口类这种东西，即便不通过专门的模块定义接口，我们也应该有一些基本的概念。 1.多继承问题在继承抽象类的过程中，我们应该尽量避免多继承；而在继承接口的时候，我们反而鼓励你来多继承接口 12接口隔离原则：使用多个专门的接口，而不使用单一的总接口。即客户端不应该依赖那些不需要的接口。 2.方法的实现在抽象类中，我们可以对一些抽象方法做出基础实现；而在接口类中，任何方法都只是一种规范，具体的功能需要子类实现 钻石继承继承顺序 继承顺序 继承原理python到底是如何实现继承的，对于你定义的每一个类，python会计算出一个方法解析顺序(MRO)列表，这个MRO列表就是一个简单的所有基类的线性顺序列表，例如 12&gt;&gt;&gt; F.mro() #等同于F.__mro__[&lt;class &#39;__main__.F&#39;&gt;, &lt;class &#39;__main__.D&#39;&gt;, &lt;class &#39;__main__.B&#39;&gt;, &lt;class &#39;__main__.E&#39;&gt;, &lt;class &#39;__main__.C&#39;&gt;, &lt;class &#39;__main__.A&#39;&gt;, &lt;class &#39;object&#39;&gt;] 为了实现继承,python会在MRO列表上从左到右开始查找基类,直到找到第一个匹配这个属性的类为止。而这个MRO列表的构造是通过一个C3线性化算法来实现的。我们不去深究这个算法的数学原理,它实际上就是合并所有父类的MRO列表并遵循如下三条准则:1.子类会先于父类被检查2.多个父类会根据它们在列表中的顺序被检查3.如果对下一个类存在两个合法的选择,选择第一个父类 继承小结继承的作用123减少代码的重用提高代码可读性规范编程模式 几个名词123抽象：抽象即抽取类似或者说比较像的部分。是一个从具题到抽象的过程。继承：子类继承了父类的方法和属性派生：子类在父类方法和属性的基础上产生了新的方法和属性 抽象类与接口类123456781.多继承问题在继承抽象类的过程中，我们应该尽量避免多继承；而在继承接口的时候，我们反而鼓励你来多继承接口2.方法的实现在抽象类中，我们可以对一些抽象方法做出基础实现；而在接口类中，任何方法都只是一种规范，具体的功能需要子类实现 钻石继承12新式类：广度优先经典类：深度优先 多态多态多态指的是一类事物有多种形态 动物有多种形态：人，狗，猪 1234567891011121314151617import abcclass Animal(metaclass&#x3D;abc.ABCMeta): #同一类事物:动物 @abc.abstractmethod def talk(self): passclass People(Animal): #动物的形态之一:人 def talk(self): print(&#39;say hello&#39;)class Dog(Animal): #动物的形态之二:狗 def talk(self): print(&#39;say wangwang&#39;)class Pig(Animal): #动物的形态之三:猪 def talk(self): print(&#39;say aoao&#39;) 文件有多种形态：文本文件，可执行文件 12345678910111213import abcclass File(metaclass&#x3D;abc.ABCMeta): #同一类事物:文件 @abc.abstractmethod def click(self): passclass Text(File): #文件的形态之一:文本文件 def click(self): print(&#39;open file&#39;)class ExeFile(File): #文件的形态之二:可执行文件 def click(self): print(&#39;execute file&#39;) 多态性一 什么是多态动态绑定（在继承的背景下使用时，有时也称为多态性） 多态性是指在不考虑实例类型的情况下使用实例 12345在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息（！！！obj.func():是调用了obj的方法func，又称为向obj发送了一条消息func），不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。比如：老师.下课铃响了（），学生.下课铃响了()，老师执行的是下班操作，学生执行的是放学操作，虽然二者消息一样，但是执行的效果不同 多态性 12345678910111213peo&#x3D;People()dog&#x3D;Dog()pig&#x3D;Pig()#peo、dog、pig都是动物,只要是动物肯定有talk方法#于是我们可以不用考虑它们三者的具体是什么类型,而直接使用peo.talk()dog.talk()pig.talk()#更进一步,我们可以定义一个统一的接口来使用def func(obj): obj.talk() 鸭子类型 逗比时刻： Python崇尚鸭子类型，即‘如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子’ python程序员通常根据这种行为来编写程序。例如，如果想编写现有对象的自定义版本，可以继承该对象 也可以创建一个外观和行为像，但与它无任何关系的全新对象，后者通常用于保存程序组件的松耦合度。 例1：利用标准库中定义的各种‘与文件类似’的对象，尽管这些对象的工作方式像文件，但他们没有继承内置文件对象的方法 例2：序列类型有多种形态：字符串，列表，元组，但他们直接没有直接的继承关系 例子 封装【封装】 ​ 隐藏对象的属性和实现细节，仅对外提供公共访问方式。 【好处】 \\1. 将变化隔离； \\2. 便于使用； \\3. 提高复用性； \\4. 提高安全性； 【封装原则】 \\1. 将不需要对外提供的内容都隐藏起来； \\2. 把属性都隐藏，提供公共方法对其访问。 私有变量和私有方法在python中用双下划线开头的方式将属性隐藏起来（设置成私有的） 私有变量12345678910111213#其实这仅仅这是一种变形操作#类中所有双下划线开头的名称如__x都会自动变形成：_类名__x的形式：class A: __N&#x3D;0 #类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置成私有的如__N,会变形为_A__N def __init__(self): self.__X&#x3D;10 #变形为self._A__X def __foo(self): #变形为_A__foo print(&#39;from A&#39;) def bar(self): self.__foo() #只有在类内部才可以通过__foo的形式访问到.#A._A__N是可以访问到的，即这种操作并不是严格意义上的限制外部访问，仅仅只是一种语法意义上的变形 这种自动变形的特点： 1.类中定义的**x只能在内部使用，如self.x，*\\*引用的就是变形的结果**\\。** \\2.这种变形其实正是针对外部的变形\\*，在外部是无法通过__x这个名字访问到的。*** 3.在子类定义的__x不会覆盖在\\父类定义的x，因为子类中变形成了：_子类名x,而父类中变形成了：_父类名__x，即双下滑线开头的属性在继承给子类时，子类是无法覆盖的。**** 这种变形需要注意的问题是： 1.这种机制也并没有真正意义上限制我们从外部直接访问属性，知道了类名和属性名就可以拼出名字：_类名属性，然后就可以访问了，如a._AN 2.变形的过程只在类的内部生效,在定义后的赋值操作，不会变形 私有方法3.在继承中，父类如果不想让子类覆盖自己的方法，可以将方法定义为私有的 123456789101112131415161718192021222324252627282930#正常情况&gt;&gt;&gt; class A:... def fa(self):... print(&#39;from A&#39;)... def test(self):... self.fa()... &gt;&gt;&gt; class B(A):... def fa(self):... print(&#39;from B&#39;)... &gt;&gt;&gt; b&#x3D;B()&gt;&gt;&gt; b.test()from B #把fa定义成私有的，即__fa&gt;&gt;&gt; class A:... def __fa(self): #在定义时就变形为_A__fa... print(&#39;from A&#39;)... def test(self):... self.__fa() #只会与自己所在的类为准,即调用_A__fa... &gt;&gt;&gt; class B(A):... def __fa(self):... print(&#39;from B&#39;)... &gt;&gt;&gt; b&#x3D;B()&gt;&gt;&gt; b.test()from A 封装与扩展性封装在于明确区分内外，使得类实现者可以修改封装内的东西而不影响外部调用者的代码；而外部使用用者只知道一个接口(函数)，只要接口（函数）名、参数不变，使用者的代码永远无需改变。这就提供一个良好的合作基础——或者说，只要接口这个基础约定不变，则代码改变不足为虑。 12345678910111213141516171819202122232425262728293031#类的设计者class Room: def __init__(self,name,owner,width,length,high): self.name&#x3D;name self.owner&#x3D;owner self.__width&#x3D;width self.__length&#x3D;length self.__high&#x3D;high def tell_area(self): #对外提供的接口，隐藏了内部的实现细节，此时我们想求的是面积 return self.__width * self.__length#使用者&gt;&gt;&gt; r1&#x3D;Room(&#39;卧室&#39;,&#39;egon&#39;,20,20,20)&gt;&gt;&gt; r1.tell_area() #使用者调用接口tell_area#类的设计者，轻松的扩展了功能，而类的使用者完全不需要改变自己的代码class Room: def __init__(self,name,owner,width,length,high): self.name&#x3D;name self.owner&#x3D;owner self.__width&#x3D;width self.__length&#x3D;length self.__high&#x3D;high def tell_area(self): #对外提供的接口，隐藏内部实现，此时我们想求的是体积,内部逻辑变了,只需求修该下列一行就可以很简答的实现,而且外部调用感知不到,仍然使用该方法，但是功能已经变了 return self.__width * self.__length * self.__high#对于仍然在使用tell_area接口的人来说，根本无需改动自己的代码，就可以用上新功能&gt;&gt;&gt; r1.tell_area() property属性什么是特性property property是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值 例一 View Code 例二：圆的周长和面积 123456#注意：此时的特性area和perimeter不能被赋值c.area&#x3D;3 #为特性area赋值&#39;&#39;&#39;抛出异常:AttributeError: can&#39;t set attribute&#39;&#39;&#39; 为什么要用property 将一个类的函数定义成特性以后，对象再去使用的时候obj.name,根本无法察觉自己的name是执行了一个函数然后计算出来的，这种特性的使用方式遵循了统一访问的原则 除此之外，看下 1234567ps：面向对象的封装有三种方式:【public】这种其实就是不封装,是对外公开的【protected】这种封装方式对外不公开,但对朋友(friend)或者子类(形象的说法是“儿子”,但我不知道为什么大家 不说“女儿”,就像“parent”本来是“父母”的意思,但中文都是叫“父类”)公开【private】这种封装对谁都不公开 python并没有在语法上把它们三个内建到自己的class机制中，在C++里一般会将所有的所有的数据都设置为私有的，然后提供set和get方法（接口）去设置和获取，在python中通过property方法可以实现 12345678910111213141516171819202122class Foo: def __init__(self,val): self.__NAME&#x3D;val #将所有的数据属性都隐藏起来 @property def name(self): return self.__NAME #obj.name访问的是self.__NAME(这也是真实值的存放位置) @name.setter def name(self,value): if not isinstance(value,str): #在设定值之前进行类型检查 raise TypeError(&#39;%s must be str&#39; %value) self.__NAME&#x3D;value #通过类型检查后,将值value存放到真实的位置self.__NAME @name.deleter def name(self): raise TypeError(&#39;Can not delete&#39;)f&#x3D;Foo(&#39;egon&#39;)print(f.name)# f.name&#x3D;10 #抛出异常&#39;TypeError: 10 must be str&#39;del f.name #抛出异常&#39;TypeError: Can not delete&#39; 一个静态属性property本质就是实现了get，set，delete三种方法 View Code View Code 怎么用？ 12345678910111213141516171819202122232425262728class Goods: def __init__(self): # 原价 self.original_price &#x3D; 100 # 折扣 self.discount &#x3D; 0.8 @property def price(self): # 实际价格 &#x3D; 原价 * 折扣 new_price &#x3D; self.original_price * self.discount return new_price @price.setter def price(self, value): self.original_price &#x3D; value @price.deleter def price(self): del self.original_priceobj &#x3D; Goods()obj.price # 获取商品价格obj.price &#x3D; 200 # 修改商品原价print(obj.price)del obj.price # 删除商品原价 classmethod1234567class Classmethod_Demo(): role &#x3D; &#39;dog&#39; @classmethod def func(cls): print(cls.role)Classmethod_Demo.func() staticmethod1234567class Staticmethod_Demo(): role &#x3D; &#39;dog&#39; @staticmethod def func(): print(&quot;当普通方法用&quot;)Staticmethod_Demo.func() 面向对象的更多说明面向对象的软件开发很多人在学完了python的class机制之后，遇到一个生产中的问题，还是会懵逼，这其实太正常了，因为任何程序的开发都是先设计后编程，python的class机制只不过是一种编程方式，如果你硬要拿着class去和你的问题死磕，变得更加懵逼都是分分钟的事，在以前，软件的开发相对简单，从任务的分析到编写程序，再到程序的调试，可以由一个人或一个小组去完成。但是随着软件规模的迅速增大，软件任意面临的问题十分复杂，需要考虑的因素太多，在一个软件中所产生的错误和隐藏的错误、未知的错误可能达到惊人的程度，这也不是在设计阶段就完全解决的。 所以软件的开发其实一整套规范，我们所学的只是其中的一小部分，一个完整的开发过程，需要明确每个阶段的任务，在保证一个阶段正确的前提下再进行下一个阶段的工作，称之为软件工程 面向对象的软件工程包括下面几个部： 1.面向对象分析（object oriented analysis ，OOA） 软件工程中的系统分析阶段，要求分析员和用户结合在一起，对用户的需求做出精确的分析和明确的表述，从大的方面解析软件系统应该做什么，而不是怎么去做。面向对象的分析要按照面向对象的概念和方法，在对任务的分析中，从客观存在的事物和事物之间的关系，贵南出有关的对象（对象的‘特征’和‘技能’）以及对象之间的联系，并将具有相同属性和行为的对象用一个类class来标识。 建立一个能反映这是工作情况的需求模型，此时的模型是粗略的。 2 面向对象设计（object oriented design，OOD） 根据面向对象分析阶段形成的需求模型，对每一部分分别进行具体的设计。 首先是类的设计，类的设计可能包含多个层次（利用继承与派生机制）。然后以这些类为基础提出程序设计的思路和方法，包括对算法的设计。 在设计阶段并不牵涉任何一门具体的计算机语言，而是用一种更通用的描述工具（如伪代码或流程图）来描述 3 面向对象编程（object oriented programming，OOP） 根据面向对象设计的结果，选择一种计算机语言把它写成程序，可以是python 4 面向对象测试（object oriented test，OOT） 在写好程序后交给用户使用前，必须对程序进行严格的测试，测试的目的是发现程序中的错误并修正它。 面向对的测试是用面向对象的方法进行测试，以类作为测试的基本单元。 5 面向对象维护（object oriendted soft maintenance，OOSM） 正如对任何产品都需要进行售后服务和维护一样，软件在使用时也会出现一些问题，或者软件商想改进软件的性能，这就需要修改程序。 由于使用了面向对象的方法开发程序，使用程序的维护比较容易。 因为对象的封装性，修改一个对象对其他的对象影响很小，利用面向对象的方法维护程序，大大提高了软件维护的效率，可扩展性高。 在面向对象方法中，最早发展的肯定是面向对象编程(OOP),那时OOA和OOD都还没有发展起来，因此程序设计者为了写出面向对象的程序，还必须深入到分析和设计领域，尤其是设计领域，那时的OOP实际上包含了现在的OOD和OOP两个阶段，这对程序设计者要求比较高，许多人感到很难掌握。 现在设计一个大的软件，是严格按照面向对象软件工程的5个阶段进行的，这个5个阶段的工作不是由一个人从头到尾完成的，而是由不同的人分别完成，这样OOP阶段的任务就比较简单了。程序编写者只需要根据OOd提出的思路，用面向对象语言编写出程序既可。 在一个大型软件开发过程中，OOP只是很小的一个部分。 对于全栈开发的你来说，这五个阶段都有了，对于简单的问题，不必严格按照这个5个阶段进行，往往由程序设计者按照面向对象的方法进行程序设计，包括类的设计和程序的设计 几个概念的说明1.面向对象的程序设计看起来高大上，所以我在编程时就应该保证通篇class，这样写出的程序一定是好的程序（面向对象只适合那些可扩展性要求比较高的场景） 2.很多人喜欢说面向对象三大特性（这是从哪传出来的，封装，多态，继承？漏洞太多太多，好吧暂且称为三大特性），那么我在基于面向对象编程时，我一定要让我定义的类中完整的包含这三种特性，这样写肯定是好的程序 好家伙，我说降龙十八掌有十八掌，那么你每次跟人干仗都要从第一掌打到第18掌这才显得你会了是么：面对敌人，你打到第三掌对方就已经倒下了，你说，不行，你给老子起来，老子还没有show完… 3.类有类属性，实例有实例属性，所以我们在定义class时一定要定义出那么几个类属性，想不到怎么办，那就使劲的想，定义的越多越牛逼 这就犯了一个严重的错误，程序越早面向对象，死的越早，为啥面向对象，因为我们要将数据与功能结合到一起，程序整体的结构都没有出来，或者说需要考虑的问题你都没有搞清楚个八九不离十，你就开始面向对象了，这就导致了，你在那里干想，自以为想通了，定义了一堆属性，结果后来又都用不到，或者想不通到底应该定义啥，那就一直想吧，想着想着就疯了。 你见过哪家公司要开发一个软件，上来就开始写，肯定是频繁的开会讨论计划，请看第八节。 面向对象常用术语抽象/实现 抽象指对现实世界问题和实体的本质表现,行为和特征建模,建立一个相关的子集,可以用于 绘程序结构,从而实现这种模型。抽象不仅包括这种模型的数据属性,还定义了这些数据的接口。 对某种抽象的实现就是对此数据及与之相关接口的现实化(realization)。现实化这个过程对于客户 程序应当是透明而且无关的。 封装/接口 封装描述了对数据/信息进行隐藏的观念,它对数据属性提供接口和访问函数。通过任何客户端直接对数据的访问,无视接口,与封装性都是背道而驰的,除非程序员允许这些操作。作为实现的 一部分,客户端根本就不需要知道在封装之后,数据属性是如何组织的。在Python中,所有的类属性都是公开的,但名字可能被“混淆”了,以阻止未经授权的访问,但仅此而已,再没有其他预防措施了。这就需要在设计时,对数据提供相应的接口,以免客户程序通过不规范的操作来存取封装的数据属性。 注意：封装绝不是等于“把不想让别人看到、以后可能修改的东西用private隐藏起来” 真正的封装是，经过深入的思考，做出良好的抽象，给出“完整且最小”的接口，并使得内部细节可以对外透明 （注意：对外透明的意思是，外部调用者可以顺利的得到自己想要的任何功能，完全意识不到内部细节的存在） 合成 合成扩充了对类的 述,使得多个不同的类合成为一个大的类,来解决现实问题。合成 述了 一个异常复杂的系统,比如一个类由其它类组成,更小的组件也可能是其它的类,数据属性及行为, 所有这些合在一起,彼此是“有一个”的关系。 派生/继承/继承结构 派生描述了子类衍生出新的特性,新类保留已存类类型中所有需要的数据和行为,但允许修改或者其它的自定义操作,都不会修改原类的定义。继承描述了子类属性从祖先类继承这样一种方式继承结构表示多“代”派生,可以述成一个“族谱”,连续的子类,与祖先类都有关系。 泛化/特化 基于继承泛化表示所有子类与其父类及祖先类有一样的特点。特化描述所有子类的自定义,也就是,什么属性让它与其祖先类不同。 多态与多态性 多态指的是同一种事物的多种状态：水这种事物有多种不同的状态：冰，水蒸气 多态性的概念指出了对象如何通过他们共同的属性和动作来操作及访问,而不需考虑他们具体的类。 冰，水蒸气，都继承于水，它们都有一个同名的方法就是变成云，但是冰.变云(),与水蒸气.变云()是截然不同的过程，虽然调用的方法都一样 自省/反射 自省也称作反射，这个性质展示了某对象是如何在运行期取得自身信息的。如果传一个对象给你,你可以查出它有什么能力,这是一项强大的特性。如果Python不支持某种形式的自省功能,dir和type内建函数,将很难正常工作。还有那些特殊属性,像dict,name及doc","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python函数","slug":"python函数","date":"2020-06-13T10:17:51.000Z","updated":"2020-06-13T10:18:22.288Z","comments":true,"path":"2020/06/13/python函数/","link":"","permalink":"http://yoursite.com/2020/06/13/python%E5%87%BD%E6%95%B0/","excerpt":"","text":"Python 中函数的应用非常广泛，前面章节中我们已经接触过多个函数，比如 input() 、print()、range()、len() 函数等等，这些都是 Python 的内置函数，可以直接使用。 除了可以直接使用的内置函数外，Python 还支持自定义函数，即将一段有规律的、可重复使用的代码定义成函数，从而达到一次编写、多次调用的目的。 举个例子，前面学习了 len() 函数，通过它我们可以直接获得一个字符串的长度。我们不妨设想一下，如果没有 len() 函数，要想获取一个字符串的长度，该如何实现呢？请看下面的代码： 1n&#x3D;0for c in &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot;: n &#x3D; n + 1print(n) 程序执行结果为： 30 要知道，获取一个字符串长度是常用的功能，一个程序中就可能用到很多次，如果每次都写这样一段重复的代码，不但费时费力、容易出错，而且交给别人时也很麻烦。 所以 Python 提供了一个功能，即允许我们将常用的代码以固定的格式封装（包装）成一个独立的模块，只要知道这个模块的名字就可以重复使用它，这个模块就叫做函数（Function）。 比如，在程序中定义了一段代码，这段代码用于实现一个特定的功能。问题来了，如果下次需要实现同样的功能，难道要把前面定义的代码复制一次？如果这样做实在太傻了，这意味着每次当程序需要实现该功能时，都要将前面定义的代码复制一次。正确的做法是，将实现特定功能的代码定义成一个函数，每次当程序需要实现该功能时，只要执行（调用）该函数即可。 其实，函数的本质就是一段有特定功能、可以重复使用的代码，这段代码已经被提前编写好了，并且为其起一个“好听”的名字。在后续编写程序过程中，如果需要同样的功能，直接通过起好的名字就可以调用这段代码。 下面演示了如何将我们自己实现的 len() 函数封装成一个函数： 1#自定义 len() 函数def my_len(str): length &#x3D; 0 for c in str: length &#x3D; length + 1 return length#调用自定义的 my_len() 函数length &#x3D; my_len(&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&#x2F;&quot;)print(length)#再次调用 my_len() 函数length &#x3D; my_len(&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;shell&#x2F;&quot;)print(length) 程序执行结果为： 3029 如果读者接触过其他编程语言中的函数，以上对于函数的描述，肯定不会陌生。但需要注意的一点是，和其他编程语言中函数相同的是，Python 函数支持接收多个（ ≥0 ）参数，不同之处在于，Python 函数还支持返回多个（ ≥0 ）值。 比如，上面程序中，我们自己封装的 my_len(str) 函数，在定义此函数时，我们为其设置了 1 个 str 参数，同时该函数经过内部处理，会返回给我们 1 个 length 值。 通过分析 my_len() 函数这个实例不难看出，函数的使用大致分为 2 步，分别是定义函数和调用函数。接下来一一为读者进行详细的讲解。 Python函数的定义定义函数，也就是创建一个函数，可以理解为创建一个具有某些用途的工具。定义函数需要用 def 关键字实现，具体的语法格式如下： def 函数名(参数列表): //实现特定功能的多行代码 [return [返回值]] 其中，用 [] 括起来的为可选择部分，即可以使用，也可以省略。 此格式中，各部分参数的含义如下： 函数名：其实就是一个符合 Python 语法的标识符，但不建议读者使用 a、b、c 这类简单的标识符作为函数名，函数名最好能够体现出该函数的功能（如上面的 my_len，即表示我们自定义的 len() 函数）。 形参列表：设置该函数可以接收多少个参数，多个参数之间用逗号（ , ）分隔。 [return [返回值] ]：整体作为函数的可选参参数，用于设置该函数的返回值。也就是说，一个函数，可以用返回值，也可以没有返回值，是否需要根据实际情况而定。 注意，在创建函数时，即使函数不需要参数，也必须保留一对空的“()”，否则 Python 解释器将提示“invaild syntax”错误。另外，如果想定义一个没有任何功能的空函数，可以使用 pass 语句作为占位符。 例如，下面定义了 2 个函数： 1#定义个空函数，没有实际意义def pass_dis(): pass#定义一个比较字符串大小的函数def str_max(str1,str2): str &#x3D; str1 if str1 &gt; str2 else str2 return str 虽然 Python 语言允许定义个空函数，但空函数本身并没有实际意义。 另外值得一提的是，函数中的 return 语句可以直接返回一个表达式的值，例如修改上面的 str_max() 函数： 1def str_max(str1,str2): return str1 if str1 &gt; str2 else str2 该函数的功能，和上面的 str_max() 函数是完全一样的，只是省略了创建 str 变量，因此函数代码更加简洁。 Python函数的调用调用函数也就是执行函数。如果把创建的函数理解为一个具有某种用途的工具，那么调用函数就相当于使用该工具。 函数调用的基本语法格式如下所示： [返回值] = 函数名([形参值]) 其中，函数名即指的是要调用的函数的名称；形参值指的是当初创建函数时要求传入的各个形参的值。如果该函数有返回值，我们可以通过一个变量来接收该值，当然也可以不接受。 需要注意的是，创建函数有多少个形参，那么调用时就需要传入多少个值，且顺序必须和创建函数时一致。即便该函数没有参数，函数名后的小括号也不能省略。 例如，我们可以调用上面创建的 pass_dis() 和 str_max() 函数： 1pass_dis()strmax &#x3D; str_max(&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;python&quot;,&quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;shell&quot;);print(strmax) 首先，对于调用空函数来说，由于函数本身并不包含任何有价值的执行代码，也没有返回值，应该调用空函数不会有任何效果。 其次，对于上面程序中调用 str_max() 函数，由于当初定义该函数为其设置了 2 个参数，因此这里在调用该参数，就必须传入 2 个参数。同时，由于该函数内部还使用了 return 语句，因此我们可以使用 strmax 变量来接收该函数的返回值。 因此，程序执行结果为： http://c.biancheng.net/shell 为函数提供说明文档前面章节讲过，通过调用 Python 的 help() 内置函数或者 doc 属性，我们可以查看某个函数的使用说明文档。事实上，无论是 Python 提供给我们的函数，还是自定义的函数，其说明文档都需要设计该函数的程序员自己编写。 其实，函数的说明文档，本质就是一段字符串，只不过作为说明文档，字符串的放置位置是有讲究的，函数的说明文档通常位于函数内部、所有代码的最前面。 以上面程序中的 str_max() 函数为例，下面演示了如何为其设置说明文档： 1#定义一个比较字符串大小的函数def str_max(str1,str2): &#39;&#39;&#39; 比较 2 个字符串的大小 &#39;&#39;&#39; str &#x3D; str1 if str1 &gt; str2 else str2 return strhelp(str_max)#print(str_max.__doc__) 程序执行结果为： Help on function str_max in module main: str_max(str1, str2) 比较 2 个字符串的大小 上面程序中，还可以使用 doc 属性来获取 str_max() 函数的说明文档，即使用最后一行的输出语句，其输出结果为： 比较 2 个字符串的大小","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python—if语句","slug":"python—if语句","date":"2020-06-13T10:15:08.000Z","updated":"2020-06-13T10:16:38.628Z","comments":true,"path":"2020/06/13/python—if语句/","link":"","permalink":"http://yoursite.com/2020/06/13/python%E2%80%94if%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"今天给大家分享一下Python中的IF语句的使用场景以及注意事项。主要内容如下: 1.python中的真假 2.Python操作符 3.if语句实例和嵌套实例 4.if语句中的if嵌套实例 5.and和or的运算关系演示 首先我们看一个IF语句处理的流程图： IF语句运行原理就是：给出条件，决定下一步怎么做？如果条件为真，就执行决策条件代码块的内容，为假就退出。 我们学习之前先看下Python中的真假：在python中，任何非零，非空对象都是真，除真和None以外其他的都是假。 来敲一下笔记： 1.任何非零和非空对象都为真 解释为True 2.数字0、空对象和特殊对象None均为假 解释为False 3.比较和相等测试会应用到数据结构中 4.返回值为True或False 我们来看几个例子细细品味一下： 123456789101112&gt;&gt;&gt; not 0True&gt;&gt;&gt; not 1False&gt;&gt;&gt; not []True&gt;&gt;&gt; not [1]False&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not FalseTrue ok，你知道了真假以后，然后我们来简单介绍一下python中的常用的几种运算符.因为条件语句和运算符的结合是经常会用到的。 Python操作符介绍1234561.算术运算符 + - * &#x2F; (取商) %（取余数） **2.赋值运算符 num&#x3D;100 num &#x3D; num + 903.成员关系运算符 in not in 4.比较运算符 &gt; &lt; &gt;&#x3D; &lt; &#x3D; &#x3D;&#x3D; !&#x3D; &lt;&gt; 接下来看一下关于IF语句中的一些常用的实例…… 1.if语句基本构成 1234 if 条件： if语句块 else: else语句 if语句用于比较运算（大于&gt;）中 12345a &#x3D; 0 if a &gt; 0: print &quot;a is not 0&quot;else: print &#39;a is o&#39; if语句用于比较运算中结合逻辑运算符 12345a &#x3D; 50if a&lt; 100 and a &gt; 10: print &quot;a is not 0&quot;else: print &#39;a is false&#39; and的优先级大于or有括号的运算最优先 12345a &#x3D; 50if (a&lt; 100 and a &gt; 10 or (a &gt;20 and a&lt;100): print &quot;a is true&quot;else: print &#39;a is false&#39; 2.if结合**比较运算操作符: &gt;&lt; == &gt;= &lt;= == != &lt;&gt;** 123456a &#x3D;90b &#x3D;100if a&gt;b: print &quot;a is max&quot;else: print &#39;a is min&#39; IF语句结合不等于实例： 123456a &#x3D;90b &#x3D;100if a&lt;&gt;b: print &quot;a is max&quot;else: print &#39;a is min&#39; IF语句结合成员关系运算符：In （not in ） 12345name &#x3D; &#39;zhangshan&#39;if &#39;zhang&#39; not in name: print &#39;zhang is in name&#39;else: print &#39;zhang is not in name&#39; 3.if elif嵌套结构123456if 条件： if语句块elif 条件： elif语句块else: else语句块 用于检查多个条件是否满足： 1234567891011number1 &#x3D; int(input(&quot;请输入数字1:&quot;))number2 &#x3D; int(input(&quot;请输入数字2:&quot;))if number1 &gt; number2: print &quot;&#123;&#125; 大于 &#123;&#125;&quot;.format(number1,number2)elif number2 &lt; number2: print &quot;&#123;&#125; 小于 &#123;&#125;&quot;.format(number1,number2)elif number1 &#x3D;&#x3D; number2: print &#39;%s 等于 %s&#39;%(number1,number2)else: print &#39;game is over&#39; IF嵌套语句2 最外侧if语句作为整个if语句中的决策条件，优先满足后，才可以继续和if子句进行在判断，如果一开始输入的内容不符合决策条件，就直接退出整个if分支语句。 12345678910name &#x3D; input(&quot;请输入信息:&quot;)if name.endswith(&#39;hello&#39;): if name.startswith(&#39;china&#39;): print &#39;welcome to &#123;&#125;&#39;.format(name) elif name.startswith(&#39;japan&#39;): print &#39;say you &#123;&#125;&#39;.format(name) else: print &#39;输入有误，重新输入&#39;else: print &#39;游戏结束----&gt;&#39; 写在最后补充-对Python而言： 123其一, 在不加括号时候, and优先级大于or其二, x or y 的值只可能是x或y. x为真就是x, x为假就是y其三, x and y 的值只可能是x或y. x为真就是y, x为假就是x 1234567看几个实际的例子&gt;&gt;&gt; 5 and 6 and 77&gt;&gt;&gt; 4 and 5 or 6 and 75&gt;&gt;&gt; True or True and FalseTrue&gt;&gt;&gt; 将喜欢的一切留在身边，这便是努力的意义。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python运算符","slug":"python运算符","date":"2020-06-13T10:08:53.000Z","updated":"2020-06-13T10:10:23.151Z","comments":true,"path":"2020/06/13/python运算符/","link":"","permalink":"http://yoursite.com/2020/06/13/python%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"Python运算符及逻辑运算 基本运算符运算符用于执行程序代码运算，会针对一个以上操作数项目来进行运算。例如：2+3,其操作数是2和3，而运算符则是“+”。在计算器语言中运算符大致可以分为5种类型：算术运算符、连接运算符、关系运算符、赋值运算符和逻辑运算符。运算符也是计算机里比较好理解的人类语言之一，只要稍微懂点数学的，都能看懂算数运算符。 在Python中常见的运算符有： +、-、、/、*/&lt;、&gt;、!=、//、%、&amp;、|、^、~、&gt;&gt;、&lt;&lt;、&lt;=、&gt;=、==、not、and、or 。接下来一一介绍这些运算符的具体事例。 算数运算以下假设变量：a=10，b=20 比较运算以下假设变量：a=10，b=20 赋值运算以下假设变量：a=10，b=20 http://kuanghy.github.io/2016/05/26/python-connect（Python连接符+=、+、-=） 逻辑运算 针对逻辑运算的进一步研究： 1、在没有()的情况下not 优先级高于 and，and优先级高于or，即优先级关系为( )&gt;not&gt;and&gt;or，同一优先级从左往右计算。 1print&#96;&#96;(&#96;&#96;3&#96;&#96;&gt;&#96;&#96;4&#96; &#96;or&#96; &#96;4&#96;&#96;&lt;&#96;&#96;3&#96; &#96;and&#96; &#96;1&#96;&#96;&#x3D;&#96;&#96;&#x3D;&#96;&#96;1&#96;&#96;)&#96;&#96;print&#96;&#96;(&#96;&#96;1&#96; &#96;&lt; &#96;&#96;2&#96; &#96;and&#96; &#96;3&#96; &#96;&lt; &#96;&#96;4&#96; &#96;or&#96; &#96;1&#96;&#96;&gt;&#96;&#96;2&#96; &#96;)&#96;&#96;print&#96;&#96;(&#96;&#96;2&#96; &#96;&gt; &#96;&#96;1&#96; &#96;and&#96; &#96;3&#96; &#96;&lt; &#96;&#96;4&#96; &#96;or&#96; &#96;4&#96; &#96;&gt; &#96;&#96;5&#96; &#96;and&#96; &#96;2&#96; &#96;&lt; &#96;&#96;1&#96;&#96;)&#96;&#96;print&#96;&#96;(&#96;&#96;1&#96; &#96;&gt; &#96;&#96;2&#96; &#96;and&#96; &#96;3&#96; &#96;&lt; &#96;&#96;4&#96; &#96;or&#96; &#96;4&#96; &#96;&gt; &#96;&#96;5&#96; &#96;and&#96; &#96;2&#96; &#96;&gt; &#96;&#96;1&#96; &#96;or&#96; &#96;9&#96; &#96;&lt; &#96;&#96;8&#96;&#96;)&#96;&#96;print&#96;&#96;(&#96;&#96;1&#96; &#96;&gt; &#96;&#96;1&#96; &#96;and&#96; &#96;3&#96; &#96;&lt; &#96;&#96;4&#96; &#96;or&#96; &#96;4&#96; &#96;&gt; &#96;&#96;5&#96; &#96;and&#96; &#96;2&#96; &#96;&gt; &#96;&#96;1&#96; &#96;and&#96; &#96;9&#96; &#96;&gt; &#96;&#96;8&#96; &#96;or&#96; &#96;7&#96; &#96;&lt; &#96;&#96;6&#96;&#96;)&#96;&#96;print&#96;&#96;(&#96;&#96;not&#96; &#96;2&#96; &#96;&gt; &#96;&#96;1&#96; &#96;and&#96; &#96;3&#96; &#96;&lt; &#96;&#96;4&#96; &#96;or&#96; &#96;4&#96; &#96;&gt; &#96;&#96;5&#96; &#96;and&#96; &#96;2&#96; &#96;&gt; &#96;&#96;1&#96; &#96;and&#96; &#96;9&#96; &#96;&gt; &#96;&#96;8&#96; &#96;or&#96; &#96;7&#96; &#96;&lt; &#96;&#96;6&#96;&#96;)&#96; &#96;#输出&#96;&#96;False&#96;&#96;True&#96;&#96;True&#96;&#96;False&#96;&#96;False&#96;&#96;False 2 、 x or y , x为真，值就是x，x为假，值是y；x and y, x为真，值是y,x为假，值是x。 非0转换为布尔值是True，0转换为布尔值是False 1print&#96;&#96;(&#96;&#96;8&#96; &#96;or&#96; &#96;4&#96;&#96;)&#96;&#96;print&#96;&#96;(&#96;&#96;0&#96; &#96;and&#96; &#96;3&#96;&#96;)&#96;&#96;print&#96;&#96;(&#96;&#96;0&#96; &#96;or&#96; &#96;4&#96; &#96;and&#96; &#96;3&#96; &#96;or&#96; &#96;7&#96; &#96;or&#96; &#96;9&#96; &#96;and&#96; &#96;6&#96;&#96;)&#96; &#96;#输出&#96;&#96;8&#96;&#96;0&#96;&#96;3 成员运算除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。 判断子元素是否在原字符串（字典，列表，集合）中： 1print&#96;&#96;(&#96;&#96;&#39;喜欢&#39;&#96; &#96;in&#96; &#96;&#39;dkfljadklf喜欢hfjdkas&#39;&#96;&#96;)&#96;&#96;print&#96;&#96;(&#96;&#96;&#39;a&#39;&#96; &#96;in&#96; &#96;&#39;bcvd&#39;&#96;&#96;)&#96;&#96;print&#96;&#96;(&#96;&#96;&#39;y&#39;&#96; &#96;not&#96; &#96;in&#96; &#96;&#39;ofkjdslaf&#39;&#96;&#96;)&#96; &#96;#输出&#96;&#96;True&#96;&#96;False&#96;&#96;True 位运算 按位取反运算规则(按位取反再加1) 详解http://blog.csdn.net/wenxinwukui234/article/details/42119265 运算符优先级 以下表格列出了从最高到最低优先级的所有运算符： ———————以下是些具体运算———————python运算符基础实例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159# coding&#x3D;utf-8#两个数字相加sumNumber&#x3D;1+2print(sumNumber) #输出结果：3 #两个字符串相加sumString&#x3D;&quot;Nice work&quot;print(sumString) #输出结果：Nice work #两个数字相减subNumber&#x3D;2-1print(subNumber) #输出结果：1 #两个数字相乘或者字符串重复multiplicationNumber&#x3D;2*3print(multiplicationNumber) #输出结果：6multiplicationString&#x3D;&quot;hello&quot;*2print(multiplicationString) #输出结果：hellohello#&#x2F;---关于*号重复字符串之前的博客已经介绍过了---&#x2F; #两个数相除divisionNumber&#x3D;9&#x2F;2print(divisionNumber) #输出结果：4divisionNumber&#x3D;9.0&#x2F;2print(divisionNumber) #输出结果：4.5divisionNumber&#x3D;9&#x2F;2.0print(divisionNumber) #输出结果：4.5#&#x2F;---除数或被除数中有任意一个是小数的话，商也会保留小数，反之取整---&#x2F; #求幂运算powerNumber&#x3D;2**3 #相当于2的3次幂，就是2*2*2 关于幂运算大家应该在数学里都很熟悉了print powerNumber #输出结果：8 #小于符号，返回值是bool值lessThan&#x3D;1&lt;2print(lessThan) #输出结果：TruelessThan&#x3D;1&lt;1print(lessThan) #输出结果：False #大于符号，返回值是bool值moreThan&#x3D;2&gt;1print(moreThan) #输出结果：TruemoreThan&#x3D;2&gt;2print(moreThan) #输出结果：False #不等于符号 返回值是Bool值notEqual&#x3D;1!&#x3D;2print(notEqual) #输出结果：TruenotEqual&#x3D;1!&#x3D;1print(notEqual) #输出结果：False #除法运算&#x2F;&#x2F; 返回商的整数部分，抛弃余数divisorNumber&#x3D;10&#x2F;&#x2F;3print(divisorNumber) #输出结果：3 #除法运算% 返回商的余数部分，抛弃商divisorNumber&#x3D;10%3print(divisorNumber) #输出结果：1divisorNumber&#x3D;10%1print(divisorNumber) #输出结果：0 &#x2F;--没有余数则返回0--&#x2F;divisorNumberx&#x3D;10&#x2F;&#x2F;3 #divisorNumberx是商的整数部分divisorNumbery&#x3D;10%3 #divisorNumbery是余数divisorNumberz&#x3D;3*divisorNumberx+divisorNumbery #divisorNumberz是除数乘以商的整数部分加上余数，得到的divisorNumberz的值就是被除数print(divisorNumberz) #输出结果：10 #按位与运算&amp;， 按位与是指一个数字转化为二进制，然后这些二进制的数按位来进行与运算operationNumber&#x3D;7&amp;18print operationNumber #输出结果：2&#39;&#39;&#39;这个有点绕，稍微多说下，如果对二进制不是太熟的朋友，可以打开电脑自带的计算器，按住win+q,输入&quot;calculator&quot;。然后在打开的计算器设置成程序员模式， 就是View(查看)-&gt;&gt;programmer(程序员).然后我们将7转为二进制:111,自动补全8位：00000111，然后将18转为二进制补全8位后得到：00010010最后将 00000111跟 00010010 按位进行与运算，&#x2F;-对与运算不熟的朋友可以看看百度百科的介绍，还是很详细的。http:&#x2F;&#x2F;baike.baidu.com&#x2F;link?url&#x3D;lfGJREBvGCY5j7VdF2OO9n2mtIbSyNUD7lZyyY74QIetguL5lXIQUxY38Yr-p4z4WdUvHUKGjw9CDfagiun2Ea-&#x2F;得到结果：00000010我们都知道10二进制→十进制&#x3D;2，所以7跟18的按位与的结果是二进制10(十进制2)&#39;&#39;&#39; #按位或运算|， 按位或是指一个数字转化为二进制，然后这些二进制的数按位来进行或运算operationNumber&#x3D;7|18print operationNumber #输出结果：23 #结题思路和按位与运算的一样，可以参考按位与运算 #按位异或operationNumber&#x3D;7^18print operationNumber #输出结果：21 #结题思路和按位与运算的一样，可以参考按位与运算 #按位翻转 ~ 按位翻转公式: ~x&#x3D; - (x+1)operationNumber&#x3D;~12 #~12&#x3D;- (12+1) &#x3D; -13print operationNumber #输出结果：-13 #结题思路和按位与运算的一样，可以参考按位与运算 #左移&lt;&lt;&#39;&#39;&#39;比如18左移就是将他的二进制形式00100100左移，得到00100100(36)。左移规律:左移一个单位相当于乘2，左移两个单位相当于乘以4，左移三个单位相当于乘以8，即: 左移n个单位相当于乘以2的n次幂&#39;&#39;&#39;operationNumber&#x3D;12&lt;&lt;1print operationNumber #输出结果：24operationNumber&#x3D;3&lt;&lt;3print operationNumber #输出结果：24 #右移&gt;&gt;&#39;&#39;&#39;理解左移以后，右移就很好理解了。右移是左移的逆运算，将对应的二进制数向右移动。右移规律:右移一个单位相当于除以2，右移两个单位相当于除以4，右移三个单位相当于除以8，即: 右移n个单位相当于除以2的n次幂&#39;&#39;&#39;operationNumber&#x3D;12&gt;&gt;1print operationNumber #输出结果：6operationNumber&#x3D;12&gt;&gt;2print operationNumber #输出结果：3 #小于等于&lt;&#x3D; 比较运算，小于或等于返回一个bool值operationNumber&#x3D;3&lt;&#x3D;3print operationNumber #输出结果：TrueoperationNumber&#x3D;3&lt;&#x3D;2print operationNumber #输出结果：False #大于等于&gt;&#x3D; 比较运算，大于或等于返回一个bool值operationNumber&#x3D;2&gt;&#x3D;3print operationNumber #输出结果：FalseoperationNumber&#x3D;3&gt;&#x3D;2print operationNumber #输出结果：True #比较两个对象是否相等&#x3D;&#x3D;operationNumber&#x3D;3&#x3D;&#x3D;2print operationNumber #输出结果：FalseoperationString&#x3D;&quot;hi&quot;&#x3D;&#x3D;&quot;hi&quot;print operationString #输出结果：True #逻辑非 notoperationx&#x3D;Trueoperationy&#x3D;not operationxprint operationy #输出结果：Falseoperationz&#x3D;Falseprint not operationz #输出结果：True #逻辑与 and&#39;&#39;&#39;True and True &#x3D; TrueTrue and False &#x3D; FalseFalse and True &#x3D; FalseFalse and False &#x3D; False&#39;&#39;&#39;print True and True #输出结果：True #逻辑或 or&#39;&#39;&#39;True or True &#x3D; TrueTrue or False &#x3D; TrueFalse or True &#x3D; TrueFalse or False &#x3D; False&#39;&#39;&#39;print False or False #输出结果：False 在一个表达式中可能包含多个有不同运算符连接起来的、具有不同数据类型的数据对象；由于表达式有多种运算，不同的运算顺序可能得出不同结果甚至出现错误运算错误，因为当表达式中含多种运算时，必须按一定顺序进行结合，才能保证运算的合理性和结果的正确性、唯一性。 优先级从上到下依次递减，最上面具有最高的优先级，逗号操作符具有最低的优先级。表达式的结合次序取决于表达式中各种运算符的优先级。优先级高的运算符先结合，优先级低的运算符后结合，同一行中的运算符的优先级相同。 123456789101112131415161718192021222324252627282930313233343536# coding&#x3D;utf-8#优先级的简单实例priorityNumber&#x3D;2+1*4print priorityNumber #输出结果：6#优先级使用实例#以下优先级排名从高到低，在同一运算中，先执行优先级高的再执行低的，以此类推。#Top 1:函数调用、寻址、下标#Top 2:幂运算**priorityNumber&#x3D;2*2**3print priorityNumber #输出结果：16#Top 3:翻转运算~#Top 4:正负号print 1+2*-3 #输出结果：-5#Top 5:*、&#x2F;、%print 2+1*2&#x2F;5 #输出结果：2#Top 6:+、-print 3&lt;&lt;2+1 #输出结果：24#Top 7:&lt;&lt;、&gt;&gt;#Top 8:按位&amp;、^、|#Top 9:比较运算符priority&#x3D;2*3+2&lt;&#x3D;2+1*7print priority #输出结果：True#Top 10:逻辑的not and or#Top 11:lambda表达式 12345678910111213141516171819#python优先级使用规律#1、一般情况下是左结合的#ps:在没有更高优先级运算符，即只有同级运算符时时从左到右结合print 1+2+3*5+5 #输出结果：23#2、出现赋值的时候一般是右结合#ps:在有赋值运算符时，是右结合，即先算出1+2的值以后再赋值给prioritypriority&#x3D;1+2print priority #输出结果：23#python运算符优先级大招&#39;&#39;&#39;比如说有这个需求： 去商店买水，买3瓶水，每瓶5块，再买一个绿箭(假设绿箭3块)，总共多少钱？ 这个简单的应用非常明显，需要先用乘法再用加法，如果这里你忘记了乘法和加法的优先级，可以这样：&#39;&#39;&#39;print (3*5)+3 #输出结果：18#ps: 这只是一个简单的例子，只是为了告诉大家实际应用中实在不行咱就放大招。有备无患。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python缩进","slug":"python缩进","date":"2020-06-13T10:04:12.000Z","updated":"2020-06-13T10:04:54.535Z","comments":true,"path":"2020/06/13/python缩进/","link":"","permalink":"http://yoursite.com/2020/06/13/python%E7%BC%A9%E8%BF%9B/","excerpt":"","text":"大家都知道python是一种对缩进非常敏感的语言，对代码格式要求非常严格的，个人遇到的最常见的一些问题如下： 1.不应该使用空格或Tab缩进的地方使用了空格或Tab 2.不同级别的代码没有缩进 3.缩进量不对 3.1代码内全部使用4个空格，某些代码缩进量不是4个空格 3.2缩进太多(本应4个空格或1个Tab，缩进8个空格或2个Tab)或太少（本应8个空格或2个Tab，缩进4个空格或1个Tab） 4.Tab和空格的混用—–这个问题最难看出来 这些错误很难用肉眼辨别。.。 报错信息：IndentationError: unexpected indent；IndentationError: expected an indented block。。。 如果遇到这类报错，就可能是代码里tab和空格缩进的问题，你需要检查下tab和空格了”。 【解决办法】 1.检查是否不应该使用空格的地方使用了空格或Tab，检查是否有缩进，缩进量是否对，缩进和空格是否有混用 2.注释有时候也会影响，所以注释的缩进也应引起注意 3.尤其对于缩进和空格是否有混用，可以用文本编辑器Notepad++把当前python脚本的所有空格或Tab字符都显示出来查看。 设置见： 视图 -&gt; 显示符号 -&gt; 显示空格与制表符 Tips: 确保代码内统一使用4或4的倍数个空格，或者统一使用Tab键或多个Tab键，如果运行不通过，可以使用Pycharm来运行，报错信息会很清楚的告诉你是哪一行不对。 Python自带IDLE缩进问题： Python IDEL整体代码缩进 左缩进 Ctrl + [ 右缩进 Ctrl + ] 加注释 Alt + 3 去注释 Alt + 4","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python字典","slug":"python字典","date":"2020-06-13T09:57:07.000Z","updated":"2020-06-13T09:58:48.490Z","comments":true,"path":"2020/06/13/python字典/","link":"","permalink":"http://yoursite.com/2020/06/13/python%E5%AD%97%E5%85%B8/","excerpt":"","text":"字典也是 Python 提供的一种常用的数据结构，它用于存放具有映射关系的数据。 比如有份成绩表数据，语文：79，数学：80，英语：92，这组数据看上去像两个列表，但这两个列表的元素之间有一定的关联关系。如果单纯使用两个列表来保存这组数据，则无法记录两组数据之间的关联关系。 为了保存具有映射关系的数据，Python 提供了字典，字典相当于保存了两组数据，其中一组数据是关键数据，被称为 key；另一组数据可通过 key 来访问，被称为 value。形象地看，字典中 key 和 value 的关联关系如图 1 所示： 图 1 字典保存的关联数据 由于字典中的 key 是非常关键的数据，而且程序需要通过 key 来访问 value，因此字典中的 key 不允许重复。 程序既可使用花括号语法来创建字典，也可使用 dict() 函数来创建字典。实际上，dict 是一种类型，它就是 Python 中的字典类型。 在使用花括号语法创建字典时，花括号中应包含多个 key-value 对，key 与 value 之间用英文冒号隔开；多个 key-value 对之间用英文逗号隔开。 如下代码示范了使用花括号语法创建字典： 1scores &#x3D; &#123;&#39;语文&#39;: 89, &#39;数学&#39;: 92, &#39;英语&#39;: 93&#125;print(scores)# 空的花括号代表空的dictempty_dict &#x3D; &#123;&#125;print(empty_dict)# 使用元组作为dict的keydict2 &#x3D; &#123;(20, 30):&#39;good&#39;, 30:&#39;bad&#39;&#125;print(dict2) 上面程序中第 1 行代码创建了一个简单的 dict，该 dict 的 key 是字符串，value 是整数；第 4 行代码使用花括号创建了一个空的字典；第 7 行代码创建的字典中第一个 key 是元组，第二个 key 是整数值，这都是合法的。 需要指出的是，元组可以作为 dict 的 key，但列表不能作为元组的 key。这是由于 dict 要求 key 必须是不可变类型，但列表是可变类型，因此列表不能作为元组的 key。 在使用 dict() 函数创建字典时，可以传入多个列表或元组参数作为 key-value 对，每个列表或元组将被当成一个 key-value 对，因此这些列表或元组都只能包含两个元素。例如如下代码： 1vegetables &#x3D; [(&#39;celery&#39;, 1.58), (&#39;brocoli&#39;, 1.29), (&#39;lettuce&#39;, 2.19)]# 创建包含3组key-value对的字典dict3 &#x3D; dict(vegetables)print(dict3) # &#123;&#39;celery&#39;: 1.58, &#39;brocoli&#39;: 1.29, &#39;lettuce&#39;: 2.19&#125;cars &#x3D; [[&#39;BMW&#39;, 8.5], [&#39;BENS&#39;, 8.3], [&#39;AUDI&#39;, 7.9]]# 创建包含3组key-value对的字典dict4 &#x3D; dict(cars)print(dict4) # &#123;&#39;BMW&#39;: 8.5, &#39;BENS&#39;: 8.3, &#39;AUDI&#39;: 7.9&#125; 如果不为 dict() 函数传入任何参数，则代表创建一个空的字典。例如如下代码： 1# 创建空的字典dict5 &#x3D; dict()print(dict5) # &#123;&#125; 还可通过为 dict 指定关键字参数创建字典，此时字典的 key 不允许使用表达式。例如如下代码： 1# 使用关键字参数来创建字典dict6 &#x3D; dict(spinach &#x3D; 1.39, cabbage &#x3D; 2.59)print(dict6) # &#123;&#39;spinach&#39;: 1.39, &#39;cabbage&#39;: 2.59&#125; 上面粗体字代码在创建字典时，其 key 直接写 spinach、cabbage，不需要将它们放在引号中。 字典的基本用法对于初学者而言，应牢记字典包含多个 key-value 对，而 key 是字典的关键数据，因此程序对字典的操作都是基于 key 的。基本操作如下： 通过 key 访问 value 。 通过 key 添加 key-value 对。 通过 key 删除 key-value 对。 通过 key 修改 key-value 对。 通过 key 判断指定 key-value 对是否存在。 通过 key 访问 value 使用的也是方括号语法，就像前面介绍的列表和元组一样，只是此时在方括号中放的是 key，而不是列表或元组中的索引。 如下代码示范了通过 key 访问 value： 1scores &#x3D; &#123;&#39;语文&#39;: 89&#125;# 通过key访问valueprint(scores[&#39;语文&#39;]) 如果要为 dict 添加 key-value 对，只需为不存在的 key 赋值即可： 1# 对不存在的key赋值，就是增加key-value对scores[&#39;数学&#39;] &#x3D; 93scores[92] &#x3D; 5.7print(scores) # &#123;&#39;语文&#39;: 89, &#39;数学&#39;: 93, 92: 5.7&#125; 如果要删除宇典中的 key-value 对，则可使用 del 语句。例如如下代码： 1# 使用del语句删除key-value对del scores[&#39;语文&#39;]del scores[&#39;数学&#39;]print(scores) # &#123;92: 5.7&#125; 如果对 dict 中存在的 key-value 对赋值，新赋的 value 就会覆盖原有的 value，这样即可改变 dict 中的 key-value 对。例如如下代码： 1cars &#x3D; &#123;&#39;BMW&#39;: 8.5, &#39;BENS&#39;: 8.3, &#39;AUDI&#39;: 7.9&#125;# 对存在的key-value对赋值，改变key-value对cars[&#39;BENS&#39;] &#x3D; 4.3cars[&#39;AUDI&#39;] &#x3D; 3.8print(cars) # &#123;&#39;BMW&#39;: 8.5, &#39;BENS&#39;: 4.3, &#39;AUDI&#39;: 3.8&#125; 如果要判断字典是否包含指定的 key，则可以使用 in 或 not in 运算符。需要指出的是，对于 dict 而言，in 或 not in 运算符都是基于 key 来判断的。例如如下代码： 1# 判断cars是否包含名为&#39;AUDI&#39;的keyprint(&#39;AUDI&#39; in cars) # True# 判断cars是否包含名为&#39;PORSCHE&#39;的keyprint(&#39;PORSCHE&#39; in cars) # Falseprint(&#39;LAMBORGHINI&#39; not in cars) # True 通过上面介绍可以看出，字典的 key 是它的关键。换个角度来看，字典的 key 就相当于它的索引，只不过这些索引不一定是整数类型，字典的 key 可以是任意不可变类型。 可以这样说，字典相当于索引是任意不可变类型的列表：而列表则相当于 key 只能是整数的字典。因此，如果程序中要使用的字典的 key 都是整数类型，则可考虑能否换成列表。 此外，还有一点需要指出，列表的索引总是从 0 开始、连续增大的；但字典的索引即使是整数类型，也不需要从 0 开始，而且不需要连续。因此，列表不允许对不存在的索引赋值：但字典则允许直接对不存在的 key 赋值，这样就会为字典增加一个 key-value 对。 列表不允许对不存在的索引赋值，但字典则允许直接对不存在的 key 赋值。 字典的常用方法字典由 dict 类代表，因此我们同样可使用 dir(dict) 来查看该类包含哪些方法。在交互式解释器中输入 dir(dict) 命令，将看到如下输出结果： &gt;&gt;&gt; dir(dict)[‘clear’, ‘copy’, ‘fromkeys’, ‘get’, ‘items’, ‘keys’, ‘pop’, ‘popitem’, ‘setdefault’, ‘update’, ‘values’]&gt;&gt;&gt; 下面介绍 dict 的一些方法。 clear()方法clear() 用于清空字典中所有的 key-value 对，对一个字典执行 clear() 方法之后，该字典就会变成一个空字典。例如如下代码： 1cars &#x3D; &#123;&#39;BMW&#39;: 8.5, &#39;BENS&#39;: 8.3, &#39;AUDI&#39;: 7.9&#125;print(cars) # &#123;&#39;BMW&#39;: 8.5, &#39;BENS&#39;: 8.3, &#39;AUDI&#39;: 7.9&#125;# 清空cars所有key-value对cars.clear()print(cars) # &#123;&#125; get()方法get() 方法其实就是根据 key 来获取 value，它相当于方括号语法的增强版，当使用方括号语法访问并不存在的 key 时，字典会引发 KeyError 错误；但如果使用 get() 方法访问不存在的 key，该方法会简单地返回 None，不会导致错误。例如如下代码： 1cars &#x3D; &#123;&#39;BMW&#39;: 8.5, &#39;BENS&#39;: 8.3, &#39;AUDI&#39;: 7.9&#125;# 获取&#39;BMW&#39;对应的valueprint(cars.get(&#39;BMW&#39;)) # 8.5print(cars.get(&#39;PORSCHE&#39;)) # Noneprint(cars[&#39;PORSCHE&#39;]) # KeyError update()方法update() 方法可使用一个字典所包含的 key-value 对来更新己有的字典。在执行 update() 方法时，如果被更新的字典中己包含对应的 key-value 对，那么原 value 会被覆盖；如果被更新的字典中不包含对应的 key-value 对，则该 key-value 对被添加进去。例如如下代码： 1cars &#x3D; &#123;&#39;BMW&#39;: 8.5, &#39;BENS&#39;: 8.3, &#39;AUDI&#39;: 7.9&#125;cars.update(&#123;&#39;BMW&#39;:4.5, &#39;PORSCHE&#39;: 9.3&#125;)print(cars) 从上面的执行过程可以看出，由于被更新的 dict 中己包含 key 为“AUDI”的 key-value 对，因此更新时该 key-value 对的 value 将被改写；但如果被更新的 dict 中不包含 key 为“PORSCHE”的 key-value 对，那么更新时就会为原字典增加一个 key-value 对。 items()、keys()、values()items()、keys()、values() 分别用于获取字典中的所有 key-value 对、所有 key、所有 value。这三个方法依次返回 dict_items、dict_keys 和 dict_values 对象，Python 不希望用户直接操作这几个方法，但可通过 list() 函数把它们转换成列表。如下代码示范了这三个方法的用法： 1cars &#x3D; &#123;&#39;BMW&#39;: 8.5, &#39;BENS&#39;: 8.3, &#39;AUDI&#39;: 7.9&#125;# 获取字典所有的key-value对，返回一个dict_items对象ims &#x3D; cars.items()print(type(ims)) # &lt;class &#39;dict_items&#39;&gt;# 将dict_items转换成列表print(list(ims)) # [(&#39;BMW&#39;, 8.5), (&#39;BENS&#39;, 8.3), (&#39;AUDI&#39;, 7.9)]# 访问第2个key-value对print(list(ims)[1]) # (&#39;BENS&#39;, 8.3)# 获取字典所有的key，返回一个dict_keys对象kys &#x3D; cars.keys()print(type(kys)) # &lt;class &#39;dict_keys&#39;&gt;# 将dict_keys转换成列表print(list(kys)) # [&#39;BMW&#39;, &#39;BENS&#39;, &#39;AUDI&#39;]# 访问第2个keyprint(list(kys)[1]) # &#39;BENS&#39;# 获取字典所有的value，返回一个dict_values对象vals &#x3D; cars.values()# 将dict_values转换成列表print(type(vals)) # [8.5, 8.3, 7.9]# 访问第2个valueprint(list(vals)[1]) # 8.3 从上面代码可以看出，程序调用字典的 items()、keys()、values() 方法之后，都需要调用 list() 函数将它们转换为列表，这样即可把这三个方法的返回值转换为列表。 在 Python 2.x 中，items()、keys()、values() 方法的返回值本来就是列表，完全可以不用 list() 函数进行处理。当然，使用 list() 函数处理也行，列表被处理之后依然是列表。 pop方法pop() 方法用于获取指定 key 对应的 value，并删除这个 key-value 对。如下方法示范了 pop() 方法的用法： 1cars &#x3D; &#123;&#39;BMW&#39;: 8.5, &#39;BENS&#39;: 8.3, &#39;AUDI&#39;: 7.9&#125;print(cars.pop(&#39;AUDI&#39;)) # 7.9print(cars) # &#123;&#39;BMW&#39;: 8.5, &#39;BENS&#39;: 8.3&#125; 此程序中，第 2 行代码将会获取“AUDI”对应的 value，并删除该 key-value 对。 popitem()方法popitem() 方法用于随机弹出字典中的一个 key-value 对。 此处的随机其实是假的，正如列表的 pop() 方法总是弹出列表中最后一个元素，实际上字典的 popitem() 其实也是弹出字典中最后一个 key-value 对。由于字典存储 key-value 对的顺序是不可知的，因此开发者感觉字典的 popitem() 方法是“随机”弹出的，但实际上字典的 popitem() 方法总是弹出底层存储的最后一个 key-value 对。 如下代码示范了 popitem() 方法的用法： 1cars &#x3D; &#123;&#39;AUDI&#39;: 7.9, &#39;BENS&#39;: 8.3, &#39;BMW&#39;: 8.5&#125;print(cars)# 弹出字典底层存储的最后一个key-value对print(cars.popitem()) # (&#39;AUDI&#39;, 7.9)print(cars) # &#123;&#39;BMW&#39;: 8.5, &#39;BENS&#39;: 8.3&#125; 由于实际上 popitem 弹出的就是一个元组，因此程序完全可以通过序列解包的方式用两个变量分别接收 key 和 value。例如如下代码： 1# 将弹出项的key赋值给k、value赋值给vk, v &#x3D; cars.popitem()print(k, v) # BENS 8.3 setdefault()方法setdefault() 方法也用于根据 key 来获取对应 value 的值。但该方法有一个额外的功能，即当程序要获取的 key 在字典中不存在时，该方法会先为这个不存在的 key 设置一个默认的 value，然后再返回该 key 对应的 value。 总之，setdefault() 方法总能返回指定 key 对应的 value；如果该 key-value 对存在，则直接返回该 key 对应的 value；如果该 key-value 对不存在，则先为该 key 设置默认的 value，然后再返回该 key 对应的 value。 如下代码示范了 setdefault() 方法的用法： 1cars &#x3D; &#123;&#39;BMW&#39;: 8.5, &#39;BENS&#39;: 8.3, &#39;AUDI&#39;: 7.9&#125;# 设置默认值，该key在dict中不存在，新增key-value对print(cars.setdefault(&#39;PORSCHE&#39;, 9.2)) # 9.2print(cars)# 设置默认值，该key在dict中存在，不会修改dict内容print(cars.setdefault(&#39;BMW&#39;, 3.4)) # 8.5print(cars) fromkeys()方法fromkeys() 方法使用给定的多个 key 创建字典，这些 key 对应的 value 默认都是 None；也可以额外传入一个参数作为默认的 value。该方法一般不会使用字典对象调用（没什么意义），通常会使用 dict 类直接调用。例如如下代码： 1# 使用列表创建包含2个key的字典a_dict &#x3D; dict.fromkeys([&#39;a&#39;, &#39;b&#39;])print(a_dict) # &#123;&#39;a&#39;: None, &#39;b&#39;: None&#125;# 使用元组创建包含2个key的字典b_dict &#x3D; dict.fromkeys((13, 17))print(b_dict) # &#123;13: None, 17: None&#125;# 使用元组创建包含2个key的字典，指定默认的valuec_dict &#x3D; dict.fromkeys((13, 17), &#39;good&#39;)print(c_dict) # &#123;13: &#39;good&#39;, 17: &#39;good&#39;&#125; 使用字典格式化字符串前面章节介绍过，在格式化字符串时，如果要格式化的字符串模板中包含多个变量，后面就需要按顺序给出多个变量，这种方式对于字符串模板中包含少量变量的情形是合适的，但如果字符串模板中包含大量变量，这种按顺序提供变量的方式则有些不合适。可改为在字符串模板中按 key 指定变量，然后通过字典为字符串模板中的 key 设置值。 例如如下程序： 1# 字符串模板中使用keytemp &#x3D; &#39;教程是:%(name)s, 价格是:%(price)010.2f, 出版社是:%(publish)s&#39;book &#x3D; &#123;&#39;name&#39;:&#39;Python基础教程&#39;, &#39;price&#39;: 99, &#39;publish&#39;: &#39;C语言中文网&#39;&#125;# 使用字典为字符串模板中的key传入值print(temp % book)book &#x3D; &#123;&#39;name&#39;:&#39;C语言小白变怪兽&#39;, &#39;price&#39;:159, &#39;publish&#39;: &#39;C语言中文网&#39;&#125;# 使用字典为字符串模板中的key传入值print(temp % book) 运行上面程序，可以看到如下输出结果： 教程是:Python基础教程, 价格是:0000099.00, 出版社是:C语言中文网教程是:C语言小白变怪兽, 价格是:0000159.00, 出版社是:C语言中文网 引用网址","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python元组","slug":"python元组","date":"2020-06-13T09:53:50.000Z","updated":"2020-06-13T09:55:15.218Z","comments":true,"path":"2020/06/13/python元组/","link":"","permalink":"http://yoursite.com/2020/06/13/python%E5%85%83%E7%BB%84/","excerpt":"","text":"Python的元组与列表类似，不同之处在于元组的元素不能修改,元组使用小括号,列表使用方括号,元组创建很简单,只需要在括号中添加元素,并使用逗号隔开即可*一、创建元组* 代码如下: 1tup1 &#96;&#96;&#x3D;&#96; &#96;(&#96;&#96;&#39;physics&#39;&#96;&#96;, &#96;&#96;&#39;chemistry&#39;&#96;&#96;, &#96;&#96;1997&#96;&#96;, &#96;&#96;2000&#96;&#96;);&#96;&#96;tup2 &#96;&#96;&#x3D;&#96; &#96;(&#96;&#96;1&#96;&#96;, &#96;&#96;2&#96;&#96;, &#96;&#96;3&#96;&#96;, &#96;&#96;4&#96;&#96;, &#96;&#96;5&#96; &#96;);&#96;&#96;tup3 &#96;&#96;&#x3D;&#96; &#96;&quot;a&quot;&#96;&#96;, &#96;&#96;&quot;b&quot;&#96;&#96;, &#96;&#96;&quot;c&quot;&#96;&#96;, &#96;&#96;&quot;d&quot;&#96;&#96;; 创建空元组 代码如下: 1tup1 &#96;&#96;&#x3D;&#96; &#96;(); 元组中只包含一个元素时，需要在元素后面添加逗号来消除歧义 代码如下: 1tup1 &#96;&#96;&#x3D;&#96; &#96;(&#96;&#96;50&#96;&#96;,); 元组与字符串类似，下标索引从0开始，可以进行截取，组合等。二、访问元组元组可以使用下标索引来访问元组中的值，如下实例: 1代码如下:&#96;&#96;#!&#x2F;usr&#x2F;bin&#x2F;python&#96;&#96; &#96; &#96;tup1 &#96;&#96;&#x3D;&#96; &#96;(&#96;&#96;&#39;physics&#39;&#96;&#96;, &#96;&#96;&#39;chemistry&#39;&#96;&#96;, &#96;&#96;1997&#96;&#96;, &#96;&#96;2000&#96;&#96;);&#96;&#96;tup2 &#96;&#96;&#x3D;&#96; &#96;(&#96;&#96;1&#96;&#96;, &#96;&#96;2&#96;&#96;, &#96;&#96;3&#96;&#96;, &#96;&#96;4&#96;&#96;, &#96;&#96;5&#96;&#96;, &#96;&#96;6&#96;&#96;, &#96;&#96;7&#96; &#96;);&#96; &#96;print&#96; &#96;&quot;tup1[0]: &quot;&#96;&#96;, tup1[&#96;&#96;0&#96;&#96;]&#96;&#96;print&#96; &#96;&quot;tup2[1:5]: &quot;&#96;&#96;, tup2[&#96;&#96;1&#96;&#96;:&#96;&#96;5&#96;&#96;]&#96;&#96;#以上实例输出结果：&#96;&#96;#tup1[0]: physics&#96;&#96;#tup2[1:5]: [2, 3, 4, 5] 三、修改元组元组中的元素值是不允许修改的，但我们可以对元组进行连接组合，如下实例: 代码如下: 1#!&#x2F;usr&#x2F;bin&#x2F;python&#96;&#96; &#96; &#96;tup1 &#96;&#96;&#x3D;&#96; &#96;(&#96;&#96;12&#96;&#96;, &#96;&#96;34.56&#96;&#96;);&#96;&#96;tup2 &#96;&#96;&#x3D;&#96; &#96;(&#96;&#96;&#39;abc&#39;&#96;&#96;, &#96;&#96;&#39;xyz&#39;&#96;&#96;);&#96; &#96;# 以下修改元组元素操作是非法的。&#96;&#96;# tup1[0] &#x3D; 100;&#96; &#96;# 创建一个新的元组&#96;&#96;tup3 &#96;&#96;&#x3D;&#96; &#96;tup1 &#96;&#96;+&#96; &#96;tup2;&#96;&#96;print&#96; &#96;tup3;&#96;&#96;#以上实例输出结果：&#96;&#96;#(12, 34.56, &#39;abc&#39;, &#39;xyz&#39;) *四、删除元组*元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组，如下实例: 代码如下: 1#!&#x2F;usr&#x2F;bin&#x2F;python&#96;&#96; &#96; &#96;tup &#96;&#96;&#x3D;&#96; &#96;(&#96;&#96;&#39;physics&#39;&#96;&#96;, &#96;&#96;&#39;chemistry&#39;&#96;&#96;, &#96;&#96;1997&#96;&#96;, &#96;&#96;2000&#96;&#96;);&#96; &#96;print&#96; &#96;tup;&#96;&#96;del&#96; &#96;tup;&#96;&#96;print&#96; &#96;&quot;After deleting tup : &quot;&#96;&#96;print&#96; &#96;tup;&#96; &#96;#以上实例元组被删除后，输出变量会有异常信息，输出如下所示：&#96;&#96;#(&#39;physics&#39;, &#39;chemistry&#39;, 1997, 2000)&#96;&#96;#After deleting tup :&#96;&#96;#Traceback (most recent call last):&#96;&#96;# File &quot;test.py&quot;, line 9, in &lt;module&gt;&#96;&#96;# print tup;&#96;&#96;#NameError: name &#39;tup&#39; is not defined[&#x2F;code] 五、元组运算符与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这就意味着他们可以组合和复制，运算后会生成一个新的元组。 六、元组索引，截取因为元组也是一个序列，所以我们可以访问元组中的指定位置的元素，也可以截取索引中的一段元素，如下所示：元组： 代码如下: 1L &#96;&#96;&#x3D;&#96; &#96;(&#96;&#96;&#39;spam&#39;&#96;&#96;, &#96;&#96;&#39;Spam&#39;&#96;&#96;, &#96;&#96;&#39;SPAM!&#39;&#96;&#96;) 七、无关闭分隔符任意无符号的对象，以逗号隔开，默认为元组，如下实例： 代码如下: 1#!&#x2F;usr&#x2F;bin&#x2F;python&#96;&#96; &#96; &#96;print&#96; &#96;&#39;abc&#39;&#96;&#96;, &#96;&#96;-&#96;&#96;4.24e93&#96;&#96;, &#96;&#96;18&#96;&#96;+&#96;&#96;6.6j&#96;&#96;, &#96;&#96;&#39;xyz&#39;&#96;&#96;;&#96;&#96;x, y &#96;&#96;&#x3D;&#96; &#96;1&#96;&#96;, &#96;&#96;2&#96;&#96;;&#96;&#96;print&#96; &#96;&quot;Value of x , y : &quot;&#96;&#96;, x,y; 以上实例允许结果： 代码如下: 1abc &#96;&#96;-&#96;&#96;4.24e&#96;&#96;+&#96;&#96;93&#96; &#96;(&#96;&#96;18&#96;&#96;+&#96;&#96;6.6j&#96;&#96;) xyz&#96;&#96;Value of x , y : &#96;&#96;1&#96; &#96;2 八、元组内置函数Python元组包含了以下内置函数1、cmp(tuple1, tuple2)：比较两个元组元素。2、len(tuple)：计算元组元素个数。3、max(tuple)：返回元组中元素最大值。4、min(tuple)：返回元组中元素最小值。5、tuple(seq)：将列表转换为元组。 九、另一种解读 tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字： 代码如下: 1&gt;&gt;&gt; classmates &#96;&#96;&#x3D;&#96; &#96;(&#96;&#96;&#39;Michael&#39;&#96;&#96;, &#96;&#96;&#39;Bob&#39;&#96;&#96;, &#96;&#96;&#39;Tracy&#39;&#96;&#96;) 现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如： 代码如下: 1&gt;&gt;&gt; t &#96;&#96;&#x3D;&#96; &#96;(&#96;&#96;1&#96;&#96;, &#96;&#96;2&#96;&#96;)&#96;&#96;&gt;&gt;&gt; t&#96;&#96;(&#96;&#96;1&#96;&#96;, &#96;&#96;2&#96;&#96;) 如果要定义一个空的tuple，可以写成()： 代码如下: 1&gt;&gt;&gt; t &#96;&#96;&#x3D;&#96; &#96;()&#96;&#96;&gt;&gt;&gt; t&#96;&#96;() 但是，要定义一个只有1个元素的tuple，如果你这么定义： 代码如下: 1&gt;&gt;&gt; t &#96;&#96;&#x3D;&#96; &#96;(&#96;&#96;1&#96;&#96;)&#96;&#96;&gt;&gt;&gt; t&#96;&#96;1 定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： 代码如下: 1&gt;&gt;&gt; t &#96;&#96;&#x3D;&#96; &#96;(&#96;&#96;1&#96;&#96;,)&#96;&#96;&gt;&gt;&gt; t&#96;&#96;(&#96;&#96;1&#96;&#96;,) Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。 在来看一个“可变的”tuple： 代码如下: 1&gt;&gt;&gt; t &#96;&#96;&#x3D;&#96; &#96;(&#96;&#96;&#39;a&#39;&#96;&#96;, &#96;&#96;&#39;b&#39;&#96;&#96;, [&#96;&#96;&#39;A&#39;&#96;&#96;, &#96;&#96;&#39;B&#39;&#96;&#96;])&#96;&#96;&gt;&gt;&gt; t[&#96;&#96;2&#96;&#96;][&#96;&#96;0&#96;&#96;] &#96;&#96;&#x3D;&#96; &#96;&#39;X&#39;&#96;&#96;&gt;&gt;&gt; t[&#96;&#96;2&#96;&#96;][&#96;&#96;1&#96;&#96;] &#96;&#96;&#x3D;&#96; &#96;&#39;Y&#39;&#96;&#96;&gt;&gt;&gt; t&#96;&#96;(&#96;&#96;&#39;a&#39;&#96;&#96;, &#96;&#96;&#39;b&#39;&#96;&#96;, [&#96;&#96;&#39;X&#39;&#96;&#96;, &#96;&#96;&#39;Y&#39;&#96;&#96;]) 这个tuple定义的时候有3个元素，分别是’a’，’b’和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？ 别急，我们先看看定义的时候tuple包含的3个元素：当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为：表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python列表","slug":"python列表","date":"2020-06-13T09:50:49.000Z","updated":"2020-06-13T09:51:51.213Z","comments":true,"path":"2020/06/13/python列表/","link":"","permalink":"http://yoursite.com/2020/06/13/python%E5%88%97%E8%A1%A8/","excerpt":"","text":"python中有列表、元组、集合、字典这四种可以存放多个数据元素的集合，他们在总体功能上都起着存放数据的作用，却都有着各自的特点。本片文章中我们会对列表的用法做详细说明。 演示环境：python3.6pycharm中的python3.6 第一部分：列表（list）：列表（list）用来存储不同的数据类型，使用 [ ] 例如： 12service &#x3D; [&#39;http&#39;,&#39;ssh&#39;,&#39;ftp&#39;]1 后续演示中的service都以上述为基础。列表的特性：1.1：索引： 123print(service[1]) ##输出第二个元素，sshprint(service[-1]) ##输出最后一个元素，ftp12 1.2：切片： 1234print(service[1:]) ##打印第一个元素之后的内容print(service[:-1]) ##打印最后一个元素之前的内容print(service[::-1]) ##倒序输出123 1.3：重复： 12print(service * 3) ##输出三遍1 1.4：连接： 123service1 &#x3D; [&#39;nfs&#39;,&#39;samba&#39;]print(service + service1)12 1.5：成员操作赋: 12print(&#39;nfs&#39; in service) ##判断是否存在1 1.6：迭代:[for循环遍历] 123for i in service: print(i) ##遍历输出每个元素12 1.7列表里嵌套列表 12345service2 &#x3D; [[&#39;abc&#39;,&#39;def&#39;,&#39;www&#39;],[1,2,3],[&#39;mike&#39;,&#39;tony&#39;,&#39;sun&#39;]]对其索引：print(service2[2][1]) ##第三个元素中的第二个元素对其切片：print(service2[:][1]) ##第二个元素1234 对以上内容进行一个练习：题目：输入一年中的某一天，判断这一天是这一年的第几天：【输入格式：YYYY-MM-DD】 1234567891011121314151617 User_input &#x3D; input(&#39;输入：年-月-日&#39;)Year &#x3D; int(User_input.split(&#39;-&#39;)[0]) ##得到年份Month &#x3D; int(User_input.split(&#39;-&#39;)[1]) ##得到月份Day &#x3D; int(User_input.split(&#39;-&#39;)[2]) ##得到天li &#x3D; [31,28,31,30,31,30,31,31,30,31,30,31] ##所有平年各个月份的天数num &#x3D; 0 ##记录天数if ((Year % 4 &#x3D;&#x3D; 0) and (Year % 100 !&#x3D; 0) or (Year % 400 &#x3D;&#x3D; 0)): ##当闰年时： li[1] &#x3D; 29 ##将二月的天数改为29for i in range(12): ##遍历月份 if Month &gt; i + 1: ##i从0开始，假如是5月的某一天，i循环到3停止，经过0-1-2-3四次循环，取4个月份即取1-2-3-4月的所有天 num +&#x3D; li[i] ##将1-4月总天数求和 else: ##退出if判断后，当下一次循环时，i&#x3D;4，i+1不满足if的条件，进入else，将最后5月的第几天加入总天数中 num +&#x3D; Day breakprint(&#39;这一天是%d年的第%d天&#39; %(Year,num))12345678910111213141516 列表的增删改查：1.增加： 往列表里增加元素: 123456781.print(service + [&#39;firewalld&#39;]) ##用连接的方式2.service.append(&#39;firewalld&#39;) print(service) ##append:追加一个元素到列表中3.extend:拉伸 追加多个元素到列表中 service.extend([&#39;mysql&#39;,&#39;firewalld&#39;])4.service.insert(1,&#39;samba&#39;) ###在指定索引位置插入元素 ##在第二个元素的位置插入samba作为第二个元素1234567 2.删除： 123456789101.service.pop() ##弹出最后一个元素a &#x3D; service.pop(0) ##弹出第1个元素 ###可以将其赋值2.service.remove(&#39;ssh&#39;) ##指定删除对象的名字 ##直接删除，不能将其赋值 ##不能指定序号，只能指定要删除对象的3. del service ##删除列表del service ##直接删除整个列表print(service)123456789 3.赋值： 12341.service[0] &#x3D; &#39;mysql&#39; ##通过索引 重新赋值2.service[:2] &#x3D; [&#39;samba&#39;,&#39;iscsi&#39;] ##通过切片给前两个元素重新赋值123 4.查看：查看出现的次数 12service.count(&#39;ssh&#39;)1 查看指定元素的索引值 123service.index(&#39;iscsi&#39;) ###最小索引值service.index(&#39;ssh&#39;,1,3) ###从1-3中查找【第二个元素和第三个元素之间】【不取上限】12 5.排序：sort 排序对字符串排序不区分大小写 1234567names &#x3D; [&#39;alice&#39;,&#39;Bob&#39;,&#39;coco&#39;,&#39;Harry&#39;]names.sort()names ###按照ASCLL排序 ###先排序首字母为大写的，再排序首字母是小写的names.sort(key&#x3D;str.lower) ###对字符串排序不区分大小写，相当于将所有元素转换为小写，再排序names.sort(key&#x3D;str.upper) ###相当于将所有元素转换为大写，再排序123456 乱序 123456li &#x3D; list(range(10)) ##生成0-9，将其转换为列表形式print(li)import randomrandom.shuffle(li) ##随机打乱print(li) 12345 练习：修改用户登陆系统：用户名和用户密码存放在两个列表里。用admin超级用户登陆后，可以进行添加，删除，查看用户的操作。1.后台管理员admin 密码admin2.管理员才能看到会员信息3.会员信息包含添加会员信息删除会员信息查看会员信息退出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950inuser &#x3D; input(&#39;UserName: &#39;)inpasswd &#x3D; input(&#39;Password: &#39;)users &#x3D; [&#39;root&#39;, &#39;westos&#39;]passwds &#x3D; [&#39;123&#39;, &#39;456&#39;]if inuser &#x3D;&#x3D; &#39;admin&#39; and inpasswd &#x3D;&#x3D; &#39;admin&#39;: while True: print(&quot;&quot;&quot; 菜单 1.添加会员信息 2.删除会员信息 3.查看会员信息 4.退出 &quot;&quot;&quot;) choice &#x3D; input(&#39;请输入选择： &#39;) if choice &#x3D;&#x3D; &#39;1&#39;: Add_Name &#x3D; input(&#39;要添加的会员名: &#39;) Add_Passwd &#x3D; input(&#39;设置会员的密码为： &#39;) users &#x3D; users + [Add_Name] passwds &#x3D; passwds + [Add_Passwd] print(&#39;添加成功！&#39;) elif choice &#x3D;&#x3D; &#39;2&#39;: Remove_Name &#x3D; input(&#39;请输入要删除的会员名： &#39;) if Remove_Name in users: Remove_Passwd &#x3D; input(&#39;请输入该会员的密码： &#39;) SuoYinZhi &#x3D; int(users.index(Remove_Name)) if Remove_Passwd &#x3D;&#x3D; passwds[SuoYinZhi]: users.remove(Remove_Name) passwds.pop(SuoYinZhi) print(&#39;成功删除！&#39;) else: print(&#39;用户密码错误,无法验证身份,删除失败&#39;) else: print(&#39;用户错误！请输入正确的用户名&#39;) elif choice &#x3D;&#x3D; &#39;3&#39;: print(&#39;查看会员信息&#39;.center(50,&#39;*&#39;)) print(&#39;\\t用户名\\t密码&#39;) usercount &#x3D; len(users) for i in range(usercount): print(&#39;\\t%s\\t%s&#39; %(users[i],passwds[i])) elif choice &#x3D;&#x3D; &#39;4&#39;: exit() else: print(&#39;请输入正确选择！&#39;)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849 值是简单的列表使用练习，功能不全面，后续待改进。 练习二：用python列表实现栈操作：1.入栈2.出栈3.栈顶元素4.栈长度5.栈是否为空 “””功能包括：1.入栈 放到栈顶的位置2.出栈 判断是不是栈顶元素，不是的话将其后元素遍历移除，再移走该元素，再将其他元素加回栈3.栈顶元素 索引4.栈长度 判断个数5.栈是否为空 #栈顶有无元素“””#栈的特点：先进后出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152Zhan &#x3D; [] ##定义栈列表t &#x3D; [] ##定义出栈临时栈列表while True: print(&quot;&quot;&quot; 菜单 1.入栈 2.出栈 3.查看栈顶元素 4.查看栈长度 5.查看栈中元素 6.退出&quot;&quot;&quot;) choice &#x3D; input(&#39;请输入选择: &#39;) if choice &#x3D;&#x3D; &#39;1&#39;: Aim_Name &#x3D; input(&#39;请输入要入栈的元素名： &#39;) Zhan &#x3D; Zhan+[Aim_Name] print(&#39;入栈成功!&#39;) elif choice &#x3D;&#x3D; &#39;2&#39;: Del_Name &#x3D; input(&#39;请输入要出栈的元素名： &#39;) if Del_Name in Zhan: Length &#x3D; len(Zhan) if Zhan.index(Del_Name) &#x3D;&#x3D; Length-1: #如果为栈顶元素 Zhan.pop() else: #不为栈顶元素 SuoYin &#x3D; Zhan.index(Del_Name) for i in range(Length-1-SuoYin): #将要出栈元素后面的元素先保留 t.append(Zhan.pop()) #原栈中最后一个元素变为了第一个，顺序颠倒 Zhan.pop() #目标出栈 Zhan &#x3D; Zhan+t[::-1] #将目标元素后的其他元素移回栈中 else: print(&#39;栈中没有%s&#39; %Del_Name) elif choice &#x3D;&#x3D; &#39;3&#39;: Zhan_Top &#x3D; Zhan[-1] print(&#39;栈顶元素为：%s&#39; %Zhan_Top) elif choice &#x3D;&#x3D; &#39;4&#39;: Length &#x3D; len(Zhan) print(&#39;栈的长度为%s&#39; %Length) elif choice &#x3D;&#x3D; &#39;5&#39;: print(Zhan) elif choice &#x3D;&#x3D; &#39;6&#39;: exit() else: print(&#39;请输入正确的选项！&#39;) print(&#39;\\n&#39;)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 ) 关于python中列表的基础用法如上所述。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python字符串","slug":"python字符串","date":"2020-06-13T09:47:57.000Z","updated":"2020-06-13T09:48:30.685Z","comments":true,"path":"2020/06/13/python字符串/","link":"","permalink":"http://yoursite.com/2020/06/13/python%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"字符串 字符串就是一系列字符。在Python中，单引号、双引号或者三引号里面的内容就是字符串。如何字符串中包括单引号或者双引号，python使用反斜线（）对字符串中的字符进行转义。 123456789101112131415# 单引号里面的文本就是字符串‘I am a boy’# 双引号其实和单引号一样，一般推荐使用单引号&quot;人生苦短，我用Python&quot;# 三引号表示的字符串，一般表示很长的文字，只要引号没有结束就可以一直写。# 一般用来写文本注释&#39;&#39;&#39;人生苦短，我用Python&#39;&#39;&#39;","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python浮点数","slug":"python浮点数","date":"2020-06-13T09:46:01.000Z","updated":"2020-06-13T09:46:30.530Z","comments":true,"path":"2020/06/13/python浮点数/","link":"","permalink":"http://yoursite.com/2020/06/13/python%E6%B5%AE%E7%82%B9%E6%95%B0/","excerpt":"","text":"浮点数 带小数点的数字都是浮点数，也可以进行类型整数的运算，比如加减乘除等。 123456789# 加法add &#x3D; 0.2 + 0.1#Python中,format方法是格式化输出，也就是在&#123;&#125;的地方替换为变量的值。后面项目实战中经常用到print(&#39;0.2+0.1的值是&#123;&#125;&#39;.format(add))0.2+0.1的值是 0.30000000000000004","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python—整数语句","slug":"python—整数","date":"2020-06-13T09:40:18.000Z","updated":"2020-06-13T09:47:27.547Z","comments":true,"path":"2020/06/13/python—整数/","link":"","permalink":"http://yoursite.com/2020/06/13/python%E2%80%94%E6%95%B4%E6%95%B0/","excerpt":"","text":"整数 整数也就是int类型，在Python中，可以直接对整数进行算数运算 1234567891011# 加法add &#x3D; 3 + 4# Python中,format方法是格式化输出，也就是在&#123;&#125;的地方替换为变量的值。后面项目实战中经常用到print(&#39;3+4的值是&#123;&#125;&#39;.format(add))运行结果为：3+4的值是 7","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"python—循环语句","slug":"python—循环语句","date":"2020-06-13T09:37:01.000Z","updated":"2020-06-13T09:40:54.203Z","comments":true,"path":"2020/06/13/python—循环语句/","link":"","permalink":"http://yoursite.com/2020/06/13/python%E2%80%94%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/","excerpt":"","text":"for循环for i in range（10）： 求阶乘 123456789#输出a &#x3D; int(input(&#39;请输入一个值:&#39;))#阶乘控制单位total &#x3D; 1#求阶乘for i in range(1,a+1,1): ##起始值为1，终止符为a+1，间隔为1求阶乘 total *&#x3D; iprint(total)12345678 练习求1，2，3，4四个数字可以组成多少个不同的且不重复的三位数字 1234567891011121314151617181920&quot;&quot;&quot;file:求1，2，3，4四个数可以组成多少个不重复且不相同的三位数字并打印date:2019-6-23 09:46description:&quot;&quot;&quot;#不相同数字的数目num &#x3D; 0#对三位数字取值for g in range(1,5,1): for s in range(1,5,1): for b in range(1, 5, 1):#判断三个数字是否有相同数字，若没有则打印且num自加1 if(g !&#x3D; s and g !&#x3D; b and b !&#x3D; s ): print(&#39;%d%d%d&#39; %(b,s,g)) num +&#x3D; 1#输出有多少个不重复数字print(&#39;共%d个不重复且不相同的数字&#39; %(num))1234567891011121314151617在这里插入代码片1 跳出循环break：跳出循环continue：continue后的程序不执行，但后续循化会继续执行exit：终止程序运行（exit为函数） for循环实现用户登录 1234567891011121314151617181920&quot;&quot;&quot;1.输入用户和密码2.判断是否正确(name &#x3D; &#39;root&#39;,passwd &#x3D; &#39;westos&#39;)3.登陆仅有三次机会，超过三次则报错for循环实现用户登录&quot;&quot;&quot;for i in range(3): name &#x3D; input(&#39;用户名:&#39;) passwd &#x3D; input(&#39;密码:&#39;) if ((name &#x3D;&#x3D; &#39;root&#39;) and (passwd &#x3D;&#x3D; &#39;westos&#39;)): print(&#39;登陆成功&#39;) break else: print(&#39;登陆失败&#39;) print(&#39;您还有%d次机会&#39; %(2-i))else: print(&#39;失败超过三次，请稍后再试&#39;)12345678910111213141516171819 简单实现shell命令 1234567891011import osfor i in range(1000): cmd &#x3D; input(&#39;[root@python ~]&#39;) if cmd: if cmd &#x3D;&#x3D; &#39;exit&#39;: print(&#39;logout&#39;) else: os.system(cmd) else: continue12345678910 求最大公约数与最小公倍数 12345678910111213a &#x3D; int(input(&#39;输入第一个数:&#39;))b &#x3D; int(input(&#39;输入第二个数:&#39;))small &#x3D; min(a,b)big &#x3D; max(a,b)sum &#x3D; 1for i in range(1,small+1): if (a % i &#x3D;&#x3D; 0) and (b % i &#x3D;&#x3D; 0): sum &#x3D; 1 * i continueprint(&#39;最大公约数为:%d&#39; %(sum))print(&#39;最小公倍数为%d&#39; %(a*b&#x2F;sum))123456789101112 whilewhile 条件：条件满足时，做的事情条件满足时，做的事情… 123456789eg:#1.定义计数器i &#x3D; 0#2.条件判断while i &lt; 3: #3.处理计数器 i &#x3D; i + 1 print(&quot;%d&quot; %(i))12345678 while实现for循环编辑的简易用户登录 1234567891011121314i &#x3D; 0while i &lt;&#x3D; 2: name &#x3D; input(&#39;用户名:&#39;) passwd &#x3D; input(&#39;密码:&#39;) if ((name &#x3D;&#x3D; &#39;root&#39;) and (passwd &#x3D;&#x3D; &#39;westos&#39;)): print(&#39;登陆成功&#39;) break else: print(&#39;登陆失败&#39;) print(&#39;您还有%d次机会&#39; %(2-i)) i &#x3D; i + 1else: print(&#39;失败超过三次，请稍后再试&#39;)12345678910111213 while打印四种直角三角形第一行输出1颗星，每行依次加一颗星，直至第五行第一种 12345678910 row &#x3D; 1while row &lt;&#x3D; 5: col &#x3D; 1 while col &lt;&#x3D; row: print(&#39;*&#39;,end&#x3D;&#39;&#39;) col +&#x3D; 1 print(&#39;&#39;) row +&#x3D; 1123456789 第二种倒序输出上题条件 12345678910row &#x3D; 1while row &lt;&#x3D; 5: col &#x3D; 5 while col &gt;&#x3D; row: print(&#39;*&#39;,end&#x3D;&#39;&#39;) col -&#x3D; 1 print(&#39;&#39;) row +&#x3D; 1123456789 第三种 123456789101112row &#x3D; 1while row &lt;&#x3D; 5: col &#x3D; 1 while col &lt; row: print(&#39; &#39;,end&#x3D;&#39;&#39;) col +&#x3D; 1 while col &gt;&#x3D; row and col &lt;&#x3D; 5: print(&#39;*&#39;,end&#x3D;&#39;&#39;) col +&#x3D; 1 print(&#39;&#39;) row +&#x3D; 11234567891011 第四种 123456789101112row &#x3D; 1while row &lt;&#x3D; 5: col &#x3D; 1 while col &lt;&#x3D; (5 - row): print(&#39; &#39;,end&#x3D;&#39;&#39;) col +&#x3D; 1 while (col &gt;(5-row) and col &lt;&#x3D;5): print(&#39;*&#39;,end&#x3D;&#39;&#39;) col +&#x3D; 1 print(&#39;&#39;) row +&#x3D; 11234567891011 打印乘法口诀表 123456789row &#x3D; 1while row &lt;&#x3D; 9: col &#x3D; 1 while col &lt;&#x3D; row: print(&#39;%d * %d &#x3D; %d &#39; %(col,row,col*row),end&#x3D;&#39;&#39;) col +&#x3D; 1 print(&#39;&#39;) row +&#x3D; 112345678 猜数字游戏1.电脑随即输入1～100中的某个数字2.玩家输入数字若正确则输出“congratulation”3.若数字太大则提示“too big“4.若数字太小则提示“too small”5.共有五次机会 12345678910111213141516171819import randomnum &#x3D; 0c &#x3D; int(random.randint(1, 100))while True and num &lt;&#x3D;4 : print(&#39;您还有%d次机会&#39; % (5 - num)) i &#x3D; int(input(&#39;请输入数字:&#39;)) if i &#x3D;&#x3D; c: print(&#39;congratulation&#39;) break elif i &gt; c: print(&#39;too big&#39;) num +&#x3D; 1 else: print(&#39;too small&#39;) num +&#x3D; 1if num &#x3D;&#x3D; 5: print(&#39;数字为%d,你猜错啦&#39; %(c))123456789101112131415161718 字符串定义定义：a = ‘hello’b = “westos”c = ‘let’s go’d = “let’s go”e = “””1.打印2.复制3.copy“””字符串特性###索引#s = ‘hello’#print(s[0])#print(s[1])#print(s[2]) ###切片#print(s[0:3])##输出1到第三个字符#print(s[:3])#print(s[0:4:2]) #s[start🔚step],从start开始，从end-1结束，补偿为step#print(s[:])#打印全部字符串#print(s[::-1])#反向输出字符串#print(s[1:])#输出第二个到最后一个字符#print(s[:-1])#除了最后一个字符都输出#print(s[-1]) #只输出最后一个字符 #重复#print(s * 5)a = ‘hello’hello hello hello hello hello #连接print(‘hello’+‘world’)helloworld判断大小写与大小写转换和文件查找判断输出都为True与Falseprint(‘hello’.istitle()) ##判断hello是否为题目，首字母大写print(‘hello’.isupper()) 判断hello是否为全大写print(‘heLLo’.islower()) 判断heLLo是否为全小写 #大小写转换print(‘hello’.upper()) 转换hello为大写print(‘heLLo’.lower()) 转换heLLo为小写 #判断文件类型是否以.log结尾filename = ‘hello.log’if filename.endswith(’.log’):print(filename)else:print(‘error’)a = ’ hello ’b = ‘hello’print(a)print(a.strip())##去除两边的空格print(a.lstrip())##去除左边的空格print(a.rstrip())##去除右边的空格print(b.lstrip(‘h’))##去除左边的h 字符串的搜索和替换s = ‘hello world hello’#find找到子串并返回最小的索引print(s.find(‘hello’))print(s.find(‘world’))#find找到子串并返回最大的索引print(s.rfind(‘hello’))print(s.rfind(‘world’)) #字符串统计print(s.count(‘l’))print(s.count(“l”)) #字符串替换print(s.replace(’ ‘,’ westos’)) 把‘ ’替换为westos 123456a &#x3D; input(&#39;输入一串字符:&#39;)b &#x3D; input(&#39;输入另一串字符:&#39;)for i in b[:]: a &#x3D; a.replace(i,&#39;&#39;)print(a)12345 #字符串的分离和连接s = ‘172.25.254.142’s1 = s.split(’.’) #以点为分割符号切割s并将其赋值给s1print(s1)s2 = (s1[::-1]) # 将s1倒序赋值给s2print(s1[::-1])date = ‘2019-06-23’date1 = date.split(’-’)print(date1) #连接print(’-’.join(date1))print(’.’.join(s2))","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python注释","slug":"Python注释","date":"2020-06-13T09:32:39.000Z","updated":"2020-06-13T09:35:11.466Z","comments":true,"path":"2020/06/13/Python注释/","link":"","permalink":"http://yoursite.com/2020/06/13/Python%E6%B3%A8%E9%87%8A/","excerpt":"","text":"1、单行注释（行注释）Python中使用#表示单行注释。单行注释可以作为单独的一行放在被注释代码行之上，也可以放在语句或表达式之后。 1# 这是单行注释 当单行注释作为单独的一行放在被注释代码行之上时，为了保证代码的可读性，建议在#后面添加一个空格，再添加注释内容。 当单行注释放在语句或表达式之后时，同样为了保证代码的可读性，建议注释和语句（或注释和表达式）之间至少要有两个空格。 2、多行注释（块注释）当注释内容过多，导致一行无法显示时，就可以使用多行注释。Python中使用三个单引号或三个双引号表示多行注释。 1234567'''这是使用三个单引号的多行注释'''\"\"\"这是使用三个双引号的多行注释\"\"\" 3、注意 注释不是越多越好。对于一目了然的代码，不需要添加注释。 对于复杂的操作，应该在操作开始前写上相应的注释。 对于不是一目了然的代码，应该在代码之后添加注释。 绝对不要描述代码。一般阅读代码的人都了解Python的语法，只是不知道代码要干什么。 4、关于代码规范Python官方提供有一系列PEP文档，其中第8篇文档专门针对Python的代码格式给出了建议，也就是俗称的PEP 8。PEP 8文档地址。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"Python——print()函数","slug":"Python——print()函数","date":"2020-06-13T09:26:10.000Z","updated":"2020-06-13T09:35:24.122Z","comments":true,"path":"2020/06/13/Python——print()函数/","link":"","permalink":"http://yoursite.com/2020/06/13/Python%E2%80%94%E2%80%94print()%E5%87%BD%E6%95%B0/","excerpt":"","text":"python版本：python3.5.1 ; IDE：pycharm2017.2 目录 一、print()函数概述 二、变量的输出 三、数据的格式化输出 [3.1 %字符](https://blog.csdn.net/sinat_28576553/article/details/81154912#3.1 %字符) [3.2 最小字段宽度和精度](https://blog.csdn.net/sinat_28576553/article/details/81154912#3.2 最小字段宽度和精度) [3.3 转换标志](https://blog.csdn.net/sinat_28576553/article/details/81154912#3.3 转换标志) [3.4 格式字符归纳](https://blog.csdn.net/sinat_28576553/article/details/81154912# 3.4 格式字符归纳) 四、换行与防止换行 一、print()函数概述print() 方法用于打印输出，是python中最常见的一个函数。 该函数的语法如下： 1print(*objects, sep=' ', end='\\n', file=sys.stdout) 参数的具体含义如下： objects –表示输出的对象。输出多个对象时，需要用 , （逗号）分隔。 sep – 用来间隔多个对象。 end – 用来设定以什么结尾。默认值是换行符 \\n，我们可以换成其他字符。 file – 要写入的文件对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960print(1) #数值类型可以直接输出'''运行结果如下1'''print(\"Hello World\") #字符串类型可以直接输出'''运行结果如下：Hello World'''a=1b=\"Hello World\"print(a, b) #可以一次输出多个对象，对象之间用逗号分隔'''运行结果如下：1 Hello World'''#如果直接输出字符串，而不是用对象表示的话，可以不使用逗号print(\"Duan\"\"Yixuan\")print(\"Duan\",\"Yixuan\")'''运行结果如下：DuanYixuanDuan Yixuan可知，不添加逗号分隔符，字符串之间没有间隔'''print(\"www\", \"snh48\", \"com\", sep=\".\") # 设置间隔符'''运行结果如下：www.snh48.com''' 二、变量的输出无论什么类型的数据，包括但不局限于：数值型，布尔型，列表变量，字典变量…都可以直接输出。 123456789101112131415161718192021#例如：num = 19print(num) #19 输出数值型变量str = 'Duan Yixuan'print(str) #Duan Yixuan 输出字符串变量list = [1,2,'a']print(list) #[1, 2, 'a'] 输出列表变量tuple = (1,2,'a')print(tuple) #(1, 2, 'a') 输出元组变量dict = &#123;'a':1, 'b':2&#125;print(dict) # &#123;'a': 1, 'b': 2&#125; 输出字典变量 三、数据的格式化输出在C语言中，我们可以使用printf(“%-.4f”,a)之类的形式，实现数据的的格式化输出。 在python中，我们同样可以实现数据的格式化输出。我们可以先看一个简单的例子： 123456789101112131415161718192021s='Duan Yixuan'x=len(s)print('The length of %s is %d' %(s,x))''''The length of %s is %d' 这部分叫做：格式控制符(s,x) 这部分叫做：转换说明符% 字符，表示标记转换说明符的开始输出如下：The length of Duan Yixuan is 11''' 和C语言的区别在于，Python中格式控制符和转换说明符用%分隔，C语言中用逗号。 接下来我们仔细探讨一下格式化输出 3.1 %字符(1).%字符：标记转换说明符的开始。 %字符的用法可参考上例，不再赘述。 3.2 最小字段宽度和精度最小字段宽度：转换后的字符串至少应该具有该值指定的宽度。如果是*（星号），则宽度会从值元组中读出。 点(.)后跟精度值：如果需要输出实数，精度值表示出现在小数点后的位数。如果需要输出字符串，那么该数字就表示最大字段宽度。如果是*，那么精度将从元组中读出。 可参考C语言的实现方式。 注：字段宽度中，小数点也占一位。 12345678910111213141516171819202122232425PI = 3.141592653print('%10.3f'%PI) #字段宽10，精度3# 3.142#精度为3，所以只显示142，指定宽度为10，所以在左边需要补充5个空格，以达到10位的宽度PI=3.1415926print(\"PI=%.*f\"%(3,PI))#用*从后面的元组中读取字段宽度或精度,可以读取出来精度是3位#PI=3.142 #没有指定宽度，所以不需要缩进print(\"PI=%*.3f\"%(10,PI)) #精度为3，总长为10.# PI= 3.142#* 所处的位置不同，读取的内容也不同 3.3 转换标志转换标志：-表示左对齐；+表示在数值前要加上正负号；” “(空白字符)表示正数之前保留空格()；0表示转换值若位数不够则用0填充。 具体的我们可以看一下例子： 123456789101112131415PI=3.1415926print('%-10.3f' %PI) #左对齐，还是10个字符，但空格显示在右边。#3.142PI=3.1415926print('%+f' % PI) #显示正负号 #+3.141593# 类型f的默认精度为6位小数。PI=3.1415926print('%010.3f'%PI) #字段宽度为10，精度为3，不足处用0填充空白#000003.142 0表示转换值若位数不够则用0填充 3.4 格式字符归纳格式字符 说明 格式字符 说明 %s 字符串采用str()的显示 %x 十六进制整数 %r 字符串(repr())的显示 %e 指数（基底写e） %c 单个字符 %E 指数（基底写E） %b 二进制整数 %f,%F 浮点数 %d 十进制整数 %g 指数(e)或浮点数(根据显示长度) %i 十进制整数 %G 指数(E)或浮点数(根据显示长度) %o 八进制整数 %% 字符% 四、换行与防止换行在python中，输出函数总是默认换行，比如说： 1234567891011121314151617for x in range(0,5): print(x)'''01234''' 而显然，这种输出太占“空间”，我们可以进行如下改造： 参考文本第一部分对end参数的描述：end – 用来设定以什么结尾。默认值是换行符 \\n，我们可以换成其他字符。 12345678910for x in range(0, 5): print(x, end=' ')#0 1 2 3 4 for x in range(0, 5): print(x, end=',')#0,1,2,3,4, 但如果，我们同时运行上面两段代码，结果会如下所示，可知：我们需要在两次输出间，实现换行。 12345678910for x in range(0, 5): print(x, end=' ')for x in range(0, 5): print(x, end=',')#0 1 2 3 4 0,1,2,3,4, 我们比较以下几种方式 方式一： 123456789101112131415161718for x in range(0, 5): print(x, end=' ')print('\\n') for x in range(0, 5): print(x, end=',')'''0 1 2 3 4 0,1,2,3,4,''' 之所以出现上面这种情况，是因为print()本身就是默认换行的，再加上换行符，相当于换行两次。 方式二： 12345678910111213141516171819for x in range(0, 5): print(x, end=' ')print() #本身自带换行，完美输出for x in range(0, 5): print(x, end=',')'''0 1 2 3 4 0,1,2,3,4,'''","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"最全的Markdown语法汇总在这里","slug":"最全的Markdown语法汇总在这里","date":"2020-05-30T03:35:12.000Z","updated":"2020-05-30T03:27:02.172Z","comments":true,"path":"2020/05/30/最全的Markdown语法汇总在这里/","link":"","permalink":"http://yoursite.com/2020/05/30/%E6%9C%80%E5%85%A8%E7%9A%84Markdown%E8%AF%AD%E6%B3%95%E6%B1%87%E6%80%BB%E5%9C%A8%E8%BF%99%E9%87%8C/","excerpt":"","text":"Markdown 语法汇总精要1. 斜体和粗体使用 * 和 ** 表示斜体和粗体。 示例： 这是 斜体，这是 粗体。 2. 分级标题使用 === 表示一级标题，使用 — 表示二级标题。 示例： 1234567这是一个一级标题&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;这是一个二级标题--------------------------------------------------### 这是一个三级标题 你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。 3. 外链接使用 描述 为文字增加外链接。 示例代码： 1这是去往 [本人github](https://github.com/GW-Lazybones/Lazybones.github.io) 的链接。 效果：这是去往 本人github 的链接。 4. 无序列表使用 *，+，- 表示无序列表。 示例： 123- 无序列表项 一- 无序列表项 二- 无序列表项 三 效果： 无序列表项 一 无序列表项 二 无序列表项 三 5. 有序列表使用数字和点表示有序列表。 示例： 1231. 有序列表项 一2. 有序列表项 二3. 有序列表项 三 效果： 有序列表项 一 有序列表项 二 有序列表项 三 6. 文字引用使用 &gt; 表示文字引用。 示例： 1&gt; 野火烧不尽，春风吹又生。 效果： 野火烧不尽，春风吹又生。 7. 行内代码块使用 代码 表示行内代码块。 示例： 1让我们聊聊 &#96;html&#96;。 效果：让我们聊聊 html。 8. 代码块使用 四个缩进空格 表示代码块。 示例： 1这是一个代码块，此行左侧有四个不可见的空格。 效果：这是一个代码块，此行左侧有四个不可见的空格。 9. 插入图像使用 插入图像。 示例： 1![我的头像](https:&#x2F;&#x2F;avatars3.githubusercontent.com&#x2F;u&#x2F;10223537?s&#x3D;460&amp;v&#x3D;4) 效果： Markdown 高阶语法1. 内容目录在段落中填写 [TOC] 以显示全文内容的目录结构。 [TOC] 2. 标签分类在编辑区任意行的列首位置输入以下代码给文稿标签： 标签： 数学 英语 Markdown 或者 Tags： 数学 英语 Markdown 3. 删除线使用 ~~ 表示删除线。 这是一段错误的文本。 4. 注脚使用 [^keyword] 表示注脚。 这是一个注脚1的样例。 这是第二个注脚2的样例。 5. LaTeX 公式$ 表示行内公式： 质能守恒方程可以用一个很简洁的方程式 E=mc2E=mc^2E=m*c*2 来表达。 $$ 表示整行公式： ∑i=1nai=0\\sum_{i=1}^n a_i=0i=1∑nai=0 f(x1,xx,…,xn)=x12+x22+⋯+xn2f(x_1,x_x,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2f(x1,x**x,…,x**n)=x12+x22+⋯+x*n*2 ∑k=0j−1γ^kjzk\\sum^{j-1}{k=0}{\\widehat{\\gamma}{kj} z_k}k=0∑j−1γkjzk 访问 MathJax 参考更多使用方法。 6. 加强的代码块支持四十一种编程语言的语法高亮的显示，行号显示。 非代码示例： 1$ sudo apt-get install vim-gnome Python 示例： 123456789101112@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' JavaScript 示例： 1234567891011121314151617/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) &#123; var a = 1, b = 1; var tmp; while (--n &gt;= 0) &#123; tmp = a; a += b; b = tmp; &#125; return a;&#125;document.write(fib(10)); 7. 流程图示例12345678910st&#x3D;&gt;start: Start:&gt;https:&#x2F;&#x2F;www.zybuluo.comio&#x3D;&gt;inputoutput: verificationop&#x3D;&gt;operation: Your Operationcond&#x3D;&gt;condition: Yes or No?sub&#x3D;&gt;subroutine: Your Subroutinee&#x3D;&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io 8. 序列图示例 1123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 示例 212345Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow 9. 甘特图甘特图内在思想简单。基本是一条线条图，横轴表示时间，纵轴表示活动（项目），线条表示在整个期间上计划和实际的活动完成情况。它直观地表明任务计划在什么时候进行，及实际进展与计划要求的对比。 12345678910111213title 项目开发流程section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5dsection 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5dsection 发布验收 发布: 2d 验收: 3d 10. Mermaid 流程图1234A[Hard edge] --&gt;|Link text| B(Round edge)B --&gt; C&#123;Decision&#125;C --&gt;|One| D[Result one]C --&gt;|Two| E[Result two] 11. Mermaid 序列图1234Alice-&gt;John: Hello John, how are you?loop every minute John--&gt;Alice: Great!end 12. 表格支持 项目 价格 数量 计算机 $1600 5 手机 $12 12 管线 $1 234 13. 定义型列表 名词 1 定义 1（左侧有一个可见的冒号和四个不可见的空格） 代码块 2 这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）代码块（左侧有八个不可见的空格） 14. Html 标签本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格： 12345678910111213&lt;table&gt; &lt;tr&gt; &lt;th rowspan&#x3D;&quot;2&quot;&gt;值班人员&lt;&#x2F;th&gt; &lt;th&gt;星期一&lt;&#x2F;th&gt; &lt;th&gt;星期二&lt;&#x2F;th&gt; &lt;th&gt;星期三&lt;&#x2F;th&gt; &lt;&#x2F;tr&gt; &lt;tr&gt; &lt;td&gt;李强&lt;&#x2F;td&gt; &lt;td&gt;张明&lt;&#x2F;td&gt; &lt;td&gt;王平&lt;&#x2F;td&gt; &lt;&#x2F;tr&gt;&lt;&#x2F;table&gt; 值班人员 星期一 星期二 星期三 李强 张明 王平 15. 内嵌图标本站的图标系统对外开放，在文档中输入 1&lt;i class&#x3D;&quot;icon-weibo&quot;&gt;&lt;&#x2F;i&gt; 即显示微博的图标： 替换 上述 i 标签 内的 icon-weibo 以显示不同的图标，例如： 1&lt;i class&#x3D;&quot;icon-renren&quot;&gt;&lt;&#x2F;i&gt; 即显示人人的图标： 更多的图标和玩法可以参看 font-awesome 官方网站。 16. 待办事宜 Todo 列表使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如： 1234567891011- [ ] **Cmd Markdown 开发** - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 - [ ] 支持以 PDF 格式导出文稿 - [x] 新增Todo列表功能 [语法参考](https:&#x2F;&#x2F;github.com&#x2F;blog&#x2F;1375-task-lists-in-gfm-issues-pulls-comments) - [x] 改进 LaTex 功能 - [x] 修复 LaTex 公式渲染问题 - [x] 新增 LaTex 公式编号功能 [语法参考](http:&#x2F;&#x2F;docs.mathjax.org&#x2F;en&#x2F;latest&#x2F;tex.html#tex-eq-numbers)- [ ] **七月旅行准备** - [ ] 准备邮轮上需要携带的物品 - [ ] 浏览日本免税店的物品 - [x] 购买蓝宝石公主号七月一日的船票 对应显示如下待办事宜 Todo 列表： Cmd Markdown 开发 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率 支持以 PDF 格式导出文稿 新增Todo列表功能 语法参考 改进 LaTex 功能 修复 LaTex 公式渲染问题 新增 LaTex 公式编号功能 语法参考 七月旅行准备 准备邮轮上需要携带的物品 浏览日本免税店的物品 购买蓝宝石公主号七月一日的船票","categories":[],"tags":[]},{"title":"hexo","slug":"hexo","date":"2020-05-30T01:46:10.000Z","updated":"2020-06-14T06:49:12.565Z","comments":true,"path":"2020/05/30/hexo/","link":"","permalink":"http://yoursite.com/2020/05/30/hexo/","excerpt":"","text":"你是否想过自己开发一个网站？你是否想过免费获得一个自己的域名？hexo只需1分钟就可以实现这个目标** 民间有传言，没有手撸过个人网站的程序员不是一个好的前端开发工程师，可是！hexo完全免费，hexo你直接带回家。通过hexo，可以快速构建个人博客，并搭建到github 上供他人访问，三秒真男人，我们开始吧！ Hexo是一个快速、简洁且高效的博客框架。Hexo 使用Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。即把用户的markdown文件，按照指定的主题解析成静态网页。 先上源代码： hexo init hexo s #如果里面有玄学因素就不怪我了（此代码不包含环境以及相关的一些npm下载的东西） 正文开始： （一些环境可能有些同学还不清楚，我就重头开始讲） 安装Git Bash 下载地址：https://git-for-windows.github.io 安装步骤：双击下载好的exe文件，一路next就好啦 然后你就可以在这里发挥你的聪明才智了 安装NodeJs Hexo是基于nodeJS环境的静态博客，里面的npm工具很有用啊，所以还是老老实实把这玩意儿装了吧 地址：https://nodejs.org/en (说明：LTS为长期支持版，Current为当前最新版) 安装步骤：反正下载好msi文件后，双击打开安装，也是一路next，不过在CustomSetup这一步记得选 Add to PATH ,这样你就不用自己去配置电脑上环境变量了 又到自由发挥的时候了 安装hexo 看到这么多安装，千万不要紧张，小哥哥小姐姐们一定要稳住，别怕，因为后面的东西都是在gitbash中用npm工具安装就好了。 先创建一个文件夹（用来存放所有blog的东西），然后cd到该文件夹下。 安装hexo命令：npm i -g hexo （这里说一下，nmp的速度太慢了，国内的镜像有很多的bug，所以用cnpm——淘宝镜像） cnpm安装： 命令行输入：npm install cnpm -g –registry=https://registry.npm.taobao.org （就这么简单。。。然后以后输入的时候npm就在前面加一个c就OK） 初始化命令：hexo init ，初始化完成之后打开所在的文件夹可以看到以下文件： 解释一下： node_modules：是依赖包 public：存放的是生成的页面 scaffolds：命令生成文章等的模板 source：用命令创建的各种文章 themes：主题 _config.yml：整个博客的配置 db.json：source解析所得到的 package.json：项目所需模块项目的配置信息 做好这些前置工作之后接下来的就是各种配配配置了。 一些hexo常用指令 （有时候会因为一些插件的原因冲突，自行百度就好或者cmd输入hexo看看一共有什么命令） # 本地预览 hexo s # 根据配置文件和主题，将 root/source/_post 下的 markdown 文件生成 html 内容 hexo g # 清空 hexo g 生成的内容，内容在 root/public hexo clean # 将本地生成 url 链接推送到百度，让百度爬取其中的内容进行索引 hexo d # 根据 标题名称 在root/source/_post 生成 markdown 文件 hexo new post 标题名称 （在一些编程语言中”#”也代表着注释，文件_config.yml里面的#就表示注释） 部署 没账号的创建账号（这我不多说），有账号的看下面 创建一个repo，名称为yourname.github.io,其中yourname是你的github名称，按照这个规则创建才有用哦，如下： 回到gitbash中，配置github账户信息（YourName和YourEail都替换成你自己的）： 创建SSH 在gitbash中输入：ssh-keygen -t rsa -C“youremail@example.com，生成ssh。然后按下图的方式找到id_rsa.pub文件的内容。 将上面获取的ssh放到github中： 添加一个 New SSH key ，title随便取，key就填刚刚那一段。 在gitbash中验证是否添加成功：ssh -T git@github.com 完成下一步你就成功啦！ 5.一步之遥 用编辑器打开你的blog项目，修改_config.yml文件的一些配置(冒号之后都是有一个半角空格的)： deploy: ​ type: git ​ repo: https://github.com/YourgithubName/YourgithubName.github.io.git ​ branch: master 回到gitbash/cmd中，进入你的blog目录，分别执行以下命令： ​ hexo clean ​ hexo generate ​ hexo server ​ #hexo clean 不是必要的，有时候需要加一些自己的东西，如果hexo​ clean后自己的东西就不见了，如果自己的东西，那就推荐hexo clean 注：hexo 3.0把服务器独立成个别模块，需要单独安装：npm i hexo-server 输入完hexo server后，打开浏览器输入：http://localhost:4000 （如果该端口有其他的东西，可以调到其他的端口，自行百度，官网有，我就不在这多说了） 到这一步，你就可以搭建一个自己的内网的网站 上传到github 先安装一波：npm install hexo-deployer-git–save（这样才能将你写好的文章部署到github服务器上并让别人浏览到） 执行命令(建议每次都按照如下步骤部署)： ​ hexo clean ​ hexo generate ​ hexo deploy 注意deploy的过程中要输入你的username及passward。如下： 在浏览器中输入http://yourgithubname.github.io就可以看到你的个人博客啦，是不是很兴奋！ 感觉gitbash中东西太多的时候输入clear命令清空。 （部署完后大概3分钟左右就可以访问到新的内容） 6.优化 一，coding（因为篇幅较长，我就不加图片，如果需要就找度娘或找我） Coding与Github相似，都是基于Git的代码托管平台，GitHub大家应该都很熟悉，相对与Coding来说，GitHub面向英语系国家程序员，Coding面向中国程序猿，而且Coding的私有库可免费使用这是最大的区别。两者的用法和操作其实大同小异。（Coding的优势是服务器在国内，访问速度快，缺点是有时候有一些玄学的因素，域名无法控制。。。） 新建仓库： 打开coding主页，创建新项目 新建一个名为yourname.coding.me的项目，其中这里的yourname最好是coding注册时的username，等项目部署成功后它就是你博客的访问地址。如下所示coding可以创建私有仓库，GitHub中是要收费的。 开启Pages服务，开启后我们就可以通过用户名+网站后缀来访问博客，而且还可以绑定域名通过固定域名来访问。进入项目-&gt;代码-&gt;Pages服务 在管理Git项目时，无论是GitHub还是Coding我们可以通过SSH、HTTPS两种方式来clone或者push代码，当使用HTTPS的方式来管理代码，每次操作时都需要验证用户名和密码；而使用SSH方式Push代码之前需要配置个人的SSHkey,这样就可以省掉繁琐的验证步骤。 当然，我们也可以选择通过HTTPS方式来进行项目的管理，那么请跳过SSHkey的配置步骤，直接阅读项目部署步骤的内容。 _config.yml文件的配置和GitHub大同小异，我不多说了 二，主题 风格不喜欢？换之。 这是 hexo默认的主题，我们需要修改这个主题，那么我们可以去找一些符合我们个人爱好的一些主题选择一个自己喜欢的Hexo 主题：https://hexo.io/themes/ 更换主题流程：下载主题 -&gt; 配置主题，以 xoxo 为例（不要想歪了！） # 下载到themes文件夹下 git clone https://github.com/KevinOfNeu/hexo-theme-xoxo xoxo # 修改 _config.yml 配置 theme: xoxo 很多的主题都会有一定的介绍，根据介绍摸索也可以的（我就是自己摸索的） 三，插件 Hexo中有很多优质的插件，具体可以在我做的社团网站欣赏：GW-Lazybones.github.io 里面有很多我认为优质的东西，比如说，二次元看板娘，音乐播放的实现，语法高亮的实现等等 插件推荐：hexo-generator-searchdb: 用于搜索 hexo-generate-feed: 用于生成RSS订阅 hexo-generator-index-pin-top: 用于文章置顶 hexo-blog-encrypt：用于文章加密 hexo-tag-aplayer：用于播放音乐 hexo-tag-aplayer：用于播放音乐 hexo-helper-live2d：二次元看板娘 更多插件请见 hexo插件市场 四，其他 还有一些东西，比如说评论的接口，访问的统计，如何被百度等搜索引擎给收录等等，都可以单独拿出来讲， 这常常会有很多很玄学的东西，如果遇到了一些bug我可能有一点帮助。 其实绝大部分的东西在官网就可以解决，而且浏览hexo官网会有很多意想不到的发现，为自己的网站更加的完善 如果有兴趣的可以加我qq：503404172 （直接在大群里也OK） 还有我们社团的新的网站：https://gw-lazybones.github.io 如果有Markdown特别感兴趣的同学可以和我联系（为社团网站添砖加瓦） 大家可以积极投稿，我们都会展示到社团网站的，因为我年纪小，刚刚做副社，所以有很多东西没有那么熟练，请各位谅解，并且提出有益的意见，谢谢。 关于我：一个喜欢搞UE4的（复刻GW，结果发现我不是第一个。。。） 会一点点C++，Python，一点点网页，知道一点点网安 其实上面的部署可以自己写一个程序，用Windows.h就OK了（源码太简单，我就不打出来了） 以后的社团活动通知会发在Q群上，每次课的知识都会发，请留意。 UE4项目进展（以前项目的工程文件还没用拿到，所以重新开了一个）： 模式是第一人称和第三人称，内网联机在技术上是可行的（暂时还没有弄，外网的以后再说吧），我用了光线追踪，最高画质，所以对配置的要求较高，（以后会搞画质调节相关的），现在UI还没有做，支持win7以上的64位系统，安装包800M左右，安装下来差不多1.4G，最低配置：i5-4，内存6G。推荐i5-7以上，内存8G不卡。 （这纸还有挺多空位的如果想记就记‘亿’点点笔记吧）** Attention：这张纸以后要用，所以请保留好，谢谢 大家希望以后讲什么，可以在群里@我也可以私信 在最后，祝大家的代码没有BUG","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"别撞柱子","slug":"别撞柱子","date":"2020-05-30T01:36:23.000Z","updated":"2020-05-30T01:44:14.740Z","comments":true,"path":"2020/05/30/别撞柱子/","link":"","permalink":"http://yoursite.com/2020/05/30/%E5%88%AB%E6%92%9E%E6%9F%B1%E5%AD%90/","excerpt":"","text":"c++自制游戏之一——别撞柱子 up主页 我的主页","categories":[],"tags":[]},{"title":"编程社本学期第一篇公告","slug":"编程社本学期第一篇公告","date":"2020-05-23T10:59:48.000Z","updated":"2020-05-23T11:49:48.788Z","comments":true,"path":"2020/05/23/编程社本学期第一篇公告/","link":"","permalink":"http://yoursite.com/2020/05/23/%E7%BC%96%E7%A8%8B%E7%A4%BE%E6%9C%AC%E5%AD%A6%E6%9C%9F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%85%AC%E5%91%8A/","excerpt":"","text":"因为疫情的原因，我社很久没有开展社团活动了， 我们将在下个星期向老师申请场地， 并且尽量固定场地。 下周社团活动的通知正常来说会贴在饭堂门口， 请留意。 ​ 此为社团网站， 开启了留言功能， 欢迎在下方留言。 ​ 因为没钱买服务器和域名 所以就凑合着用吧 ​ 在网站中调用了网易云音乐的接口， 所以会有音乐 ​ 还有电脑端会有一个看板娘在右下角， 挺好玩的，就加了 （在作死的边缘试探） ​ ​ ——广外编程社的一个”新副社长“","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"置顶","slug":"置顶","permalink":"http://yoursite.com/tags/%E7%BD%AE%E9%A1%B6/"},{"name":"pyrhon","slug":"pyrhon","permalink":"http://yoursite.com/tags/pyrhon/"},{"name":"RPG Maker MV","slug":"RPG-Maker-MV","permalink":"http://yoursite.com/tags/RPG-Maker-MV/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"nodejs","slug":"nodejs","permalink":"http://yoursite.com/tags/nodejs/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}